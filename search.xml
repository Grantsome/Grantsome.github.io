<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[流形奥秘临一瞥—-我的处女作:微分流形笔记]]></title>
      <url>%2F2020%2F04%2F21%2F%E6%B5%81%E5%BD%A2%E5%A5%A5%E7%A7%98%E4%B8%B4%E4%B8%80%E7%9E%A5%E2%80%94-%E6%88%91%E7%9A%84%E5%A4%84%E5%A5%B3%E4%BD%9C-%E5%BE%AE%E5%88%86%E6%B5%81%E5%BD%A2%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[历史上最好懂的微分流形笔记，没有之一! 导语作为微分几何方向的学生，在学微分流形的时候始终会感觉有一些困难，于是我整理了这一份笔记，是微分流形入门的所有中文资料中最好的笔记，没有之一！ 简介本笔记是云南师范大学数学学院2019年秋季郭震教授所开研究生基础课程“微分流形”的笔记,笔记中大部分内容均来自于老师上课的讲述,其中很大部分笔记参考了刘泓斓小姐姐的笔记和同门师姐吴元芬的笔记以及同门同届马江涛小哥哥的笔记,并且也部分的参考了平锐小姐姐的笔记和张徐小姐姐的笔记以及于秀君小姐姐的笔记,在这里谨向她(他)们表示感谢. 写作起源笔记主要包括如下内容:多重线性函数基础、微分流形初步、子流形理论、流形上的微积分。之所以想要整理一份LaTeX 排版,起源于自己上课不记笔记的这种懒惰恶习,偶尔抄一抄笔记也只是用A4纸,但A4又不方便保存,容易丢失.从而有了做一份PDF的笔记方便自己需要查阅的时候在手机上翻看和复习的想法.另一方面,希望对那些和我一样懒以及对微分流形有兴趣的同学有些帮助. 一些说明另外,笔记中附加了两篇博客,分别是关于认知心理学和数学学习方法的文章,这大多是在我考研完了之后的一点点观察,希望对那些对学习数学有疑惑的人的一点点帮助。由于笔记整理时间匆忙,加之理解能力有限,学识不足,并且对 \LaTeX 排版不熟悉,故笔记必然有诸多纰漏之处,希望各位多多批评指正.欢迎各位读者朋友就书中的内容与我讨论,我的邮箱1278603466@qq.com. 获取方式关注微分公众号：数理逍遥侯，后台回复：微分流形笔记。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[星辰日月此生活——研一上半学期学习生活浅谈]]></title>
      <url>%2F2019%2F11%2F01%2F%E6%98%9F%E8%BE%B0%E6%97%A5%E6%9C%88%E6%AD%A4%E7%94%9F%E6%B4%BB%E2%80%94%E2%80%94%E7%A0%94%E4%B8%80%E4%B8%8A%E5%8D%8A%E5%AD%A6%E6%9C%9F%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB%E6%B5%85%E8%B0%88%2F</url>
      <content type="text"><![CDATA[开学两个月了，我也不知道自己在干什么。浑浑噩噩的日子，每天的穷忙族，好像很忙。实际上每天没有什么规划。写词一首，抒发感情。要说这半学期做了什么，我只能说什么也没做，聊天倒是聊得挺多的，乱七八糟的事情也做了不少。想学的PS还没有开始学，想看的红楼梦没看，想学的微分拓扑没学，想懂的黎曼几何没学，想看的同调代数没看，想整理的泛函分析的笔记没整理，想整理的抽象代数的笔记没整理。想早上写点字修身养性没写，以前每天晚上散步的习惯也没有了，想多思考一些问题的没有思考，想读得毛泽东传没有读，想做的题没有做。想写的文章没写，想更新的博客没更，想做的公众号没推送，想观察的人和事没有观察……每天在干嘛？整理笔记、改作业、准备习题课、和别人聊天瞎吹、听歌、各种聚会、看电影、打球、晒太阳、和别人讨论、写点微分几何的LaTeX、玩手机、逛知乎…… 解决之道总结过去与规划未来承认说总结过去的确是一个不错的习惯，但也不能沉溺其中。如同我们应该多参加社交活动但不能迷一样。总结过去也是，我们需要的是对过去的观察和反思，而不是顾影自怜忆往昔。有时候总结过去也许什么也看不见，这时候可以换个思路，规划一下未来。 江城子.混沌八月奋战是豪情，欲飞天，难料定。当头棒喝，谁知我去向。三番波折落尘埃，岁月奔，到今天。不觉时间已过半，未成学，无立志。凝望长空，滋味更哪般。应笑世间穷忙人，纵劳苦，功不见。 临江仙.畅想滴滴心血任流淌，情意困尽天下。爱恨情仇何时休，缘分依然在，一梦痴心留。清风之上阴沉有，也道天行之中。丑年相合天喜庆，还待月圆日，共赏花开美。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[南望重邮又四年——本科学习生活浅谈]]></title>
      <url>%2F2019%2F06%2F04%2F%E5%8D%97%E6%9C%9B%E9%87%8D%E9%82%AE%E5%8F%88%E5%9B%9B%E5%B9%B4%E2%80%94%E2%80%94%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB%E6%B5%85%E8%B0%88%2F</url>
      <content type="text"><![CDATA[促成质变的因素中，观察和反思才是稀缺的，时间是微不足道的。(未完待续)本科四年，细细想来，人生大概来了四分之一到三分之一。而自身诸多毛病，未能静心沉淀自己。三言两语，以警自己。顺便对未来有所展望。 过去的意义阴阳之道恐怕没有什么东西所蕴藏的智慧比得上《周易》。而阴阳之道作为周易思想的基本建筑块，其应用的效果亦不可小视。在更高的意义上讲，中医便是周易的一个应用。同性相克，异性相吸，物极必反，阴阳平衡。举例来讲用微观的方法去理解宏观的事情，用宏观的方法去理解微观的事情。用长时间跨度去分析当前的行为，尝试用短时间跨度分析长远规划。不要被眼前的得失一叶障目，也不要被幻想出来的得失冲昏头脑。处于顺境切记不要骄傲大意，处于逆境需要乐观。 情绪管理情绪的控制能力 无限的游戏所谓无限的游戏，大抵是没有边界、没有终点、没有输赢、不可重复的游戏。相反，那些具有边界、有时间限制、有终点、有输赢的游戏则可被看做“有限游戏”。考试、工作、权利、头衔、性、 观察与意识在大多数情况下，实际行动都是发生在其主观意义处于模糊的半意识、或者实际上处于无意识的状态中，行动者更有可能是在模模糊糊的意义上“知道”它，但并不明白自己正在干什么或者对它有着明确的自觉意识。 他的行动大多受本能驱使或者习惯使然。只是在偶然的、并且涉及大量同一行动的情况下，往往也只有少数人对于行动的主观意义——无论理性的还是非理性的——产生明确的意识。 完全自觉和明确的有意义行动的理想类型，只能是一种边缘情况，在分析经验事实的时候，任何历史学和社会学的研究都必须考虑到这一点。–韦伯《经济与社会》每当谈到观察与意识的时候， 往事每当我觉得我现在做的事是对的时候，我就开始酝酿下一个错误。每当我觉得自己错了的时候，最终却错得没有那么离谱。本科四年，说短不短，说长不长。既不是很满意，也没有特别失望 生活的本质太极图和DNA的双螺旋结果是两种很有意思的东西。历史会重演但每次都不一样，如同DNA双螺旋结构，它始终螺旋上升但每次都不尽相同. 未来的展望参考文献《有限和无限的游戏》《一生的学习》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我拿什么拯救你的无聊]]></title>
      <url>%2F2019%2F05%2F25%2F%E6%88%91%E6%8B%BF%E4%BB%80%E4%B9%88%E6%8B%AF%E6%95%91%E4%BD%A0%E7%9A%84%E6%97%A0%E8%81%8A%2F</url>
      <content type="text"><![CDATA[谨以此文献给一些敢于批评我的人，是她们的启发了我而写了这篇文章。网速再快也带不走你的无聊感！面对无聊，我们需要做的，不是逃避无聊，而是拥抱并创造无聊。在手机的阴谋–信息时代的最大骗局这篇文章中说到了关于手机的一些东西，这是两年前我写的东西，现在看来这种文章毫无任何质量可言。不过那仍然是过去的痕迹。不必要去抹去过去的那些印记，无论好坏。但现在，我们可以更好的展示过去的那些东西，至少把过去写过的东西做那么一点点的升华。 无聊的产生]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[易道不易非常易--思维的陷阱与人生的真相]]></title>
      <url>%2F2019%2F04%2F27%2F%E6%98%93%E9%81%93%E4%B8%8D%E6%98%93%E9%9D%9E%E5%B8%B8%E6%98%93-%E6%80%9D%E7%BB%B4%E7%9A%84%E9%99%B7%E9%98%B1%E4%B8%8E%E4%BA%BA%E7%94%9F%E7%9A%84%E7%9C%9F%E7%9B%B8%2F</url>
      <content type="text"><![CDATA[以生命的尺度去衡量，变化就是美。 数学思维妙用数学是有用的，学数学的人思维的确会很不错，当然，前提是数学学的好。 平凡与非平凡“人活着就只有一个理想，就是不停的提升自己的层次。”——曾仕强数学里面有平凡与非平凡的概念，简单来说，每种事物都有的性质就叫做平凡，一些特殊的事物才有的性质就叫非平凡。做事情和做人也是如此，知道什么是平凡的，什么是非平凡的。这对于你抓住关键和重点大有裨益。这里或许可以拿出马克思主义矛盾学说：事物的主要矛盾对事物的发展起着决定性作用。以学习数学为例，看书是平凡的，发现书中的错误和不合理的地方是非平凡的。听课和看书是平凡的，做有挑战性的题和思考自己看不懂的地方是非平凡的。看到“留给读者、容易看出、显然、有兴趣的读者可以参考”这些数学教材/参考书是平凡的，去详细的写出这些地方的证明是非平凡的。做别人给你出的题是平凡的，自己给自己出题并做出来是非平凡的。看重要定理的证明是平凡的，自己独立思考定理的证明或者看完之后找个时间“默写”定理的证明时非平凡的。学习数学是平凡的，研究数学是非平凡的。这只是一些我在数学学习时候的那么一点点经验的总结，做人和做事有着更丰富和复杂的东西。以做事为例，做简单的事情是平凡的，做重要而富有挑战的事情是非平凡的。学习新东西是平凡的，检测自己的水平(教会别人、考试、独立做些东西等)是非平凡的。有能力和才华是平凡的，深藏不露是非平凡的。聪明是平凡的，智慧是非平凡的。注重大的改变(升学,工作,结婚等)是平凡的,注重平日里微小的改变积累是非平凡的。做一件事风风火火的开始,立下壮志是平凡的,在开始之后仍然能十年如一日的有战略的坚持是非平凡的。 抗拒变化习惯不仅不可以成就一个人，而且还可以毁灭一个人。一个人做自己擅长的事情是会上瘾的。 抓重点而不是全面大部分人都高估了大的改变(升学,工作,结婚)等对我们的影响,而忽略了平日里可积累的微小改变所能带来的巨大而实质的影响。合抱之木，生于毫末。九成之台，起于累土。千里之行，始于足下。——老子《道德经》路虽远，不行不至。事虽小，不为不行。——《荀子.修身》曾国藩有十六条家训和十二条修身，每一条看上去都不难，都是寻常人可以做到的，但积累一段时间对自身的影响相当的大。 现在开始做而非等待未来让未来今天就来。很多人都喜欢等待，等到开学，等到下周，等到明天，等到有钱了，等到…然后，他们就会开始做新的事情。似乎人们都认为，未来就有时间了，为了就怎样怎样了。但事实上，那个未来可能只存在于他们的想象之中。 享受过程而非盯着目标如果一个人减肥的时候，天天盯着体重秤，恐怕减肥是一个很痛苦的过程。世界杯中参加比赛的球队那么多，那些获胜的队伍和没有获胜的队伍的差别在哪儿呢？他们的习惯体系是不同的。曾国藩是我很喜欢的一个人物，他的那句话可以分享给大家。不为圣贤，便为禽兽。但问耕耘，莫问收获。古人也早就有了劝告,是非审之于己，毁誉听之于人，得失安之于数。 归纳法的谬论相信导致愚蠢，特别是相信自己先入为主的观念，或者说你最开始秉持的观点，你会继续寻找证据支持你的观点。如果你开始采取怀疑的观点，你会为你的怀疑寻找证据。 引言《黑天鹅》的作者在书中提到一个经典案例：火鸡的故事。每天早晨农夫会带着一碗玉米来喂火鸡。火鸡对此形成了习惯，每天早上听到农夫走进鸡棚的声音，他就知道开饭的时间到了。渐渐的，火鸡总结出来一个规律：只要农夫走进，就是自己吃大餐的时候，这个时候也是它一天中最为快乐的时候。到了感恩节那天，农夫像往常一样走进鸡棚，火鸡像往常一样欢呼雀跃，但是没有想到的是，农夫受理拿的把原始股玉米，而是一把斧子，因为感恩节那天吃火鸡嘛……归纳法的确能够帮助我们解决很多问题。但世界不是线性的，我们的生活基本上都是不可归纳的，能够归纳的东西必然具有很多特殊的性质，想当然的去对事物做归纳往往会得到一些会被现实打脸的错误结论。比如你看到的天鹅，在亚洲看到的是是白色，在欧洲看到的是是白色，在美洲看到的也是白色，于是你认为“所有的天鹅都是白色的”。但只要找出一只黑天鹅，甚至在地球之外找到一只黑天鹅，那么这个假设就自动瓦解了。事实上，在发现澳大利亚的黑天鹅之前，17世纪之前的欧洲人认为天鹅都是白色的。归纳法的要点在于经验总结，而经验总结背后所隐藏的一种特殊的性质：时间上未来必须要和过去一样，(空间上)整体必须要和局部一样。今天你看到太阳东升西落，明天太阳也东升西落，于是久而久之，你得出结论。太阳每天都是东升西落。但某一天出现日全食，太阳没从西方落下就不见了……从此之后你世界观崩溃，太阳居然可以不落下就不见了。一些没怎么接触女孩子的男生遇到了自己心仪的女孩子，一直怀疑对方是不是也是喜欢他，拼命的寻找证据，今天女孩子对他笑了一下，昨天女孩子和他打了声招呼，前天晚上他给女孩子发消息她秒回了。​一个行为一个行为的归纳对方是喜欢自己的，然后积累到某一天表白惊讶的发现​自己被发卡了。归纳的诡异的地方在于，他会让你只关注你想要归纳所得到的结论相关的例子和行为，就像你带上了某种特殊的眼镜，那种眼镜只能看见一种颜色，让你在信息不对称不完整中遭受到毁灭性打击。到底什么东西适合归纳什么东西不适合归纳呢? 如何避免归纳法给你带来的这种巨大的打击呢? 适合归纳的性质马云的那句话值得参考：成功是各种运气和禀赋努力的结果，但导致失败的原因就那么一些，避开这些东西比追求成功来得更加实际。基本上来说，负面的东西我们可以归纳以避免踩雷区，而正面的东西归纳法往往会得到一些谬论。这也就是为什么成功学基本全是忽悠，真正的成功人士都应该明白谋事在人，成事在天的道理，明白运气对自己的成功具有不可小觑的作用。这种谦卑来自于对社会和人性的深刻观察。这就是为什么网上很多所谓的考研成功经验：各种标题党：“逆袭———从三本到985的考验之路”类似的经验贴并不会对你考研产生多么大的帮助的原因。现代人的思维中有这么一种倾向：如果一个人做成了某件事情，他会倾向于把原因归结为自己的努力和自身的禀赋而不是运气！如果一个人做某件事情失败了，他会倾向于把原因归结为运气不好，而不是自己没找到学习方法和不够努力。但中华传统文化却恰恰相反，本着事了拂衣去，深藏功与名的谦卑与智慧，功成不必在我的观念早已经深入骨髓。谋事在人成事在天并不是代表着对“天”的迷信，而是对社会造化的环境机遇与出其不意的偶然契机的一种尊重和共存。事实上，国外的一些学者也表达过类似的观点。罗伯特·弗兰克在《成功与运气》提到过如下的一些见解：1、几乎所有的成功都有运气的因素。把成功原因归于自己水平高，这让我们自我感觉很好，这是人的本能。在本博客当中，我会反复强调一个东西，那就是人性本身的存在对了解更加真实的世界的干扰，我们并不能改变人性本身，我们也不需要这样子做。我们需要做的是做事情的时候跟自己死磕，反自己的人性并利用自己的人性。在做人对待别人的时候需要顺应别人的人性并利用他们的人性。大脑有个特点：1、需要让自己感觉良好，需要让自己的独特感，总是希望自己是不平凡的，但这恰恰是一个人最平凡的体现。这一点在情感心理学上表现得尤其明显：女性希望男性能看到自己独特的那一面，她们希望在自己心仪的男性面前是独特的，漂亮的女生总是希望别人能够欣赏她的感情的细腻和精神世界的有趣，而不仅仅只是每个人都能看得见那一张漂亮的脸蛋，有的女生总是希望自己所谓的以德服人地感动和自己的独特性能够独特到让渣男回归好男人，让浪子回头。女性的心理弱点被国内的PUA运用的炉火纯青，更多敢于情感的论述会在后面一一道来。2、实验：抑郁症患者能够客观地评估自己的能力，正常人往往错误归因，用自己骗自己方法在生活中前行。曾经有一项很有代表性的调查研究：研究者对开车的司机进行了调查，请他们评估自己的驾驶技术，调查的结果是：百分之八十的司机都认为自己的水平超越了百分十五十的司机，也就是百分之八十的司机都认为自己的水平超越了平均水平(也就是处于一半的百分之五十处)。听上去是不是觉得有点喜感? 在这里分享一下我经常用的一种方法：\textbf{把自己对自己的能力评价变为原来的一半或者百分十三十七左右}，那可能才是你真是的水平。3、人总是把成功归因于能力强，而把失败归因于运气差，这种乐观如果没有成功就是需要的，如果已经成功就不需要。这就解释了为什么成功学不靠谱，归纳正面的东西不靠谱的原因。讲完了为什么不能归纳正面的东西，我们回到适合归纳法的东西，一般来说：让你失败的感情经历，让你失败的学习经历，让你陷入泥潭的思维和做法，让你感受到非常痛苦的东西都可以归纳你为什么导致了这样的结局。越是让你痛苦的东西越是能够让你悟到很多道理。对待痛苦的经历的方式是接纳痛苦而超越痛苦，归纳法就是超越痛苦的那一步。我喜欢的几个历史人物之一的伟大的毛主席早已经用一句话表达过类似的观点：丢掉幻想，准备斗争！(《毛选第四卷》),丢掉你那些对自己的能力的幻想，随时准备接纳痛苦在痛苦中斗争并成长。 我是我的问题的解决者和回答者思维角色的互换可见解决之道很多时候，人们总是喜欢向比自己厉害的人提问，当然，我希望的是，在提问之前，请你自己先尝试回答一下这个问题。 更少而非更多做事情是要少做事，而不是要多做事。 参考文献《能力陷阱》《掌控习惯》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数理乾坤自分明--如何科学的学习和理解数学]]></title>
      <url>%2F2019%2F04%2F14%2F%E6%95%B0%E7%90%86%E4%B9%BE%E5%9D%A4%E8%87%AA%E5%88%86%E6%98%8E-%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E7%90%86%E8%A7%A3%E6%95%B0%E5%AD%A6%2F</url>
      <content type="text"><![CDATA[学习、理解和思考数学的精髓，探索之途，早已蕴藏于所有生命的本身之中(未完待续)。作为数学系毕业的学生，是时候写一篇关于专业学习的东西了，此文与考研二三事–悟道学习存心法互为姊妹篇如何学习科学的学习数学，或许是一个过于宏大的话题。对于我这种数学基础本来也不怎么好的人而言，似乎有点吃不消了。即使对于大数学家而言，这也不太像是一个简单的问题。我想，鄙人一点浅薄的看法，也许会对一些人有启发吧。更重要的是，总得有一些自己的观点。这才像学数学的人应有的态度 。阅读本文之前请阅读上面提到的本文的姊妹篇，以便在讨论学习数学学习之前，对学习方法有着一定的认识。 求木之长者，必固其根本。欲流之远者，必浚其其源. –唐.魏征我们必须知道，我们终将知道——希尔伯特 数学天敌个人觉得，如果是纯粹学数学，感到难是因为前提基础不够，而自己太希望快速学好了，但是数学学习是最忌讳浮躁的。欲速则不达，见小利则大事不成。学而不思则罔，思而不学则殆。学习数学知识和做数学题之间一定要有一个平衡。同样的，在理解数学思想和计算功底之间也要有一个平衡。误区一：沉迷于某一个知识层次的解题技巧，而没有深入学习更高层次的知识，技巧越玩越花，但是思考问题的角度、处理问题的方式却没有实质性的进步。误区一的对偶：某一个层次的知识还没有足够的训练，就去追求更高层次的知识，看似知道了很多，但是什么问题都解决不了。误区二：一方面要理解抽象的概念，另一方面还要会算、举例、应用。抽象的概念是别人告诉你的，而计算才是你得花时间去“参与”的。 大家之言摘录小平邦彦的一段话：我一般只看定理，努力去理解定理，然后自己独立思考数学证明。不过，大多数情况下都百思不得其解，最终只能参考书上的证明。也许有人不解。为何要如此左思右想？直接读到最后一页不就好了吗？话虽如此，不过这样会存在一个问题。在数学书中，读完以后到底能否彻底解决彻底理解，我对此持有怀疑态度。理解数学书是一种怎样的状态呢？只要一步步验证已确认证明过程无误就行了吗？在阅读数学书籍的时候，我发现即使确认了证明的求证过程，之前不理解的定理仍然不得其意。虽然证明过程正确，但总感觉整体印象模糊不清。但我们为什么能够清晰的理解2+2=4呢？是因为自己是从感觉上把我了这一数学事实，而不是通过论证。定理的；理解同样如此，应该从感觉上把握定理所要表述的数学事实，而不是通过论证。尝试摸索定理的证明过程，是一种从感觉上把握定理的方法，而并非为了检验证明过程的正确性。想要更好的理解定理，仅仅读一遍定理是不够的。将定理运用于各种问题之中才是有效的方法。花时间详细分析定理所要表述的数学事实的结构是正确的方向。数学是一门具有高度技术性的学问，如果出现理解证明过程却无法理解定理内容的情况，说明把握数学事实的感觉还不够发达。数学如同雕塑，普通的木头里面没有埋藏着定理。不过，仅仅从外表观察，并看不出里面究竟埋着什么，所以只好尝试雕刻看看，数学中的雕刻就是繁琐的计算和查阅文献，绝不是什么简单的事情，往往会竹篮打水一场空。想要理解数学，只能一步一步遵循证明过程，去体会它们表述的数学事实。我们之所以只有通过认真阅读、验证证明过程才能理解定理，是因为证明过程不仅仅是验证手段，其背后隐藏着高于验证的东西，也许我们能否清晰明了的理解数学在很大程度上取决于能否把握这个东西。 伍鸿熙先生有一段话：一、你们会了解到书内的定义和定理既是人为的，又同时是合理的。也许你们人为一本书要写得高深莫测，才能显出作者的学问渊博。但是我却希望你们会觉得书中的一切，不但是理所当然，而且是容易得到的，只要自己花一点功夫就可以自己做出来。要做到这一点，除了一般的”定义、定理、证明”以外，我设法多加一些术语来说清楚每一个概念的来龙去脉和直观意义。另一方面我也要指出，书内的概念和结果之所以被认为是基本性的，并不是因为某某权威说过是如此如此，而是因为经过时间的考验后，发现的确如此。就是说，从经验的总结，我们现在知道这些概念和定理是有用的和必须的。所以一个初学者应该致力于探求为什么所学的是有用的和必须的。否则不能对所学的内容有一个全面的了解。这种治学的态度，其实不单适用于数学上，而是适用于一切学问的领域上，包括社会科学在内。其次，我希望你们能够把握每个定理、每个证明、每个概念的要点。一本好的数学书应该不同于一本字典，在后者中每一个字都占有同样的地位。但是如果说一本数学书中每一个定理、每个证明、每个概念的要点都相同的重要，未免就太荒诞无稽了。比方说，弧长的二次变分公式只是一个一般性技巧性的结果，要点在于弄清楚如何将他应用于具体的情况，而不再探讨这个公式本身的深度和公式的推导，所以不应该只给出公式而不给出应用，更不应该把这个公司当作主要定理之一。又比如，Synge定理的证明看上去是相当累赘的。但是如果从一个很直观的事实作出发点，就是”任何一个非连通的紧致黎曼流形上必存在一个非同伦于零的最短闭曲线”，则其他一切都是顺理成章的、所以我希望你们能够培养一个习惯，总要问，这本书的要点何在？这一章的要点何在？这个证明的要点何在？能找到这些所有问题的答案，才能说有真正的了解。最后，我希望你们能够以完全直观的眼光去了解本书的内容，所有的数学书都是充满了技术性的术语的，因为为了要表达清楚，作者毫无选择的余地。但是一个数学工作者的思考，大部分时候都是靠直观(甚至是过分简化的直观)的想法来推进的。在几何学方向这一点尤其重要。所以书内这一类直观的讨论，比其他的数学课本会多一点。也许你们还迷信所谓的数学严格性的证明，以为数学上最重要的是每一步推论的正确性，这个论点，相当于说鲁迅文章的好处是每一句都很通顺。希望你们不会犯这个”见小不见大”的毛病。 “搞数学不需要太聪明，中等天分就行，主要是毅力和专研。” –张广厚“我早上醒来，想得第一件事就是数学，我的生活就是数学，终身不倦的追求就是数学。十年如一日，没有懈怠过，现在我每天至少花七八个小时思考数学。” –陈省身“每天思考七八个小时的数学，而不是呆在办公室学习七八个小时。事实上，没有个十年八年的时间，是很难成为一个合格的数学工作者。”–陈省身 个人之见当然，以上是大师们的看法。下面谈谈我自己的看法。我主要讨论听课和看书这两个角度来谈数学。首先坦然看书，口诀是：直观理解化、合理启发化、要点条理化。 心法是：一题不做，何以做数学？一例不知，何以知学问？一字不疑，何以疑定理？一句不思，何以思推广？一惑不解，何以解猜想？一理不悟，何以悟证明？一法不创，何以创学科？大体来讲，无外乎以下几点：要知道一个定义的motivation，也就是为什么要引进这个定义？最初引进这个定义的动机和目的是什么？为什么要这么定义？为什么是这样定义而不是那样定义？可以从来下简单的例子的启发由此导出这个定义？如果不这么定义有什么问题？一个定理到底是怎么来的？可以从哪些显而易见的事实中归纳出来？我自己是否可以尝试自己去证明这个定理？为什么要这么证明？有没有其他的证明思路和证明方法？要点在哪儿？这些方法各自的优缺点在哪儿？这个定理有什么应用？剩下的，就是做一些习题练习和尝试修改定理的条件看看能否得到其他的结果。具体的操作手段(请结合本文的姊妹篇的学习心法部分)，学数学至少有三遍。第一遍：看一遍书上的主要内容，过一遍书上的主要证明逻辑。第二遍：做一遍书上的习题，并对书上的定义定理给出例子和直观理解，对证明写出要点评注。第三遍：默写全书的主要内容。三者亦可以有机的结合在一起。最核心的东西是：去思考定义和定理的来龙去脉，质疑它们为什么会是这样子。学习数学有几个东西很重要：一、怀疑 二、自信 三、观察 四、思考在我看来，数学的本质在于，怀疑一切的力量(可以参见本文姊妹篇中的这部分内容，里面有着详细的心法)。剩下的，需要的是深刻而空灵的洞察力。看书的目的不是要你去相信，也不是要你去检验一遍书上的定理证明和定义是否有着逻辑上的错误。你可以尝试站在上帝的眼光去看待一本数学教材和参考书:你是来找出该书有什么不合理的地方的，你是来找出书中隐藏的错误的，你是来与作者共同修改和完善这本教材的，你是来检查书上的习题安排是否合理以及是否有错误的习题的，你是来重新获得前人赠予的知识和探索前人走过的路。而不是去“相信”这本教材，没有什么东西是在独立思考之前值得“相信”的。那些前人赠予我们的知识，如果我们需要，我们还得重新去“获取”他们。这边是上面口诀的核心。但看书只是一方面，对于数学而言，是一定要做题的，你不做题是无法检验自己的理解程度的。要有一定的习题量但也不能恋战。做题是为了增强理解和记忆，促进独立思考。当然，很多时候看书看第一遍是非常“一脸懵逼”的，这时候可以换一种方式：听课/看视频代替看书。相对而言，基础数学研究生课程稍微难一点，我的了解里面。本科的那些(数学分析、高等代数、解析几何、常微分方程、复变函数、实变函数、泛函分析、抽象代数、点集拓扑、偏微分方程、微分几何、初等数论)都还是比较适合自学的。但研究生的一些课程，比如微分流形、代数拓扑、黎曼曲面、代数几何、同调代数、黎曼几何、解析数论、代数数论等课程，自学光靠看书的话的确有些费力不讨好，这时候可以考虑先看看一些公开课的视频或者去听老师讲课，或者先熟悉一下教材和参考书的主要结论而先放弃证明。听课是一件很有意思的事情，但讲课比听课更有意思。至于如何听课，我周围有两个特别典型的听课的同学。其一是阿昕，这一位是有一些数学天赋的同学，可以说是我本科同学里面最为聪明的一个。他听课很有意思，以葛优躺的方式瘫坐在凳子上，并且偶尔时不时的点头。但老师叫他做笔记他也不愿意做笔记，但他是我们公认的数学鬼才，本学院数学最强王者，没有之一，经常对老师讲过的一些东西保持怀疑态度。其二是杨秀，这是一位非常喜欢记笔记的女生，几乎把老师在黑板上写得东西一字不漏的给抄了下来。是一个非常勤奋的妹子，这一点上我是非常佩服的。但问题在于，她对数学的理解并没有上面的那位同学深刻，并且有时候老师写错了她也发现不了，仍然把错误的东西写到了笔记本上面。下来之后对笔记的消化情况也只是一般，也就是笔记没有起到增强理解的效果。事实上，听课最重要的不是记笔记，这也是我不太愿意做的事情，我更愿意做的事跟着老师的思路走，最多记一下提纲就行了。至于笔记，肯定会有人愿意把老师的板书全部抄在黑板上的。有的人是非常勤快的能一字不漏的把老师的板书写了下来，并且，这种人在每个班上几乎都有。我不是故意去批评这种人，我也没有资格去批评他们(某种意义上讲，在懒人眼中的偶像这是这些喜欢记笔记的人。)，但我想谈谈这种行为背后的心理学认知。这种抄笔记的行为，像极了一种自我欺骗，用勤奋来麻痹自己，我并非说勤奋不好(事实上，我非常佩服记笔记的人，因为这种人大多数比我勤快多了，勤乃立身之本)，而是说，做事情的时候有比勤奋更为重要的事情，特别是数学这种智力密集型学科(与之相对的是劳力密集型学科,只需要好好做事即可)，观察和思考比勤奋更为重要。因为听不懂就想着抄了自己下去看，但是下去也看不懂就不想看从而加剧下次课听不懂，听不懂然后又想抄下老师的板书，如此恶性循环。事实上，这种行为最大的问题在于，这种勤奋的抄笔记的行为是会上瘾的，并且会给自己造成一种感觉，我已经很努力了，我已经尽力了。这种抄笔记的行为也会造成一种熟练度错觉，抄了一遍之后就会觉得自己已经开始对这些已经开始熟悉了。但是因为这些东西并没有经过自己的思考，自己未曾思考的东西并不能达到很深刻的理解，所以这种东西也很容易就忘了。在学习的时候，思考是第一位的，甚至于说思考重于听课，重于看书。思考才是学习的本质，其他的都是微不足道的。自然，也有一些可以解决方案，应对这种抄笔记式学习的方法也有不少，如果能上课不记笔记自然是最好。实在是无法改变的话，我推荐的方法是，第二天(早上)在空白草稿纸上面”默写”昨天老师所学过的内容，如果你能把老师讲得内容全部默写下来，自然是达到了某种理解程度。如果哪里卡住了，说明还没有完全理解，需要加强这里的学习和思考。把问题弄明白。 常见问题包括我在内很多同学都有这样的一些问题：数学教材/参考书看不太明白怎么办？习题不会做怎么办？要看的内容太多了看不完怎么办？这两个问题困扰着诸多学子。困扰着那些浮躁不安而又急功近利的心。事实上，这也并非是一个不可解决的问题。仔细想来，为什么会看不懂呢？要么你忽略了什么细节，要么你对某个概念和定理还理解得不够深刻，要么你看书根本没有静下心来。你遇到了苦难，你遇到了挑战，遇到了难点。所以你想逃跑，想逃避。你不愿意思考，总是想着求助于外界或者继续拖延时间，这便是症结所在。大部分时候，人们为了逃避真正的思考可以做任何事情。作家蔡志忠对如何开发自己的学习能力、尝试各种开发都身体力行。他喜欢讲一个故事，一只青蛙想跳上床，自以为会跳就可以。但是高度不够，又没有方法的时候，他跳一整夜也是白跳。后来看他整理的笔记，说得更清楚了:“人生不是爬斜坡，只要持之以恒，努力便可到达顶峰。”因此，他主张人生像走阶梯，每一阶有每一阶的难点。无法克服难点，再怎么努力都只有在原地跳，毫无进展。学数学也是如此，如果不能突破自己所看不懂的地方，如果不能突破自己不会做的习题，如果不能抓住重点的学习。如果不能克服这些难点，那大概学数学学得再久都是没有什么长进的。对数学而言，时间是微不足道的，唯有观察、反思、思考、计算、想象才是更为重要的。学数学，不要害怕看不懂，你应该感到高兴的是，小小的突破点终于来了，你可以去尝试突破自己了。任何问题，思考和尝试才是解决之道。很多人都因为害怕看不懂而不愿意找一些数学书来看，但实际上大可不必这样，应该有的心理准备是，读得懂、看得明白、想得清楚的书一定是从没看明白而过来的。从另一个角度上看，看第一遍就看得懂的书。真的有很大去读的必要吗？“……人于书有一见便晓者，天下之弃材也。读书从勤苦中得些许滋味，自然不肯放下，往往见人家弟子，一见便晓，多无成就。”——清.李光地“小疑则小悟，大疑则大悟，不疑则不悟。”事实上，也只有自己不懂之后，某一刻/某一天突然懂了，才是最开心的事。所以，千万不要因为没有明白就放弃了思考，千万不要因为自己不懂而远离一本书。“读经有一耐字要诀，一句不通，不看下句，今日不通，明日再读;今年不精，明年再读;此所谓耐也。困时切莫间断，熬过此关，便可少进。再进再困，再熬再奋，自有亨通精进之日。不特写字，凡事都有极端困难之时，打得通的，便是好汉。”——曾国藩“读书如譬若掘井，掘数十井而不及一泉，不如掘一井而见泉。读书总以背熟经书，常讲史鉴为要，每日有常，自有进境，万不可厌旧喜新，此书未完，勿换彼书耳。”——曾国藩 纯粹数学“午后，你在林荫小道散步时，或者夜深人静思绪迸发时，不经意地，你想到那个定理/问题，并为它的精巧构思惊叹不已，这就是数学。” “我的工作本身就是对我的奖励，除此之外都是微不足道的。” –佩雷尔曼 “”印象十分深刻的是，考研初试成绩出来不久，忙着准备调剂。实在是感觉心力交瘁，发生的过于意外和过快。我还反应不过来。几天之后调剂也没有什么消息，于是就拿起了数学。看了一下午，那一下午和之前忙着联系调剂的感受完全是天壤之别，我现在也还记得那天下午看得是《常微分方程》的非线性常微分方程，渐进稳定、稳定、奇点的分类等概念。那种纯粹学习、思考的感觉与之前调剂一点也不一样。也许是我开始调剂以来过得最舒心的一下午。压力很大，想要解压，那就拿起数学开始干。这次我居然发现数学对我而言还是一种解压的手段。我是第一次意识到我似乎已经离不开数学了。(不能排除是肖申克的救赎中的无法离开的悲剧) 分水岭大抵学数学并有志于从事数学理论研究的人，都得经历一个痛苦的蜕变，尤其是对于基础数学专业的学生。他们面临的是从学习数学知识到创造数学知识，从做别人的习题到解决一些学术界尚未解决的问题。由于数学学科的特殊性，他们在开始走上研究道路的时候会经历很多的挫折和苦难。如同一位即将分娩的母亲，经历过绝望与挣扎过后，才会有光明和希望的出现。数学家阿蒂亚也有类似的表述。如果在这个分水岭放弃了，可能就不在想从事数学研究方面的工作了。这其中的Key是，本科阶段学生们是在“学习”数学，而不是在“思考”数学，是在向大脑中“输入数学“而不是从大脑中向外“输出数学”。 数学理论研究是中青年人的事业。“什么时候开始做学问都没有关系，做学问也不用那么在意有没有才华。要攀登山顶从哪里出发都无所谓。唯一必要的就是持续不断。只有能够这样，总有攀上顶峰的一天。”——本居宣长《登山事始》“我基本对做研究不感兴趣，而且我也没有做过什么研究。我对于理解事物感兴趣，这对我来讲与做研究颇有不同。经常地，为了理解一些东西，你需要完全依靠自己把它搞定，因为没有别的人曾经做过这一件事。” 数学家特质数学家似乎总是常人中很奇怪的一类，以至于大家的刻板印象都是呆板木讷的。1、天赋+好奇 2、坚持探索+永不放弃 3、专注+洞察力 4、艺术+诗意 5、坚持真理+思考 参考文献《黎曼几何初步》伍鸿熙《惰者集》小平邦彦《给年轻数学人的信》《当科研成为一种职业》《给青年知识追求者的十封信》《越读者》郝明义]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[且偷浮生半日闲--如何科学的在休闲中获得幸福与满足]]></title>
      <url>%2F2019%2F04%2F07%2F%E4%B8%94%E5%81%B7%E6%B5%AE%E7%94%9F%E5%8D%8A%E6%97%A5%E9%97%B2-%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E7%9A%84%E5%9C%A8%E4%BC%91%E9%97%B2%E4%B8%AD%E8%8E%B7%E5%BE%97%E5%B9%B8%E7%A6%8F%E4%B8%8E%E6%BB%A1%E8%B6%B3%2F</url>
      <content type="text"><![CDATA[为了拥有休闲，我们不休闲。（亚里士多德）为什么每次休息和放假越休息越累？（未完待续）似乎闲暇是人类最企盼的目标之一，工作/学习是大家心中摆脱不去的恶事，若能放开一切、闲下双手，人们大概就能迈向快乐的大道了。但事实恰恰相反。休闲并不必工作更令人快乐。拥有自由时间也不见得能够提升生活品质，除非当事人能够知道如何有效运用空闲时间，但这份能力绝不是与生俱来的。的确表面上看人们的双手停了下来，大脑暂时也隔绝了工作。可人们的大脑并没有开始休息。大多数人若无目标可追寻，无朋友可互动，注意力和动机便会开始消散。一旦心念分散，人往往就会钻牛角尖，想一些无解的问题，徒增自己的焦虑。或者在不知不觉中寻找扫除内心焦虑的事物：看电视、阅读推理小说或者浪漫爱情小说、纵情声色、赌博、疯狂的打游戏。胡吃海喝、KTV每日游、打牌打麻将、通宵打游戏、刷剧、整天玩手机、在床上躺尸、游乐场嗨、夜店酒吧。人们的休闲活动目的和行为之间似乎透露了了一种不可名状的矛盾。社会学家发现了两个休息悖论，第一个悖论是：“半个世纪以来，人们可自由支配的休息时间总体上一直呈增加趋势，但人们主观上却觉得自己的休息时间正在减少，每个人的假期错觉：还没开始玩耍就要结束了？”。第二个悖论是：“休息的意义本来在于恢复疲劳、放松神经，重燃生活的激情，但现在人们休闲之后，却往往觉得疲惫和无聊。”人们慢慢发现，大部分的社会性休闲活动(KTV、泡吧、喝酒)只是制造一些情绪上的波动。将情绪引向亢奋、开心、快乐等。但情绪的起伏是会让人感到疲惫的，那种高涨的情绪消失后便会感到疲惫。于是人们慢慢观察自己和本来休闲是为了恢复身心的疲惫，但人们参与的这些休闲活动却反而加剧了身心的疲惫。于是人们慢慢开始研究到底什么活动才会真正的使人放松？ 日常休闲一般关于日常工作的休息法大概有两派。以老一辈为代表的传统休息观念认为应该劳逸结合，每工作一段时间就短暂休息一下，就像学生上课一样。传统观念认为休息的绝佳方式是出门散步几分钟或者出去与别人聊几分钟的天。部分年轻人则认为最好猛干一天，然后下班后拼命放松。具体的方式比如躺在床上玩会儿手机之内的。基本的日常工作中的休闲粗略可以分为以下几类。1、微量运动：出门散步几分钟、或者做几个伸展运动。2、补充能量：喝杯咖啡或者吃几块饼干。3、真人社交：跟同事聊聊天、和亲近的人打个电话。4、认知盈余：读读新闻，看看邮箱，刷刷社交动态、朋友圈消息。在大部分的调查报告中，第四项占了很大的比例。无论是中年人还是年轻人都是这样。在一些医生或者学者等需要思考的脑力工作者中更倾向于第一项。至于第三项，在女性工作者群体中占了较高的比例，但研究结果却恰恰相反，第四项上网类似的认知盈余不但不能休息，反而会让我们变得更累。这是因为脑力劳动者在工作的时候最需要就是意志力和注意力，所以休息的时候这两项也是为了从休息中恢复这两项有限的资源。现在很多心理学界普遍认为这是两个有限的资源，最好用在刀刃上。休息的目的就是让注意力和意志力回血。但认知盈余的网上阅读会消耗注意力，比如决定是否点击某个新闻，是否恢复某条消息等。所以真正有效的休闲是第一项和第三项。补充能量也没有起到作用。所以休息的科学方法第一步：先断网。值得注意的一点是：短暂而频繁的休息比长时间休息再长时间工作效果要好。无论是做什么事情，大脑的特点就是大概做一个小时左右就会感到厌烦，想要逃离。顺着大脑的特性暂时休息一会儿，会让你更好的工作。我想大家考试的时候深有体会：做了一个多小时过后感觉脑袋一团浆糊，开始转不过来了，这是大脑的本能反应，长时间考试是一种让大脑不得不疯狂运转的方式，但普适的规律不会随着外界的条件而发生很大的改变。这也说明了学校的上课下课制度是合理的和科学的，但是学生们似乎并不会利用下课时间使得自己恢复精力。休息的时候最好离开办公室适度新鲜感和适度的自由对于大脑的恢复是有益的，当你能去外面散散步，这对你的工作状态的恢复将有莫大的好处。 短期休闲1、适量运动对于脑力工作者而言，无论是讲了一天的课，还是写了一天的文案。终于有个周末了，终于有了一个可以休息的晚上，这时候很多人可能会选择补觉。但事实就是补觉这种活动对你的精力恢复大概是没有什么好处的。可能大家很好奇，为什么？对于脑力工作者，睡眠对于注意力和意志力的恢复并没有多大作用，而且由于大脑皮层一直处于兴奋状态，身体却处于低氧状态，即使睡12个小时仍然会很累。在这里给大家黄金休息的法则：去做你的工作的对立面的事情，既然你是脑力工作者，那你就去运动：跑步，打球，游泳，爬山。脑力工作者的身体处于一种低氧的疲惫状态，这时“有氧运动”比“葛优躺”更能放松身体。解释一下其中的原理：低强度的运动能很好地改善血液循环，增加身体含氧量，加快体内引起疲劳的乳酸代谢，肾上腺素也能让你的疲惫和不良情绪尽快释放掉，所以散步、慢跑、瑜伽、游泳等安全缓和的有氧运动都是很好的选择。这个法则的思想无论是心理学界还是传统文化中都有体现：对立/相反的事情的结合会有奇效。对应的传统文化中便是阴阳平衡。2、深度沟通(人际关系)《持续的幸福》这本书，里面谈到幸福2.0的5个元素：积极情绪、投入、意义、积极的人际关系、成就。其中给我触动最大的是积极的人际关系这一条。积极的人际关系：人类是群居动物，我们需要在群体合作；我们也渴望在群体内被爱被看见。不仅如此，当我们工作结束之后，人际关系是疗愈身心疲惫的最好解药。 主动式休闲通常休闲有助于工作后的放松，但这段时间往往只是被动地吸收资讯，没有运用任何技巧去开发新行动的契机，结果生活只是由一连串无聊而焦虑的感受所组成，个人全无控制力。要想让闲暇得到最妥善的运用，就得付出工作般的专注与才智。主动式休闲有咯与个人成长，但过程却不轻松。并且，在科学和艺术成为专业之前，绝大多数的科学研究、诗歌、绘画都是在闲暇时间进行的。 所谓主动式休闲，有下列几个特征。1、需要你主动的参与，而不是“躺着被动参与”。参与感很重要，需要人们主动参与的活动对人们而言更具有意义。比如：看书、写作、运动、做饭、艺术创作、冥想、科学研究、舞蹈、下棋、背诵诗词等。2、需要你付出工作般的专注和才智。人类总是奇怪，得不到的在骚动，得到的不珍惜。容易得到的幸福不持久，不容易得到幸福寥寥无几的人会尝试去拥有。这里或者可以引用马克思主义矛盾运动学说？矛盾是无处不在的 闲暇时光反而是一个创造价值的契机，并且鼓励我们去做主动休闲活动的事情。比如说聆听音乐的时候，不是单纯的”听个响“，而是仔细去听一场演奏会中每种乐器的区别，去品味指挥家的情绪等等，这也是乐趣之所在。只有花心思投入精力去做，才能体现其中的趣味。就像书法一样，不是为了把字写完，不是为了完成什么，而是为了体验每一笔每一画。为了体验下笔的那种感觉和书法的那种心境。完全沉浸的做自己的事情。主动式休闲是可以获得心流(也就是一个人全身心投入在某项活动中而忘记了时间和其他的东西)体验的，这在生活中是非常常见的现象。比如正在解牛的庖丁、全身心投入写作的作家、挥汗如雨的正在运动的人。 休闲的途径1、散步、冥想、瑜伽、中国传统健身运动(八段锦、五禽戏等) 世上值得看、值得做、值得学习的趣事何止千万，但我们若不肯花费心思，便无法尝到真正的趣味。从心流的角度上讲，大致有如下可推荐的休闲活动。第一名：体育运动。第三名：兴趣爱好。第四名：深度沟通。第五名：亲近大自然。学会欣赏，从生活中去感受美好。世界并非缺少美，而是缺少发现美的眼睛。学会欣赏，蓝天白云、花草树木、山河平原、清风细雨、鸟鸣蛙叫，每一物每一处都能让人产生美好愉悦之感。 第二名：深度阅读。 生命的律动我每周都至少休息一天，对于生活来说，休息是必不可少的。每天至少休息一小时，每月至少休息两天。在我看来，休闲是比工作和学习更为重要的东西。诚然，没有劳动的刺激、成就和满足感，我们的情况会很糟糕。但如果我们过度的依赖工作，将工作视为目的本身和生活本身，我们就变成了一台会工作的机器，而不是一个鲜活的生命。这也就是我所认为的律动：生命就像音乐一样，不仅有主唱的歌词，也需要各种乐器的声音：大鼓小鼓、琵琶、古筝、钢琴。我们的生活也不仅仅只是工作，还有休闲娱乐、人际关系等各种。虽然休闲可以使人恢复工作状态，但我却希望你能认识到休闲并不是为了使人恢复工作状态而产生的。休闲具有更高的意义：我们工作是为了更好的生活，若仅仅将休闲看做是工作的暂缓，则永远不能发现它的全部潜力。休闲是实用世界之外的文化基础，是人们克服其内在精神世界贫困的永恒的机会。极端的忙碌，无论是在中小学还是在大学，市场还是宗教，大人还是小孩，都是缺乏活力和升级的表现。大部分人的生活模式是这样子：因为对物质财富的重视，所以努力工作，但我们的努力常常是过度的，我们过度的努力以获得更高的学位，更多的论文，更豪华的汽车，更多的生活用品。的确说我们的努力让这个世界更加的繁华，但是也导致了更多的失眠、神经过敏、高血压、以及厌恶这种生活方式的负面情绪。这种狂热的生存模式下面，你越是加快步伐，越是停不下来，就像你一直踩在车轮上往前跑步一样。如果你慢下来了，你的意识就会告诉你你妨碍了你自己，你没有融入周围人的生活。我们日常生活可以分为三部分：睡眠、工作、休息。没有用在睡觉和工作以及其他生活必须活动以外的时间，余下的便是真实的休闲时间。这段真实休闲时间是如此重要，再怎么严肃的思考如何使用它都不为过。但令人悲伤的是，大部分的人们只是用它来打游戏或者看电视剧。 参考书籍：《发现心流》《A Science—Backed Guide to Talking Truly Restful》Jarrentt《应对焦虑》《生命的心流》《心流》《休闲的挑战》《幸福的方法》《积极心理学》(哈佛公开课)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[考研二三事--胜败兵家事不期]]></title>
      <url>%2F2019%2F03%2F05%2F%E8%80%83%E7%A0%94%E4%BA%8C%E4%B8%89%E4%BA%8B-%E8%83%9C%E8%B4%A5%E5%85%B5%E5%AE%B6%E4%BA%8B%E4%B8%8D%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[有明天吗？如果没有，就让今天去创造。（未完待续）一个人可以被毁灭，但是不能被打败。–海明威《老人与海》回忆整个考研之旅：初试之前信心满满，初试过后亦是如此。初试成绩公布后猥琐发育。国家线公布后失魂落魄。选择调剂学校纠结万分。复试时激动不已。终于尘埃落定。去了云南师范基础数学（微分几何方向，郭震老师）从准备考研以来，在这个过程中我个人觉得我已经尽力了。初试之前是真的有信心，而且是特别有信心。结果，初试成绩考得一塌糊涂。似乎与高考有着某种意义上的相同。查到成绩之后无处抒发自己的感情，写了一首沁园春，以兹勉励。沁园春.忘怀昨日豪情，今有落魄，明天风光。晓知初成绩，大惊失色。飞鸟如笼，不得高飞。会向绝处，零星回忆，欲叫绝处可逢生。修整时，忘林林总总，历经几番。数学如此趣奥，使天才纷纷欲知晓。遂已明心志，专注当下。云遮雾罩，摸索向前。山林风火，风云变幻谁与共？即刻起，人生新气象，万千是晴。 而考研给我带来的最大的启发，莫过于知道自己还是太嫩了，还是年轻人的稚气。情绪管理能力没有得到提升。年轻人始终还差一些东西，没有沉淀。问题提出者与问题解决者之间思维的互换，也许能够给我带来更大的启发。 情绪管理曾仕强教授的情绪管理课程值得看看。 问题解决者唯有自己，能够解决和回答自己提出的问题。唯有我，是我的神，是能够重新创造并改变自己的人。 运气担忧担忧，担忧是在错误的地方，寻求答案和保护。因为一切都是不确定的，而人们厌烦不确定。但不确定性才是生命的代名词，不确定性才能带来生机。人们应该向大自然学习，随时都可变化。而聪明人会保持不确定性。不确定才好玩，某种意义上讲。人们过于严肃的对待生活，生命不过是一场由生入死的游戏。人们总是担忧与害怕，因为人们总是总是希望这一切都按照自己设想来发展比较好。周易早就告诫人们，万事万物的现象和表象总是在变化。好的会变成坏的，坏的会变成好的。可能的会变为不可能的，不可能会变为可能。一切只是眼光和出发点的不同。比喻来讲，一件事情发生了，就像0-360度的一个角度，大部分人都只选择了其中的一个角度，聪明人也许能够选择三四个角度去看。但唯有智者，尝试着没有任何倾向的审视自己所有的观点和角度。不因为不确定而担忧，这就像在因为新生命而担忧一样，没有必要的。我们自有自己眼光和思维的限制，接受一切，让一切发生吧。“我们对死亡的恐惧有点莫名其妙，我们站在“有”的世界，去担忧“无”的事情，这的确没必要。”–阿尔伯特.爱因斯坦]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[考研二三事--馒头姐与嗑药妹]]></title>
      <url>%2F2019%2F03%2F05%2F%E8%80%83%E7%A0%94%E4%BA%8C%E4%B8%89%E4%BA%8B-%E9%A6%92%E5%A4%B4%E5%A7%90%E4%B8%8E%E5%97%91%E8%8D%AF%E5%A6%B9%2F</url>
      <content type="text"><![CDATA[人与人之间的缘分总是显得有那么几分不可思议。馒头姐：“我跟你说，今天食堂的馒头很甜”。馒头姐停顿了一下，看着嗑药妹。馒头姐：“真的特别甜”。于是乎，馒头姐诞生了。至于嗑药妹，由于身体不太好，经常吃药，再加上偶尔喜欢摇头晃脑。故我管她叫她嗑药妹。嗑药妹是第一个让我觉得笑也可以这么美的一位姑娘。第一次见到嗑药妹，是由于二教暑假之前开始装修，我不得不再找一个地方呆着复习，准备考研。加之我室友在四教复习，于是后面我也去了四教。当时我坐在4605的最后一排的，嗑药妹坐我旁边（左边）的一个座位上，那时候嗑药妹还不怎么喜欢嗑药。嗑药妹是比较勤奋而刻苦的学生，不像我这种混子（每天混吃等死的学生）。所以嗑药妹很晚才到离开教室。第一次对嗑药妹产生印象，也是在暑假。记得那一天晚上，我刚刚走出教室，正准备关门，顺着视野右前方望去。恰好看见嗑药妹在小声地读英语。她也正好抬头望了我一眼，两人相互对视。她先冲我笑了笑，不过由于我比较木讷。嗯，什么反应也没有。但她的笑容有一种说不出来的魅力。我瞬间想起了“烽火戏诸侯，只为博美人一笑”的周幽王与褒姒。我只想说一个字：美。是真的美。大概是我们这种“理屈词穷”的理工男无法形容吧。有一次馒头姐的一张笔记的纸掉地上了，落在我的右方，我顺手捡了起来，给了她。她回头笑了笑，说了声谢谢。我至今也记得她的笑，实在是太美了。后面有一次梦到嗑药妹，内容是和她papapa了，可能潜意识有某些不良企图。后来由于四教装修的问题，嗑药妹去其他地方上了一段时间的自习。直到大四开学。再次回到4605的时候，嗑药妹换了个位置，原因是她以前的位置有人坐了。但同样的事情也发生在我身上。我的位置也被占了，所以我也决定换一个位置。巧合的是，我这次选的位置刚好在嗑药妹的后面。嗯，也许这就是缘分吧。嗑药妹总是喜欢把头发盘起来，我每次看见她盘起的头发都想把她的橡皮筋给扯下来让她变成一个疯婆子。一次嗑药妹去吃饭，回来的路上遇到了我。我先看到她了，但毕竟都不认识，所以我假装没看见。我继续往前走，嗑药妹好像注意到我了，看了我好几眼直到她走到拐角的地方才回头。当时内心活动是这样的：“嗑药妹你咋了？盯着我干嘛？我好像今天洗了头的吧。。。”还有一次我在去吃饭的路上遇到了馒头姐和嗑药妹和另外一位她们的同学，但每次感觉看到馒头姐都感觉很不自然，本能的开始假装在思考问题，等到馒头姐从我身边走过后，我舒了一口气，然后一看前面是嗑药妹，但她和我短暂对视一眼之后快速把目光转移到地面，我心里正纳闷呢：“嗑药妹你干啥？你眼睛出bug了？难道你刚刚一直在看我？”一次嗑药妹买了一袋陈皮糖，然后她打算给周围的同座的人都给了一颗。她先去找了馒头姐，估计也是去给馒头姐给糖的。后面她坐下来了。我当时坐在她后面的位置上玩手机，对我而言。她突然回头给我给了一颗糖。我一懵？疑惑而害羞的略有笑意的看着她，她也略微害羞的笑了笑。回过头去了。我内心正纳闷“嗑药妹难道你有什么喜事发生？”。再然后，发现她给坐她左边的两个同学一人给了一颗。才明白她是在干啥。我可是从来不吃糖的，但为了表示一下友好，她给我了之后我就吃了。刚刚把糖放进嘴里，我就想把糖的包装纸放在她帽子里面，不过因为之前不认识，为了防止自己被打死，还在忍了忍算了。有很多次我与嗑药妹在兴业苑一楼相遇，我假装没看见她，然后她又看了我几眼。嗯，我还得假装什么事都没有发生。大四上我第一次去红高粱吃饭，然后，在那里再次看到嗑药妹。有时候真的感觉很神奇，我和她应该平时都很少来红高粱。嗑药妹很勤奋，但这种勤奋似乎透露着一种理科生不屑一顾的不爱思考的味道。但嗑药妹还是偶尔会思考的，这一点从她平时的状态也能看书，但也不是热衷思考的那种人(我们班有一个和她很像的女生但没考上，那个女生可以说是我们学院最勤奋的人了，没有之一)。嗑药妹应该是属于勤奋的学霸的那种学生。当时还为她写了一首词。 踏莎行.真假勤迷失题海，溺沉勤奋，终日忙碌似刻苦。问君思考曾几时，战术勤掩战略惰。初始启发，直观理解，要点还需条理化。回忆复述察不明，模拟真实见技巧。 嗑药妹从大四开学后就一直戴着口罩，不知是脸上长痘痘的原因还是其他。不过嗑药妹话很少，很文静的那种。相比之下，馒头姐话超级多。但馒头姐可不怎么戴口罩。所以每次我看见馒头姐说话都想把嗑药妹的口罩取下来给她戴上，然后叫她闭嘴。（话怎么这么多，为啥要用声音撩动我的心弦，影响我学习）一直想知道嗑药妹叫什么名字，有一次梦中都在问她叫什么名字，因为我感觉所有人叫她学姐？后面某次无意间看见她的一张药费单，上面写着薛倩。我才明白，原来不是学姐，我就感觉嗑药妹看着就不学姐，为啥所有人都叫她学姐。 馒头姐与嗑药妹是一对好基友（闺蜜），馒头姐个子稍微高一点，身材也稍微丰盈一些。但馒头姐给我的感觉里面。绝不是一位贤妻良母型的女人，也不是会在某方面有所建树的事业女强人的类型。也许作为一个普通人安居乐业对于她的认知水平而言是正确的追求。（并没有什么独到的识人艺术，只是凭感觉罢了）至于嗑药妹，嗯，她还是比较勤奋的，虽然没有特别聪明（特别聪明的身边人的例子是阿昕，他可是真的聪明。当之无愧的本学院最聪明的人，没有之一），但也算得上是一个有点小聪明的女生。有点像林妹妹，弱柳扶风。整体而言，估计嗑药妹以后会有所发展的。馒头姐与嗑药妹经常一块去吃饭。我也总是在去吃饭的路上或者在食堂遇到她们俩。馒头姐对我而言，是一个奇特的女人。正是因为馒头姐，让我重新看见了我自己。馒头姐也是第一个让我觉得，从她身上能够看见我自己的女人。馒头姐似乎九月份才开始复习考研。一般而言，这种人要么是学霸，要么准备考本校。但馒头姐身上毫无学霸气质。所以，得出结论，她考本校。初次注意到馒头姐，乃是因为这个女生天天换衣服。这对于像我这种懒惰而不爱干净的邋遢理工男来说是个不可思议的存在。总之，我感觉我和她之间竟然产生了一种非常微妙而奇特的感情。是的，从第一眼开始。似乎是一种注定。第一次与馒头姐有眼神接触也是在看见她的第一眼，她在和嗑药妹说话。我看了她一眼她也条件反射看了我一眼。第二次与馒头姐有眼神接触，那一次我是用鄙视而不屑的眼神看着她。但当时我并不知道是那个在说话的人是馒头姐。记得那时一个在很热的中午。我出去接水，但我不喜欢喝六楼的水，我喜欢喝四楼的水。正要走到楼梯那里。突然听到一句话：“而且我那好朋友的男朋友还是个渣男”。我条件反射的顺着声音望去，瞪了那个女生一眼。我也没想到居然是馒头姐。用鄙视而不屑的眼神看着她。我还记得她但是瞪大眼睛而疑惑的看着我。至于我为什么会用鄙视而不屑的眼神看着她。嗯，最大的可能是我也是个渣男吧。思维角度上讲，由于我自己有一些心理学基础，所以并不会觉得遇到渣男怎样怎样，也许那更像是一个生命走向完整的过程中上天的恩赐吧。又或者说，有些女生会遇到渣男，是一种必然。当然，这只是个人的偏见罢了。第三次与馒头姐有眼神接触，因为一直感觉馒头姐很奇怪，我也不知道为什么会有这种奇怪的感觉。偶然一次，我在走廊的尽头休息。看见她和她的同学从厕所出来，于是遂想干脆好好打望一下看看馒头姐长得怎样。看到一半突然意识到这好像不太好，一直盯着人家很不礼貌。当时心里很慌，决定假装自己在发呆而不是在看馒头姐。不过隐隐约约听到馒头姐的一个同学对馒头姐说：他好像在看你。→_→从这次以后，明显感觉我和馒头姐之间似乎又发生了什么。馒头姐喜欢座的那个位置，正是我暑假经常坐的那个位置。某次馒头姐凑巧坐到我旁边，我出去上厕所之后回来。我的位置在馒头姐左边，馒头姐坐边上的。我站在馒头姐右边的过道上，正准备让馒头姐让我进去一下。但馒头姐突然往左边望了一眼，望了一眼我的位置。我当时真心想把馒头姐转个180度，然后看着她的眼睛告诉她我在这儿。更加巧合的是，我放书的地方必须要经过馒头姐的位置。而馒头姐放书的地方，也必须要经过我的位置。所以每一次拿书放书也许都会激起对方心底的一丝涟漪。由很多次出去从教室出来上厕所，恰好看见馒头姐从厕所出来，然后两人对视一眼。嗯，人与人之间的缘分总是很诡异，连上个厕所都能遇到。真是无语。一次去吃饭的路上，遇到了馒头姐和她的另外一个同学(不是嗑药妹)，我内心一惊，然后继续假装自己在思考问题，我用余光感觉到馒头姐从发现我之后一直在看着我，那天馒头姐里面穿了一件粉色的衬衣，馒头姐穿这件衬衣的时候显得特别地好看。一直到我走出了馒头姐的视线，馒头姐才扭过了头。这种事情似乎发生好几次，我都记不太清楚了。某一次这种事情发生后我为馒头姐写了一首词 蝶恋花.是她缘分浅浅浅几时，天壤之别，却叫眼迷住。情而不知何处起，留我沉思点点滴。似命非运总巧合，偶遇无心，紧张朦懵懂。惊鸿一瞥若有无，转瞬疾寻她背影。 馒头姐喜欢问嗑药妹问题，嗑药妹坐我前面。总会在不经意间欣赏一把馒头姐的身材(假装自己不好色)，课桌的高度刚好到馒头姐大腿处，但由于她在我前面问嗑药妹问题，而且喜欢动来动去，让我不得不注意到她那丰满的屁股(我什么时候变得这么猥琐了)，总是想捏一把试试手感(当然只是个人YY了)。还有一次，我吃完饭回寝室的时候遇到了馒头姐和嗑药妹，不过我只看到了馒头姐的侧脸。但那是我见过最美的侧脸，至今为止印象深刻。然后我闲得无处发泄这种感情再次写了一首词 鹊桥仙.似心动道路相同，身位相近，欲穷美感无数。透过佳人看自己，有道是相乃己成。似视非看，飘忽不定，只把心事藏在。时运未济人不至，空慕牛郎织女星。 后面某天突然想到我好像还不知道馒头姐胸有多大，于是当时在想有没有什么机会让我光明正大地能够看看馒头姐的胸有多大。但想想这很危险，可能会被打死，还是算了。但某一天突然有了机会。那天早上我拿着一本政治书正在脑子里面默默背政治，走到楼梯口地时候还在默背，我背书的时候喜欢望着一个地方发呆，转过角看着前面我还在继续背，然后感觉眼前突然出现了一个人，但我的注意力一直在背书上面，也没怎么注意，于是我发呆盯着她的脸，顺势把目光往下移，看到一件粉色的衬衫，接着往下，嗯哼，好像胸不怎么大，平均水平？不过又好像有一点点(好色本质暴露无遗)。这时候还没有反应过来，还在发呆。后面直到她走出了我的视线我才知道，原来是馒头姐。哦豁？所以我达成了之前的目的了？怎么这么神奇？我不是故意的啊。假装自己不是流氓，嗯，什么也没发生。某天我去放书回来，馒头姐刚好从厕所回来，我走到门口馒头姐刚好开门，我当时正在想什么问题，她突然开门，吓死我了。然后我很无语而略带一些鄙视和愤怒的眼神看着她，然后又看到了她一脸懵逼的表情。当天晚上回去梦到她了，梦中我和她吵了一架而且我很生气，嗑药妹一直在中间充当调解员。某天我去放书准备回寝室，走过馒头姐的课桌的时候，她正抬头看了我一眼，我继续往前走，我的余光中，馒头姐在拿卫生纸，但她的目光却在我身上，一直到我放下书，馒头姐起身去了厕所。四六级考试之前，四教封场，同样的事情再次发生，不过却多了一些情节：我收拾完书，准备去放，从起身开始，馒头姐就在看着我，一直到我走到她的面前的时候，她的同学和她说话，于是她转移了目光。再然后我回来的时候，座她旁边的那个男生和她有说有笑的聊天，当时醋意横生，当晚回去就梦到她了。梦中和她见面聊天很开心。然后第二天因这件事情无处诉说又写了一首词 雨霖铃.记四六级前一声封场，三分躁动。人音渐嘈，瞬间无心复习。收拾处，满心期待，何以承载这般？动身本无意，竟瞥见，一双美目，聚乎与我此身段。眉目情声透迷离，又发现，有郎与攀谈，醋意生欲灭天！卧而眠、魂牵梦萦。相谈甚欢，眨眼无处寻得伊人，清醒方知一场梦，逃避怨痴缠。 我也很纳闷为啥突然就遇到馒头姐了，也好奇我为什么会看上馒头姐，至今为止也不知道她叫什么名字。然后有这么一段离奇的缘分(用眼神调情？)。这是一个神奇的世界，不过我早已看见了我们的结局，所以我无法踏出一步对她有什么行动(当然这与性格也有关，只是性格的作用远没有自己所看见的结局的作用大)。越长大，越难去开始在感情上采取行动？至于馒头姐为什么让我看见了我自己，又让我自己看见了什么，详情请参见考研二三事–爱情对错血与泪 最想对嗑药妹说的话是：你的笑好美，美得令人心醉。 最想对馒头姐说的话是：你在雷池之内，我在雷池之外。谁若越这雷池半步，终将是错误。 此文仅仅只是一个邋遢理工直男癌患者的YY。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[考研二三事--情商原来有洞天]]></title>
      <url>%2F2019%2F01%2F30%2F%E8%80%83%E7%A0%94%E4%BA%8C%E4%B8%89%E4%BA%8B-%E6%83%85%E5%95%86%E5%8E%9F%E6%9D%A5%E6%9C%89%E6%B4%9E%E5%A4%A9%2F</url>
      <content type="text"><![CDATA[管中窥豹，可见一斑。（未完待续）不爱打扮，不善言辞，不喜欢人特别多的地方，不善社交，情商-250，喜欢独来独往–典型的理工男。 期望和赞美能够创造奇迹我能够给你最好的礼物，便是赐予你强大的自信。 环境(音乐和灯光)是制造情绪的绝佳工具视觉和故事最能激发人们的幻想真正的谦虚是忘记自己]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[考研二三事--爱情对错血与泪]]></title>
      <url>%2F2019%2F01%2F30%2F%E8%80%83%E7%A0%94%E4%BA%8C%E4%B8%89%E4%BA%8B-%E7%88%B1%E6%83%85%E5%AF%B9%E9%94%99%E8%A1%80%E4%B8%8E%E6%B3%AA%2F</url>
      <content type="text"><![CDATA[小孩子家家的，谈什么恋爱。(未完待续)上次感情经历结束后，总觉得自己过于浮躁，自己身上的诸多问题与不恰当的认知未曾得到修正。于是下定决心五年之后(2021年或者2022年左右)在考虑感情的事。但这与是否受到伤害无关(也许我才是伤害别人的人)，于我而言，每一件重大的事情都需要其意义才能让我去做这件事情。如果你未曾在一件事情中获得任何经验教训，未曾仔细思考在已经发生的事情中，你有哪些不足与犯过哪些错误？难道真的得等到下一次这种类似的情况再度发生，你才能幡然醒悟？简单的重复不具有意义，至少我不会赋予它意义。真的应该停下来了，当故事结束。我们需要做的，不是顾影自怜忆往昔，不是写人间情思哀怨，不是假装它已经过去了。我们可以从故事之中汲取很多营养，当然不乏我们的教育所缺失而又是我们所必须的学会的东西。在考研二三事–馒头姐与嗑药妹写道，馒头姐是第一个能够让我看到自己的人。我开始思考：为什么我对她有着奇怪的感觉？到底是哪些地方让我有些着迷？为什么是她而不是其他人(比如嗑药妹)？为什么会在这个时候遇到她？我们有哪些方面的不同导致了这种奇怪的吸引力？她为什么会有这样和那些的行为？背后的思维和心理是什么？这一幕和以前某些事情的类似的原因是什么？是什么在维持着着现象背后的某种不变的本质？从这些事情中我能学会什么？能够发现以前未认识到的问题吗？这一次是否有足够的契机让我重新认识我自己呢？一连串的问题在脑子里面，或许明白了一些，或许一个也没有明白。不过这不重要，重要的是，答案本身代表着一种对自己的反省、观察。顺着这种深刻而真实的东西“往后看”，便能去“成为”一个男人。 原来我从未对过总结一下自己之前所犯的一些错误。 1、在未对一个女人有着足够了解的情况下，仅仅只是由于她脸长得好看，身材好，声音特别令人有保护欲，就觉得自己心动了。于男人而言，真正的爱情，不可能因为看了几眼，就特别有感觉，就是真爱了，就非她不娶了。也不会因为吃了几次饭，聊了几次天感觉很有缘合得来，就要追了。即使被拒绝也坚持不放弃。这样的男人，精神上很随便，他们还会标榜自己是个好男人，因为他们太挫。在心理学的角度上讲，这个男人喜欢上了他心中的那个女人，而不是真实的那个女人。他对自己幻想出来的那个女人的执著反应了他的自恋。莫名其妙就对一个女人深情款款，然后自我设限，在两情相悦之前，深情款款对两个人而言都是没有意义的。2、在喜欢的人面前总是觉得不自然，总是猜测她对自己的感觉和讨好与取悦式的接近她。胡思乱想这么多，给自己添一些麻烦和苦恼。猜来猜去。自己的人格不见了，自信不见了，自己也不见了。只剩下一团抓耳挠腮的欲望和一团瞻前顾后的恐惧。可以肯定的是，不用费那么多的心思去判断她对我的感觉，可笑的是，我在这么做的时候，这只不过是在逃避你自己内心的感觉。不用去猜，那不重要。重要的是，只有当自己能够做到尊重自己的感觉之后，我才能摆脱那种”表露自己感觉”的恐惧，而这恰恰会创造她对我的感觉。3、好与坏。既不要太玩世不恭，又不要太正儿八经。事实上，我们并不是在“学习”如何和女人相处，那不重要，重要的是，你得重新审视你的生活和心态。女人哪里都有，亦没有必要去迎合女人的审美。但你自己，真的发生了什么质变吗？ 4、爱别人的最好方式是不去爱她，爱自己的最好方式是变强。每爱别人一次，就在某种意义上伤害自己一次，然后顺便害了别人一次。“无爱而无不爱。将欲爱世间者恒无情，及其有情也，不足以爱世间。”这里的不爱她是指的不去刻意爱她，不去刻意对她怎样怎样。实际上，用你所认为的方式去刻意地爱对方会让你们的关系变得有一丝难以说出的奇怪。某种意义上讲，爱代表着在乎与关心，也代表着卑微与讨好。但卑微与讨好是会受人嫌弃的，并且是永远受人嫌弃。人们从来都不是因为有人对她好而感到高兴(当人如果她喜欢你则另当别论)，的确，女人很重要，一个好的女人是男人一生的财富。但你不需要做其他任何事情去“爱她”，除了一件事情：心里有她，然后偶尔“绽放”一下这种东西。5、傲气与追求的平衡。骨子里面总是有些傲气：坚信着谁能与我在一起都是她的三生有幸。这话听着总是很狂妄，是的。狂妄是需要本事的，而我，恰好有。没有必要去按照她的要求和需求而怎样怎样。没有必要去追求，那本身就是一个错误的词。事实上，刻意追来的感情，我想，那段感情从最开始就不是健康的，不是平衡的。而这继续发展下去往往会是一个悲剧。最开始两个人的相互吸引，就如同婴儿不需要刻意去做什么人们就会自然而然去哄他、抱她一样，那是最为自然的事情。在这种自然而流畅的状态之下，自己的个人特质和独特的契机相结合。一切都会自然而然的发生。只有一个男人才能给女人带来“触动”。6、朦朦胧胧。基本而言，关系越是朦胧越是对主动的一方有利。不用急着向对方表达你对她的感觉，尤其不用在语言上表达你对她的感觉。当你在不经意间用行动表露出对她的感觉的时候，这一刻有着更多的可能，能够触动她的内心。当然这不是为了朦朦胧胧而朦朦胧胧，这个过程更为深刻的意义是去观察你自己对她的感觉并去思考她吸引的原因和去洞见你们的未来。 To be a man这是一个男人要花一生的时间去回答的问题：How to be a man? 在一个男人在合适的契机下(经历过一两个女人，一些重大的事情等)，会开始思考这个问题，这个问题会伴随着他的一生。年轻小菇凉们总是期待浪漫的爱情，但她们周围的经常接触的异性都是“大男孩”。机缘巧合下他们相爱了，但最终会受不了“大男孩”们的幼稚而离去。用无声的行动“启发”这些“大男孩”们去像一个男人，等到这些“大男孩”们慢慢明白他们必须像个男人的时候，等到这些“大男孩”们On being a man，这些“大男孩”们也开始成为别人家的“男人”。男孩必须“被看见”：你得承认你审视那些依然表现得像个男孩的部分。男孩综合症：蛮横、狂妄自大、威逼、牢骚、爱做受害者、懦弱、无助、希望得到照顾、凡事以自己为中心、非常在意别人的评价和看法、假装博学、情绪化、容易被冒犯、沉溺于性、好逞能、认为自己是无所不能英雄、理想化女人。为了显示自己的博学多才和读到见解而纠正别人无伤大雅的错误，为了引起他人注意而故意显露自己的情绪，为了显示自己的优越感而不同意别人，变成一个什么都知道的人认为这样子自己的地位会更高。说和做的事情是为了赢得注意力和他人的赞同，而不是真实的希望对情况有所改善。男人不一样。一、男人有远见，停止了对未来的不切实际的美好幻想。他们将未来的事情最大限度的基于现实的考量，而非猜测或者将事情寄希望于运气。不再期待自己成为一个英雄，而是去成为一个战士，对实际的情况和自己的能力有着准确的判断。而不是英雄主义式的浪漫。二、男人不再沉溺和逃避，选择观察，“看见”并“行动”。他们清楚的认识到生而为人的“心灵漏洞”，知晓自己对于逃避和沉溺及抱怨非常的在行，对于沉溺于食物、性、幻想、他人的同情、他人的注意、解脱责任等相当的警觉。不会选择对奋斗上瘾、对理想化上瘾、对大脑编造的故事上瘾、对感情上瘾、对自我形象上瘾。对他们会“残忍”的对待自己，阻止自己沉溺于这些东西。他们清楚的知道面对问题、观察自己才是解决之道。正视自己而不去逃避问题，“无情而理性”地与自己相处。当一件事情产生了特别深刻的感情印记，我们会牢牢记得三、男人停止理想化女人，谨慎而小心的选择一段关系。一个男孩在生命中反复出现的一个问题就是他们理想化女人，将所有压抑自身的优点映射到女人身上。假装“看不见”她们身上的缺点(用优点蒙蔽了她们身上的缺点)，在这种不真实的自我幻境下卷入感情，用她来弥补自己身上的性格弱点。当然，女人从来都不是完美的。在逐渐的接触过程中，男孩们最终觉得她变了或者他受到了欺骗。这时候有的男孩选择转身离开，有的男孩选择“拯救”那个不完美的女人，但这种“拯救”是真善美式善良和男孩式英雄主义结合下的产物，注定是失败。男孩刚开始因为一个人过得没有那么好，有某种缺陷感。然后在阴差阳错的情况下走进了一段关系(大多是因为贪恋美色)，把自己心中的那个完美女人投射到她的身上，开始粘上对方。渐渐的沉溺和失去独立性，久而久之开始失去自身的独特魅力和吸引力。四、男人对自己负责，真实而深刻的面对自己。男人为自己负责，为自己的想法和目前的境况负责。学会洞察自己之前的决定是如何导致了现在的局面的。与别人之前的竞争是健康而成熟的，而不是过分竞争而不成熟的。真实是男人的特质，男人与自己真实的感觉相连。因为他们打破了从小的教育:要表现的强硬而不表达自己的感情。只有允许自己去体验自己的情绪和感情，往深处探寻，慢慢学会过一个有丰富情绪的生活。 除了你的女朋友和关系特别好的女性好友，没有任何人能够让你在感情上学会些什么。 感情与婚姻似乎对于现在的我们而言，谈论婚姻是一件过于遥远的事情(尤其是对于我们这种单身狗)，但毕竟是二十多岁的人了。不能像个小孩子那样头脑发热、脑门一拍就决定了。可以肯定的是，彼此之间的喜欢与爱慕并不足以成为婚姻的基础。能够毁掉恋爱时的喜欢的东西太多了。家务活问题(谁做饭、谁洗衣服、谁洗碗)、孩子问题(自己带还是交给父母、谁在家里陪孩子)、经济问题(谁挣钱，怎么花钱，如何储蓄)。婚姻之中，三种东西的平衡:钱、陪伴、家庭责任几乎是主旋律，找到这三者之前那个微妙的平衡点，不是一件简单的事情。 参考书籍《国王、武士、祭司、诗人》《高级男人手册》《但愿婚前我知道》 《幸福的婚姻》约翰.戈德曼女语者系列文章]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[考研二三事--山林法典笑江湖]]></title>
      <url>%2F2019%2F01%2F30%2F%E8%80%83%E7%A0%94%E4%BA%8C%E4%B8%89%E4%BA%8B-%E5%B1%B1%E6%9E%97%E6%B3%95%E5%85%B8%E7%AC%91%E6%B1%9F%E6%B9%96%2F</url>
      <content type="text"><![CDATA[本法典最终解释权归管山林所有。于每年人大前后修订。（未完待续）拿破仑滑铁卢了，可他还有他的法典。我也可以！此法典名《管山林法典》。嗯，我考研也滑铁卢了。1、任何时候不得以任何利用放弃任何未曾解决和思考清楚的数学问题。（不要求解决该问题，但亦要明白问题无解是常态，不需要一定要去能够解决，但一定不能放弃数学问题）。2、任何一天，开始学习新的知识之前，若不能先凭借自己的印象和理解回忆并在纸上写下昨天学过的重要内容，把未曾透彻理解的知识重新思考、整理、巩固。则这一天不得学习任何新的知识3、若一天手机不用于看数学视频和回复别人、聊天等。则这一天学习结束回寝室之前手机的电量不得少于80%。若用手机看数学视频，则电量不设下限。若有回复别人聊天，则电量不得少于50%。4、任何时刻不得以弯腰驼背、目光呆滞的身体语态出现在任何人面前。切记走路和坐姿挺胸抬头。5、周六、周日不得以周一~周五相同的方式度过。必须以新的方式回忆、复述、总结、测试、思考、休息、锻炼、整理等。需知变化是世间的美，也孕育着新的生命。6、任何时刻把注意力放到自己所能做出行动的事情上而不是自己所渴望但暂时无法得到或无能为力的事情上。（幻想和不切实际的期待让人们失去了当下，也间接失去了未来，然后无尽的重复这种心智模式直到死亡的到来）7、不允许以伤害身体为代价而追逐名利，亦不允许以事业的发展而牺牲陪伴家人的时间和机会，须知家庭是根，身体为基，人们最终的幸福，都会回归家庭。8、]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[考研二三事--寄意德行奈人性]]></title>
      <url>%2F2019%2F01%2F30%2F%E8%80%83%E7%A0%94%E4%BA%8C%E4%B8%89%E4%BA%8B-%E5%AF%84%E6%84%8F%E5%BE%B7%E8%A1%8C%E5%A5%88%E4%BA%BA%E6%80%A7%2F</url>
      <content type="text"><![CDATA[我若求佛，佛去求谁；佛若渡我，谁来渡佛。（未完待续）喜欢人性的黑暗与丑陋，那种意味深长的真实，指引着未来进化的方向。 得不到的永远在骚动在你没有得到你想要的东西之前，不要轻易给对方所一直渴望的东西。案例1：(来自知乎) 天行健，君子以自强不息价值与筹码是整个世界的通行证。案例2：(令令事件) 宁叫我负天下人，不叫天下人负我爱自己的唯一方式世变强，弱者的爱与善良只是一种无能和在真善美教育下的洗脑后的产品罢了。案例3：(堕胎分手事件) 关心则乱，在乎则虐我以一无所有的心境，承载着这世间的一切。案例4：(眼神的游戏，无形的战场与调情) 每个人的眼中只有自己虽然世界不因为自己而转，但我最关心的还是我自己。 慈悲生祸害，方便出下流你没有资格请我帮忙，如果有，请给我回报。 人生来善于嫉妒，特别是美女总被人嫉妒《西西里的美丽传说》就是这么一个故事: 一个相貌及其美丽的女子因丈夫参军牺牲而四处流言蜚语，因自己的美丽而落得了悲惨下场。老祖宗也早就说过深藏不露，闷声发财。人怕出名猪怕壮。树大招风。大智若愚，大巧若拙。有时候想想，我妈生来给了我两项礼物: 并不好看的脸与并不擅长讲话的嘴。人们总是善于嫉妒自己周围比自己厉害、漂亮的人。所谓眼不见心不烦。自古红颜多薄命，不是没有道理的。 我的特殊性每个人都认为自己是不平凡的，这恰恰是每个人最为平凡的表现。人们遭遇到各种不幸的时候，第一反应往往是为什么这发生在了我身上，应该发生在别人身上的啊。可是为什么那个“别人”不是“我”呢？“我”真的与“别人”更为特殊和不平凡吗?从古至今，中华海外，统治者不仅在武装力量上领导着人民，也在思想上领导着人民(除非乱世)。焚书坑儒到罢黜百家，孔子之所以名垂千古，大抵是因为孔子的那一套东西既有着片面真理的一面，更为重要的是它有利于统治者，君君臣臣父父子子，修身治国齐家平天下。所以天下读书人都在统治者的控制之内。无倾向的审视你头脑中的每一个想法、感觉以及你的每一个行为：要知道你所获得的信息都是别人“刻意告知”你的，你的想法知识你所获得的信息的加工。要明白你的感觉只是人性规则和意识形态等相互作用的结果。要了解你的行为受着每一个无疑是时刻的状态所影响。若能明白自己只不过是更为“高级的电脑”，某种意义上的“生物机器”。无倾向的审视自己，用一无所有的心境，承载着世间的一切。 没有对比就没有伤害你若你开始对别人好，后面又对人不好，别人往往会恨你或者讨厌你。但如果你最开始对别人不好，后面又对别人好，大概率别人会对你评价还不错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[考研二三事--悟道学习存心法]]></title>
      <url>%2F2018%2F12%2F31%2F%E8%80%83%E7%A0%94%E4%BA%8C%E4%B8%89%E4%BA%8B-%E6%82%9F%E9%81%93%E5%AD%A6%E4%B9%A0%E5%AD%98%E5%BF%83%E6%B3%95%2F</url>
      <content type="text"><![CDATA[为什么那些平时看似很懒惰的同学却成绩优异？（未完待续）为什么那些上课经常记笔记或者各种在书上各种荧光笔标记的同学成绩却比不上那些根本不愿意记笔记的同学？同一个老师在同一个教室上着相同的课，同学们做着相同的作业为何成绩却大相径庭？人们做了看上去相同的事情，为何会结果不同？到底什么是有效学习？学习的核心是什么？有没有什么放任四海之内的准则？我们应该怎么学习以更好的掌控自己的人生呢？ 渴望挑战的刺激让暴风雨来得更猛烈些吧！–高尔基 《海燕》我渴望有价值的对手 –英雄联盟 剑姬的台词荧光笔、下划线和反复阅读是最容易做的重复性事情，也是最没有学习效果的事情在大部分时间里，我们都在用错误的方式学习着，那些在书上写满了各种笔记和荧光笔标记的同学，笔记越多，留下给我们思考的时间也就越少。并且你看着笔记会有一种熟练度错觉，以为自己已经掌握了这个知识点。但实际上我们对自己的盲目乐观与自信加上不恰当的学习策略，导致了我们最终的结局。听上去很残酷？嗯，是的，我想告诉你，学习越轻松，效果越不好，越等于没学。只有测试和检索，才能正确的评估自己的理解层次和知识素养。很多时候，学生们不知道自己的问题在哪儿，这才是最大的问题。天性懒惰孕育了认知规律和心智模式大脑逃避思考，喜欢幻想和YY，逃避挑战和困难。学习中不可避免的挑战重新巩固记忆：练习从记忆中检索新知识或者新技能是有效的学习工具，也是保持长久记忆的唯一武器。努力检索有助于人们获得更好的学习效果，产生更持久的记忆。值得一提的是，频繁的集中检索和练习只能产生短期记忆，而间隔检索、穿插练习、组合练习、多样化练习能够使知识储存得更加牢固。思考与理解：学习不可避免的会遇到各种问题，解不出来的题、看不明白的证明过程、思考很久也没有什么头绪问题。这时候首先要做得是把问题无解视为一种常态学习是挑战天性的必修课。学习的必要难度原则：你的大脑越是费尽力气地挖出某项记忆，你对其再次学得的程度也就越深，因为提取能力和存储能力都被增强了。相反的，你复习你刚刚学过的内容对你没有任何意义，那并不会增加任何记忆强度。所以，我们平时重复看书、抄笔记等工作并没有带给大脑任何挑战，没有引起大脑的思考和提取，长此以往我们慢慢的扼杀了自己的学习和思考能力。变成了一个看上去在学习的“机器”。 Poincare的马车：顿悟沃拉斯《思考的艺术》和阿达玛《数学领域的发明心理学》中引用的那些思考者的描述相当有趣。特别是Poincare的例子法国数学家亨利.庞加莱(Henri Poincare)对自己的一段描述，很详尽地记载了他在琢磨富克斯函数的特性的种种经历。“一个人若要专研某个难题，第一次往往会一无所得，”庞加莱写下了他对自己的观察，“这人会或长或短的休息一下，再坐下来专研那道难题，跟上次一样，半个小时过去了仍然毫无头绪，可是突然之间，一个成形的想法就蓦然出现在脑海中。”“……我可以说一句在如此的环境下发现了这个定理的证明，这个定理有个很生疏的名字，恐怕我们大多数人都不熟悉它，但这一点无关紧要，对于心理学家来说，重要的不是定理本身，而是发现这个定理的种种情形。”“……这样，我们就说到富克斯函数了。起先，我对这种函数冥思苦想了整整两个星期，企图证明它不存在，但这个想法被后来的事实证明是错误的，我想要把这类函数表示成两个级数的商，思想是非常自然且有明确目标的，这时我想起了类似于此的椭圆函数的情形。我就自己设想，如果这两个级数存在，它们会有什么样的性质呢？寻此向前，我并没有遇到任何困难，我构造出了这两个级数，并称之为富克斯。”“就在此时，我离开了我所居住的地方卡昂，在矿业学院的资助下，开始了地质考察的旅行生活。途中的许多事情使我忘记了我的数学工作。到达康斯坦茨湖，我们要乘一辆马车到其他地方去，就在我把脚放到马车踏板的那一瞬间，一个思想突然闪现在我脑海中，而在此之前，我还从来没有想到的，这个思想就是，我可以定义富克斯函数的变换与非欧几何的变换是等价的。当时我没有马上去考虑证明这个思想，因为当时我没有时间去考虑这件事，我继续和马车里的旅伴海阔天空的谈论着其他事情，然而我能感觉到这个思想是完全确实的。在旅行结束之后我回到了我的居住地卡昂之后，为了能够问心无愧，我还是抽空给出了这个思想的证明。”“此后我就把注意力转移到于此有关的一些算术运算的问题上，但并没有取得任何成功，并且看起来也不像与我以前的工作有什么联系，由于对自己的失败感到厌烦，我去海边度过了几天，并且考虑了一些其他的事情，有一天早上，我正在悬岩上散步，一种新思想和上次一样突然闪现而来，而且同样是简洁而确实的一种猜想，这个思想就是不定三元二次型的算术变换和菲欧变换是等价的。”首先最令人惊奇的是，这种”顿悟”的出现。同样的话德国物理学家亥姆霍兹也说过，他被难题卡住而四处碰壁的时候，一个新的念头如何冒出来的。”令人豁然开朗的念头往往意外来临，看似不费吹灰之力，就跟灵感一样忽然出现”，他写道，“我以前的体会而言，在我的脑子里面已经累了的时候，或是坐在办公室前正儿八经工作的时候，灵感是不会跑出来的……可是要是在阳光灿烂的日子里沿着斜坡走向山林，却是他们最喜欢跑出来的时候。”这些描述在沃拉斯的眼里却并非如此：他能看出它们都有一种基础结果。这些思考者首先是被一个问题卡住，然后放下来到处走走。这时，他已经穷尽了脑子里面所有的思路却看不出任何门道。关键性的顿悟可能往往会在他放手之后、在他并非专心思考的时候，忽然意外地出现。第一个步骤叫做准备期。这一阶段可能以小时计、天计，甚至更久。是一个人用来琢磨某个逻辑难题或者创新课题的时间。比如庞加莱，他花了15天的时间想要证明富克斯函数不存在。“每天，我会让自己坐在办公桌前，花上一两个小时，反复尝试各种不同的公式组合，却总是一无所获。”他写道。装阶段不仅包括弄懂你要琢磨的难题，弄清楚你手上有什么线索、别人怎么提示你的，还包括做去各种各样的尝试，直到用尽你头脑中所有的线索。换句话讲，你不是止步不前，而是黔驴技穷了。于是，准备期到此结束。第二个步骤叫做孵化期。这要从你把问题搁到一边去的时候开始算起。以亥姆霍兹为例，他就是在放下忙了一上午的工作，出去顺着山林往上走，不再想刚才的问题时出现的顿悟。沃拉斯还发现，有些人这一阶段出现在睡觉的时候、吃饭的时候，甚至是和朋友聚会的时候。沃拉斯认为：大脑在离线状态下还在围绕那个课题继续工作，不时加上一两个老早就装在大脑里面但一时没能想到但可调用出来的想法。第三个步骤叫做顿悟期。这就是你啊哈的那一刻。第四个步骤叫做验证期。这一步骤是要复核并确认得到的结果是否真的行得通。说说我自己的几个例子。第一次产生顿悟时刻，记得是我们班一个女生(杨秀)为了参加数学竞赛而问了我一些数学分析的比较困难的题目。当时我有两个题根本没有思路做出来。持续了一周左右的时间我每天都会做那两个题，每天做一个小时左右。无果遂放弃。直到后面11月的一天，我当时正在学校15栋前面的马路上走着，忽然想到了用泰勒展开和三次方公式去化简那两个题目。然后我赶紧到了图书馆，做了一下午加一晚上终于干掉了那两个题目。我现在都还记得那一瞬间的感觉和情形。第二次产生顿悟时刻，是在学实变函数的时候遇到的一个问题，在大三上的时候，一个关于鲁津定理、Riemann可积与Lesbuegue可积的问题。当时困扰了我很久很久，一直持续到下学期开学，记得那一天做数学分析做累了，然后又没有带其他的书籍，感觉无聊的时候突然就有了一个想法：那是一个垃圾定理，偷梁换柱改拓扑而得到一个诡异的结论。然后我便去图书馆看了看那个定理的证明过程，看了好几本不同的教材，发现都是差不多的。和我之前的想法一模一样。并且在夏道行的教材上看见了和我疑惑有点类似的一个注解。才明白那个地方的缘由，不过虽然明白了那个地方的，但新的问题又冒出来了，新的问题至今为止也没有得以解决。从那以后边对鲁津定理没有任何好感了。考研的时候的顿悟时刻，记得在计算一个行列式思考了一两个小时无果之后出去上课，由于二教距离四教还有一段距离，我在路上漫不经心的走着，突然就明白了怎么做：加边法。然后到了教室我用这个思路做出来了那个题目。但考研时大多数的思考都是失败的，我到现在还有印象的思考过的题目并且最终也是靠看答案而明白的题目至少有十个左右。考研时一般没有什么思路出去吃个饭或者上个厕所回来也许有新的思路，也许这个思路最终也是不行的。个人觉得因为考研解决不了的问题会影响即将到来的考试，不敢轻易像平时的问题那样放在那里一段时间，所以实在想不出来就索性看答案。但好像效果并不是特别好。也是在考研的时候，我对学习方法和学习习惯开始有了自己的体会和看法。最近一两次顿悟的时候，一次时当时我们班班长(海宝)问了我一个问题，当时我想明白了，但是后面我又忘了，导致给他讲的时候没有说清楚细节，但思路是清楚的，细节需要加工一下。当天晚上我回去洗澡的时候，突然又明白了那个细节的地方，这次可不会再忘记了。我从云南师范复试回来，当时因为我抽到的题目比较简单，然后我很快就做完了。但后面老师又给了我一个问题：E+AB可逆，求证E+BA也逆。当时我的第一想法是初等行变换然后两边同时取行列式。但我个人觉得太麻烦了，复试的时候我也就说了一下思路，并没有去做。复试完了之后，我在思考有没有什么简单的方法，好像没有什么想法。于是就放下了。一直到回学校了之后，有一天晚上我的手机要没电了，正准备回寝室，刚刚伸出脚的时候，我突然就想到了AB与BA具有完全相同的非零特征值，(初等变换已经被我放弃了，我准备是在做不动的时候再用这个放弃，但这个结论用打洞(龙生龙，凤生凤，华罗庚的弟子会打洞)原理的一个推论是显然的)于是我马上验证这个想法的正确性，给出了如下证明：证明: 用反证法，因为AB与BA具有相同的非零特征值，如果E+ BA的行列式等于0，说明E-BA的行列式等于0，这说明-1必然是BA的特征值，而-1 是BA的非零特征值，这说明-1也是AB的特征值，即-E-AB的行列式等于0，从而E+AB的行列式也等于0，这与 E+AB可逆相矛盾，证毕然后又想着反正也是做，把之前那位哥们的面试题目也做一做。我用了类似的方法做了出来那个题目：证明不存在正交矩阵AB，使得A^2=B^2+AB。我很快就写完了这个证明：证明:用反证法，假设存在正交阵A和B，使得A^2＝B^2＋AB，于是有A^2＝(E+AB^-1)B^2，两边同时取行列式，因为A和B为正交阵，故B^-1也为正交阵，而两个正交阵的乘积也为正交阵，从而AB^-1也为正交阵，从而AB^-1的特征值只能是1或-1,进而AB^-1＋E的特征值只能是2或者0,进而AB^-1＋E的行列式只能是0或者2^m次方,其中1&lt;=m＝n，在上述等式中同时取行列式，有1＝｜AB^-1+E｜，带入上述行列式的值得到矛盾，证毕。应当说，从复试结束以来，我自认为我想明白了好一些以前所不太理解的内容，包括Galois理论、微分流形、代数拓扑里面的基础性内容。也许是比考研之前更能静下心来好好理解与思考有关。所以，先把难题放到一边不必为此感到恼怒或者垂头丧气，实在做不下去的时候，休息一下。很多时候这种关键性的休息时刻能够有助于最终解决问题。另外，值得一提的是，把问题无解视为一种常态，是至关重要的。不去因为问题无解而各种发散自我评价和各种归因，对问题的解决有着一定的帮助。 Vinci的啄木鸟：好奇“一定要清楚啄木鸟的舌头结构是怎样的。为什么它一直在啄树啄地很响，却没有引起任何不良反应(比如脑震荡等)。” –达芬奇“一定要知道鱼为什么在水里游的速度看起来为什么比鸟儿非得还要快。”–达芬奇保持好奇心，仔细观察。所谓知知者不如好知者，好知者不如乐知者。达芬奇就是达芬奇，为什么鱼儿看起来的速度比鸟儿还快？为什么啄木鸟没有脑震荡？多么有意思的问题。正是好奇，驱动着我们前进，不断逼近世界的真相。推动着科学的发展。达芬奇还有一句很有意思的话:“谈话、走路、骑马一定要风度翩翩。” 费曼技巧原理：对自己也好。对他人也好，把你学过的东西表述出来，这种简单的做法并非是传统意义上的一种“自考”方式，它更是一种“学习”的方式，一种更高效学习方式。这比你继续坐在那里盯着书本的效果肯定更好，而且这样的练习还能消除“熟练度错觉”，让你能真正看清哪些地方你还不知道，哪些地方你还有疑惑，哪些地方你已经忘记，立杆见影。这也在一定程度上说明了为什么老师基本对各种概念理解的清清楚楚，而学生学的时候总是迷迷糊糊。 渗滤：拥抱你的拖延症创造性飞跃是如何诞生的。小说家约瑟夫.海勒如何描述他那些奇思妙想的由来：“我必须独自一人。公共汽车不错，遛遛狗也行，刷牙则更好了，尤其是思路以及无处可走的时候。常常就是我在累极了、打算休息的时候，我的脑子缺格外清楚起来……这时常常会钻出来一句名团需要琢磨的句子，或者是下一步构思的念头。在我最好的思路都不是在我落笔的时候冒出来的。”诗人豪斯曼也有类似的描述。他们给我们展现了这么一幅构图：创造性的飞跃通常出现创作者沉浸于某个故事或者主题一段时间后，暂时放下之时。而且常常以零碎的方式出现，既没有一定先后顺序，也没有什么重要程度的讲究。可能是宏大的、结构严谨的想法，也有可能只是一个小小的改动 所以我们用渗滤这个词来描述不同于之前的顿悟的短期啊哈。该词的本意为：像煮咖啡那样，先将咖啡粉浸泡，再透过滤纸的点点滴滴。取其为浸泡过滤渗透之意。那些电视剧的编剧们，总是在剧情最为精彩的时候结束一集。让观众们看完这一集就期待下一集。这样的中断会在观众心理留下一个悬念。但这只是阴的一面，阳的一面呢？假如我们正在完成一项耗时耗心血的工作？那这项工作会不会一直在我们脑子中打转。人一旦被某件事情吸引，便自然会生出一种动力来想逃一口气做完那件事，而这种动力会随着事情临近尾声而变得越发强烈。“想要完成某件事情的欲望，在刚开始的时候还算不上是欲望，但是到了后来，当你投入到忘我境界之中时，那就变成了货真价实的欲望。”渗滤的第一要素是打断一旦某个目标被激活，它便能盖过其他一切，调动起我们的觉知、思维、甚至是心态，去关注身边的一切。这便是渗滤的第二要素。渗滤的第三要素是有意识的反思 机会总是留给那些去找被感知力调动起来的大脑 一次访谈中，主持人问擅长微小说的小说家韦尔蒂，她在小说中的那些对话都是怎样得来的。韦尔蒂回答说：“一旦你投入一篇故事的创作中，便会觉得所见所闻的一切都可以写下笔。比如说，你在市区搭乘公交车时听到的对话，就完全可以用到你今天写的那段故事里。随便走到哪儿，都能遇到可写入小说的情节。也许这样该算是对准了频道了吧，或者说是你的耳洞变成了磁石，你需要的事情就都被你吸引了过来。”她在这里还有一件事情没有说到：那些从公交车上听来的对话如今让她笔下的某个角色活了下来，帮她把故事铺展了开去。那些被“吸引”到我们耳朵里面的对话不但可以归入到我们脑子里面的旁人对话分裂手册里面去，更能眼神我们对一篇故事的思考。 所谓渗滤，其关键就在于一直保持这心神的警觉，不断的想办法调动我们的头脑来，关注手中那一份未完成的项目相关联的一切，随时采集各种对外界的感知，并感悟内心的反思所谓数学家，其实是说的这么一种人，他走到哪里脑子里面都惦记着一个概念，直到有一天他回过头来，发现自己已经对那个概念已经很熟了。 交替：谢谢你的厌烦每次我学习或者看书，同一本书看不了多久就感到厌烦了。但正是这种需要变化，需要交替和新鲜感的本能，这种厌烦的感觉恰恰有着非常积极的影响。学习时把不同的物件、技巧、概念等穿插在一起来练习，经过一段时间的积累之后，我们不但能够更加清楚地到了解它们之间的联系，而且对它们自身也有了更好的掌握。交替学习最为关键的地方在于，你把新的科目和已经学过但有一段时间没有接触过的东西混在一起。而这比长时间反复联系一个技巧要好得多。 怀疑一切的力量对于科学而言，没有什么比质疑(怀疑)更为重要。但质疑需要强大的自信！未经思考的相信本质与迷信无异，质疑和思考才是科学的本质。也许这是一个时代，在应试教育和听话主义下必然的结果。但唯有自信，才是解药。每一个作者眼中的事实，都有可能是扭曲的。我的文章，恐怕亦有许多偏见。有位数学家曾说：那些你的前辈赠予你的知识，如果你想要获取他们，你还得重新探索一遍。基于去探索作者的描述，去体会背后所表达的事实，而不是去相信，相信是没有意义的，相反，如果去质疑，则拥有着更多的可能，收获更为深刻的理解和更为敏锐的洞察力。不要去盲目的相信和接受，无论任何知识，既然它是前人的脑力劳动成果。既然前人能够做出来，我们就应当有信心去超越前人。在整个高中和本科时代，学生都有这种倾向: 遇到问题和困难总是寄希望与别人来告诉自己如何往下进行，始终陷入一种被动的、踌躇不决的思路框架之中，害怕标新立异的心理状态，没有什么明确的见地。其结果就是，学生们忘记了最容易请教的人：自己。学生们总是只顾着到处看别人，到处找那些更好、更聪明的观点，我不认为自己能想出来什么、写出来什么。对自己往往没有任何信心。伊利诺伊州的一名博士生在给学生们授课的时候也注意到了这个情况，她的学生所学的文章也给人这种畏畏缩缩、毕恭毕敬的感觉。龙达.代夫利当时在这个州的大学攻读英语博士学位，同时还负责本科生的写作课教学，课程主题是如何以权威性的资料为依据，在学术期刊上发表具有说服力的文章。可每次到了期末，她却倍感失望，在那一学期里，她要求学生写六篇文章，每篇文章都得以社会、政治、文化中的争议性主题为论点，篇幅3-5页。她希望看到旁征博引而论据犀利的文章，可是按照她的描述，收回来的文章无非是前任发表过的学术文章的剪贴编辑而已。最让她难过的是，期末的作品和刚开课时候的作品，没有任何进步。她决定改善这种做法，第二学期一开始，她放弃了这种小儿多动症般的忙碌教学法。她只要求学生在期末的时候交一篇涵盖单一主题的文章。但在学期的进程中，作为如何做调研的训练，他们需要另外完成5篇“练习作业”，目标均锁定在做调研/做科研的体验上面。比如，一篇练习描述如何采访一名专家，另一篇练习如何确定核心词汇，并在辩论和讨论中加以应用。第三篇则是针对自己所选主题面临的有争议的各个思想流派，他们应该如何加以应答。不仅如此，她还要求学生阿奇整个学习调研的过程中做笔记，记录下他们面对调研中的各种人物或者资料时，自己心中有什么感受，比如是否认为谋篇文章的论述合情合理？是否认同稳重中的主要观点？某位名人大流的文章里面有没有什么错误？学生们的反馈如下: 随着时光的推移，我做的调研越来越多，很多信息都已经印在了我的脑海里，如今，我已经开始质疑某些作者宣称的所谓事实，我发现现在不见得会认同发表在专业学术杂志上的所有内容。还有一位同学说：我对自己经手的资料有着更为清晰而彻底的了解，已经能够针对期刊上面的文章提出一些自己的问题了。还有一位同学嘲笑的说：发表在这篇颇有名望的杂志上的文章，简直就是给这个领域的初学者的。我只会把这篇文章推荐给对这一领域毫无了解的人去看。也就是说：她的学生不再只会借用别人的观点了，他们已经知道努力探求自己的观点了。也就是说：她让学生们把自己调研中的感受都写下来，写下他们对所用的调研材料、杂志文章、人物访谈等的个人看法。学生们的能力便随着他们慢慢积攒起来的知识得到了提高。这边是怀疑的力量，也是渗滤中反思那一步最为重要的东西。立志超越历史上所有数学家，为理解之终极而思考。 真实环境的重要性特别强调的是，针对于考试这种事情，最好定时模拟考试几次，只有真实的环境，才能考出你最为真实存在的问题，而不是在自己的思维中打转。模拟真实，而不是在自己大脑想象出来的真实场景中。有个案例：在警察学院的大学生们每次练习缴枪是两个大学生相互练习，缴掉对方的枪之后马上还给对方接着练习。但这也导致了这些警察第一次在出去办案缴枪的时候直接把缴过来的枪还给了歹徒。这就是真实环境的重要性，不过好在歹徒也没有反应过来这是什么操作，然后让警察再一次夺回了枪。 整体性学习所谓整体性学习，是指看待知识的角度是多方面的。任何一门知识都不会单方面存在，它总是与方方面面的知识存在联系，这个观点并不新鲜，很多学习方法都这么说。不过，整体性学习在这方面走的更远，它让你在学习导数和积分时，想到的不是公式，而是汽车的速度表和里程表，在学习公司管理时，想到的是达尔文的生物进化论。想要走得更远，你就需要从学科中跳出来，站在外面看学科。有人曾经问爱因斯坦：“相对论到底是什么？”爱因斯坦回答道：“你坐在 美女身边一小时干酒就像一分钟，而夏天你在火炉旁坐一分钟，感觉就像一个小时，这就是相对论！”在认知心理学领域，历史进程中一个事实是：比如作为帮助人们理解的工具，由来已久。是什么让一个人更聪明？天资聪颖，还是后天知识的积累？或者仅仅只是大学教育起作用，还是也包含各种人生的经验、技能、直觉在内？整体性学习可以分为下面六个步骤：获取、理解、拓展、纠错、应用、测试。这里我主要谈谈理解阶段和拓展阶段以及测试阶段。单纯获取信息而不理解是意义不大的， 超越整体性学习精力管理学习的常见误区及其死循环人的思维格局，决定了人们做事的时候质的不同。特别是一些常见的思维误区。 思维误区1、害怕挑战，呆在自己的舒适区。2、以为自己时间很多，就从头开始而不是抓住重点。3、对未知的恐惧很对曾经不如意的愧疚一直在情绪和潜意识中飘来飘去。4、认为下次成功的机会一定比上次高。5、相信别人能够解决自己的问题而不是自己。6、认为学习某个新东西一定得专门找个时间。事实上，当下，把一个问题一个问题的弄清楚，你就已经踏上了学习这条路了。只有脑中有问题，脚所能到达的每一寸土地都是思考的天堂。纯粹的探索着自己未知的东西，这句话比学习更为本质。做一个当下的智者，而不是未来的信徒。7、大脑习惯性的强迫性重复某些幻想的场景，重复着“单调如同死水”的生命。而不去关注当下自己能够做的能够改变的东西。拒绝做一个当下的智者。8、未完待续。 伪勤奋者的自白每天假装学习，实际上什么困难都选择逃避，没有任何独立思考的能力。假装很刻苦，实际从来不思考。这就是中学时期常见的那种，学习非常刻苦但成绩也不怎么样的那种学生。1、学习的时候没有挑战：这种人太常见了，因为这种人是大部分人的“实干家”。劳苦功不高：这一类人的典型代表是起早贪黑的考研人，每天起早贪黑的做事情，“忙碌”到自己没有任何时间去思考、沉淀。每次遇到问题都几乎放弃，要么问别人要么直接放弃，加之社交圈和信息的闭塞，他们最终的结果也会受这些“看不见的大手”的影响。当然这种人还有一些特点：① 上课喜欢记笔记而不是思考、理解。② 书看了一遍又一遍实际上对书上的内容还是理解不到位。③ 喜欢问别人问题，而没有意识到“我”是最强大的智者。④ “热衷”看书/学习而不是做题、提问、思考、创造等需要动脑的活，或者做题只做自己会的，自己不会的题目也不去想办法弄懂。⑤ 面对问题没有自信。(喜欢看答案，但实际上看了答案过以段时间回来做题还是不会)。⑥ 不会反思和总结。与之相反的有一类人，看上去漫不经心，讨厌记笔记，性格偏内向。对所有偏理解和思考性质的东西有着执著的追求，这种人走路看上都心不在焉，而且行动非常缓慢，堪比乌龟。总是喜欢自己一个人散步和思考问题，不惧怕任何问题，视问题无解为常态而不放弃问题，学习的时候懂得适度穿插做题、回忆、思考、举例等，也许内心有种热爱在里面。但这种人一般社交和语言表达都不大好。2、没有模拟真实环境：如同备考，在重大考试之前，可以模拟几次真实环境，尤其是数学。不然你不会知道你要怎么安排时间，如何检查计算结果的正确性，如何安排证明的步骤，如何使用草稿纸等，如何在考场上调整心态等，在什么情况下使用答题技巧。这也是非常重要的东西，上面也提到过模拟真实环境的重要性。3、未完待续 学习的心法幸福的家庭都是相似的，不幸的家庭各有各的不同。–列夫.托尔斯泰《安娜.卡列尼娜》说完理论来分享一些比较好的学习习惯1、每天开始学习之前拿一张A4纸，凭借理解和记忆默写昨天学过的内容。（对数学而言，特别是重要定理及其证明，例子，应用等）整理自己还存有疑惑和没有理解的地方。完全清楚和理解后再开始新的一天的学习。解释一下其中的原理：大脑要从记忆中提取学过的定理、定义、公式、推论等任何都东西，所付出的努力远比直接重读一遍或者重学一遍要好得多，而这份额外的努力则加强了这些记忆的储存能力与提取能力。这样做之所以能够对知识的掌握更加牢固，这是因为我们简单的温习了一遍，是自己把它们从脑海中“提取”了出来。值得一提的是，错误而失败的记忆、理解提取比正确的提取更令人印象深刻。2、先测试后学习：例如，每堂课开始之前脑中装三个问题：可以是三个习题、三个预习的疑惑等，上完课及时思考并加以解决。下课时不呆在教室出去转转。解释一下其中的原理：利用无知的潜在价值，与直接进入学习相比，先猜测后学习使你的大脑能以更高的要去去运作，从而使知识更为深刻的印在了脑中。更直白地说，与直接学习相比，预考更容易把知识“赶进”脑子去。3、每周周末以异于周一到周五的学习检测方式（定时考试、准备面试问题、学习非专业知识等），以检测自己的学习效果和评估自己的理解层次。4、每个学科最多持续学习两个小时，交替不同的学科学习。5、每个学科在期末之前写一本笔记(不是抄一本笔记，而是回忆和复述加注解一本笔记)和习题解答(习题解答建议每周更新一次)。并默写教材参考书上的重点和要点。6、下午吃饭后和晚上回寝室前至少花半个小时散散步。7、读完定理之后自己尝试着去证明而不是直接去看书上的证明。 人生的终极指向人们被限制在自己的思维格局之中，按着某种几乎一成不变的认知模式延续着他们的生命。若没有合适的契机或者观察者的出现，他们只是每天重复着自己的生命，如同死水，没有任何涟漪。而观察者的一瞥，如同往死水中扔了一块石头，泛起了死水的涟漪。 于大部分而言，生活在大脑的情绪体验以及自我意识受着每一个无意识时刻的影响，能够意识到这一点并在生活中观察自己、反思自己。为生命泛起一丝涟漪。 不管我写了多少心法，写了多少理论。可以肯定的是，这些只能治标而不能治本。或者说，虽然有了那些传统的错误学习方法的适度纠正。但这种纠正会制造下一个“传统学习方法不当”的错误，无论思维和解决方式现在看来多么好，跌落是必然的。任何解决问题的方法，都会跌落成下一个产生问题的原因和背景。这个方法会变成一个问题，直到我们已经找到下一个解决方法，如此循环。 成败与运气，心态与生活。成功是需要运气的，而且运气的力量甚至有时会超过努力所能决定的东西。生活中，除了所谓的努力，我们还要学会去洞见一些东西，那些东西也许正规教育是不能带给我们的。但只有自己的感觉会告诉你，什么是对的，当然，不要忘了，去审视这种感觉。不要被这种感觉所欺骗了。 另外，知识量不等于创造力。学习得再好，懂得东西再多。都要记住，我们并没有比前任更富有洞察力去开创一个学科，学习在某种意义上是平凡的。而创造是非平凡的。 一无所有的奥妙以一无所有的心境，承载着这世间的一切。我想，古人早就有了一些劝言：是非审之于己，毁誉听之于人，得失安之于数。 参考书籍《清晰思考的艺术》《辛雷学习方法》《辛雷思维》《认知天性》《如何学习》 本尼迪克特.凯里《改变：问题形成和解决的原则》《成功与运气》《周易》《道德经》《数学领域的发明心理学》阿达玛《列奥纳多.达芬奇传》《棋与人生》《思考的艺术》格雷厄姆.沃拉斯]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[考研二三事--只言片语狂书生]]></title>
      <url>%2F2018%2F12%2F31%2F%E8%80%83%E7%A0%94%E4%BA%8C%E4%B8%89%E4%BA%8B-%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD%E7%8B%82%E4%B9%A6%E7%94%9F%2F</url>
      <content type="text"><![CDATA[考研一路，为了调整自己的心态和情绪，摘录了一些箴言，凝结着将近二十一年的愚昧和狂妄。遂作此篇。 最爱天行健，君子以自强不息。地势坤，君子以厚德载物。山泽损，君子以惩忿窒欲。（出自《周易》 二十一年来最喜欢的一句话，蕴含着许多的许多。） 是非审之于己，毁誉听之于人，得失安之于数。 言行拟之古人扶摇而上九万里，独步天下五百年！（仿毛泽东 会当水击三千里，自信人生两百年。） 纵使风口浪尖，岿然不动如山！即便身临绝境，亦要绝处逢生！（仿毛泽东 不管风吹浪打，胜似闲庭信步。） 唯有悟透真理解，神州大地齐震动。（仿毛泽东 为有牺牲多壮志，敢叫日月换新天。） 为理解之终极而思考，为懒人之崛起而读书。（仿周恩来 为中华之崛起而读书） 天空浩荡龙震天，山林风火我为王！（仿林则徐 海到尽头天作岸，山登绝顶我为峰。） 二十学问风与华，三千疑惑妙和趣。（仿岳飞 三十功名尘与土，八千里路云和月。） 理解与思考并肩，智慧共观察一道。（仿王勃 落霞与孤鹜齐飞，秋水共长天一色。） 寄意德行奈人性，我以我血捍我威！（仿鲁迅 寄意寒星荃不察，我以我血荐轩辕。） 每日思考八小时，发奋研究十余载。（仿 发奋识遍天下事，立志读尽人间书。） 轻狂书生自主张脑中幻景涉二人，不如泯灭静思考。 十年格局世间，他日风光无限。 非我莫属展宏图，舍我其谁必成伟。奋发图强善观察，年轻有为愿思考。 杀气腾腾当自强，野心勃勃傲群雄。傲骨嶙嶙行天下，威风凛凛我为尊。 内心宁静平常态，自然流畅呼吸间。 竟瞥见，一双美目，聚乎与我此身段。 似视非看，飘忽不定，只把心事藏住。 时运未济人不至，空慕牛郎织女星。 惊鸿一瞥若有无，转瞬疾寻她背影。 （情窦初开？ 好像门口的那只正在发情的泰迪……） 一题不做，何以做数学？一例不知，何以知学问？一字不疑，何以疑定理？一句不思，何以思推广？一惑不解，何以解猜想？一理不悟，何以悟证明？一法不创，何以创学科？（治学的态度，数学的热爱） 三观不正的屁话天下之人皆有资格批评我，但有资格夸奖我的人，我还没有遇到过！ 天下之人皆有资格讨厌我，但有资格喜欢我的人，我也没有遇到过！ 活在这个真实的世界之中，而不是你的海马体周围的强迫性重复的幻想之中。 想要成为人上人，先不说用规律和人性去操控别人，首先让自己不被人性和规律所操控。 好记性不如烂笔头，可惜后面还有一句话：假笔记不如真理解。 黑夜给了你黑暗的眼睛，而你却用它来寻找光明。嗯哼？而你TM眼瞎了只看见了光明，另外，你爸妈姓黑？ 二十一年来尚未遇到一个女生，可以说服我的理性，让我觉得她配得上我，从来没有。 剽悍的人生不需要解释，而傻逼（比如我）的人生也不需要解释。 高富帅：高在情智商，富在真才华，帅在言行间。 评价一件事情对自己的标准: 未来的十年、成就的视野、人性的超越。 天下人从来没有错过，而我从来没有对过。 天下人从来不觉得自己笨，可我从来不觉得自己聪明。 慢一点，再慢一点，慢到停下来的那个地方，便是所有人到达过但却未曾观察和思考的地方，那个地方才是我的起点。 数学的本质在于：怀疑一切的力量与对理解的渴望以及至高无上的理性。 坚定不移的走山林特色帝王道路（理性为帝，规矩为王），坚持思考自信、价值自信、战略自信、魅力自信。为实现山林风火王者风范、名垂数学的目标而努力。坚持批判和审视自己是山林特色帝王主义最为本质的特征。根本目的是寻找新理论与认知自己。必由之路是反人性。 当国家在开什么重要的会议和提出了什么倡议的时候，那也是我们该停下来重新思考、安排、规划一些东西的时候了。国家都有十三五规划，莫非有人觉得自己比那些历史风流人物更有深谋远见？ 暴露于问题之下，存在于错误之中。 答案终结者、问题制造商、错误导致者。 我的偶像：诸葛孔明、曾国藩、庞加莱、达.芬奇、毛泽东。准确说不是偶像，而是，我想超越的人。 鹤立鸡群并不是因为鹤太高，而是因为鸡太矮。 若我求佛，佛去求谁；佛若渡我，谁来渡佛。 男人的三大挑战：女人（欲望 感情）、面对无聊（不被感觉 想法左右）、学会观察（否定自己 洞察规律）。 养生是男人的第一事业，攻击性是男人的第一尊严。 三千疑惑，抵不住一个思字。万般困难，挡不得一个杀字。 狗咬吕洞宾，咬死狗欢喜。 习惯性去相信会耗尽一个人毕生的精力，特别是相信自己头脑中的想法和观念就等同于自己本身。 狂妄而谦逊、耐心而主动、无情而善良、温雅而强大、邪魅而深情、放浪而深刻、随意而专注、执着而潇洒、接纳而超越。 把注意力放到你所能做出行动的事情上而不是你所渴望但暂时无法得到或无能为力的事情上（比如 男生的英雄梦 女生的浪漫爱情梦 或对未来的焦虑等），幻想和不切实际的期待让人们失去了当下，也间接失去了未来，然后无尽的重复这种心智模式直到死亡的到来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[考研二三事--论文说理寓诗词]]></title>
      <url>%2F2018%2F12%2F30%2F%E8%80%83%E7%A0%94%E4%BA%8C%E4%B8%89%E4%BA%8B-%E8%AE%BA%E6%96%87%E8%AF%B4%E7%90%86%E5%AF%93%E8%AF%97%E8%AF%8D%2F</url>
      <content type="text"><![CDATA[考研与否似乎并没有对我的生活产生什么太大的变化，但其中的某些缘分让我更为深刻的认识了我自己。这篇文章整理一下以前写过的一些诗词歌赋，方便自己欣赏、阅读。 论与辞人生论日月乾坤，星罗棋布。五千华夏，亿万光辉。万古江河，见证几番。十朝九代，百家争鸣。改头换面，天地之间。万山红遍。层林尽染。圣贤言语，奸臣污吏。遵道修身，行者无疆。些许感言，做浅薄论。生而为人，修而为要。修我为上。当论人性，必提意识。自家主张，不离观察。观察二字，难言奇妙。缘者自见，知者思之。弃之详述，别来无恙。心境之首，一无所有，所承万物，用载世间。由生入死，梦幻游戏。若非觉者，反以误导。不得其要，大道无言，张口便错，无话可说。修静为中。有祸不惧，有福不骄。不争世名，不谋世利。宠辱不惊，庭院之下，花开花落。去留无意，天空之上，云卷云舒。有才不傲，有智不露。不记人过，得失若常。不听闲话，不较锱铢。情绪管理，忌大起落，莫大悲喜。斩恨断愁，宜行平和，顾惜今日。不可恐慌，惩欲止水，窒忿灭火。要义如此，便生专注。抱元守一，倾尽人事，以成大器。多思多醒，金刚神功，莫过于此。修身为下。身体毫发，聚乎智能，考其规律，首推中医。养生为冲，阴阳五行，自得玄意。道性为撑，情志平定。通者自通，莫大好处。谋取之法，谋人为上。知人善用，结交贵人。对下慷慨，上不邀功。敌对之人，则寻共同，利益之上，朋党之间。守我特色，自得其所。以德服人，以才示人。谋事为中。眼光宜长，格局宜明。欲问今事，五年十年，方以为尺，可以行度。成长休闲，买书专栏，不可节俭。养生保健，顺时而动，不可冒犯。道德之事，不可愚行。欲问胜人，知己知彼，想他所想，晓以方地，战略已显。待时运来，伺机而动，藏器于身，既定乾坤，不执结果。业精于勤，而荒于嬉，行成于思，而毁于随。合抱之木，生于毫末。九成之台，起于累土，千里之行，始于足下。下善非善，上恶不恶，霹雳手段，方可显示，菩萨心肠。慈悲之心，必生祸害，方便之行，多促下流。妇人之仁，恐被利用，不可不防。孔子不圣，释迦非佛，老子不道。若我求佛，佛去求谁？若佛渡我，谁来渡佛？若我信佛，佛去信谁？宗教信仰，阴谋之间。统治工具，投放注意。谋物为下。他山之石，可以攻玉。名利之流，不可贪图。将之一军，若有所思。替人保管，总白忙活，些许解脱。（受启发于诸葛孔明《诫子书》仿《千字文》） 忙里偷闲辞天地乾坤，日月星辰。风云变幻，春秋交替。自然流畅，平常呼吸。工作学习，忙碌闲暇。阴阳平衡，如此神仙。易道逍遥，生活自在。偷闲之乐，随性洒脱。闲云野鹤，今日且过。莫效这般，恣意晚睡，贪图温床。游戏看剧，聚餐泡吧。感官刺激，无所事事。打发时间，真乃自残。不如吃茶。休息之道，变化为要。变中有定，生物之钟，不宜变化。工作用脑，偷闲之时。体力释放，挥汗如雨，以劳身体。方闲大脑。教室学习，附近散心。环境周围，山河湖海。自然风光，便透新奇。几番秀丽。清风徐来，新鲜空气。闲人独步，仔细玩味。日照暖暖，阳光融融。沐浴其中，笑逐颜开。直躺操场，一曲音乐，偶尔星光，几分月光。天马行空，思绪飘荡。怡然自得。整理住处，打理内务。去尘除垢，遗弃无用。好似净土。行于心愿，功于点滴。重于养生，调于饮食。积蓄力量，整装待发。休息有常，学习有节。学问慢磨，乐安思考。（受启发于陶渊明《归去来兮辞》仿《千字文》） 自信论为人之本，当先自信。 诗和词蝶恋花.数学学问深深深几许，定理堆砌，美感无重数。前程只有理论铺，理解不叫懵懂误。证明思路三分看，开窍在己，只教思考住。疑似哪般何启发，原来执此具体故。（仿欧阳修《蝶恋花》 庭院深深深几许……） 踏莎行.真假勤迷失题海，溺沉勤奋，终日忙碌似刻苦。问君思考曾几时，战术勤掩战略惰。初始启发，直观理解，要点还需条理化。回忆复述察不明，模拟真实见技巧。（仿秦观《踏莎行》 雾失楼台……） 鹊桥仙.似心动道路相同，身位相近，欲穷美感无数。透过佳人看自己，有道是相乃己成。似视非看，飘忽不定，只把心事藏在。时运未济人不至，空慕牛郎织女星。（仿秦观《鹊桥仙》 纤云弄巧……） 蝶恋花.是她缘分浅浅浅几时，天壤之别，却叫眼迷住。情而不知何处起，留我沉思点点滴。似命非运总巧合，偶遇无心，紧张朦懵懂。惊鸿一瞥若有无，转瞬疾寻她背影。（仿欧阳修《蝶恋花》 庭院深深深几许……） 钗头凤.月老问问月老，若血染，蓝线可否成红线？终不可，已成紫。缘分既定，好自省错。定，定，定。再询之，为何故，蓝线并非那红线？笑而答，有对比。体会自见，待时而动，静，静，静。（仿陆游《钗头凤》 红酥手……） 雨霖铃.记四六级前一声封场，三分躁动。人音渐嘈，瞬间无心复习。收拾处，满心期待，何以承载这般？动身本无意，竟瞥见，一双美目，聚乎与我此身段。眉目情声透迷离，又发现，有郎与攀谈，醋意生欲灭天！卧而眠、魂牵梦萦。相谈甚欢，眨眼无处寻得伊人，清醒方知一场梦，逃避怨痴缠。（仿柳永《雨霖铃》 寒蝉凄切……） 西江月.断情思三年自来相遇，此时情思无益，挥剑斩怨断情思，十年格局世间。五番动情似狗，安住当下专注，愿寻问题善观察，他日风光无限。（仿辛弃疾《西江月》 明月别枝惊鹊……） 青玉案.笑傲天生我才可灭天。胜候王、赛龙虎。本自王者有风范，大器必成，舍我其谁。一触若千军。侠丹义胆真豪杰，威风凛凛我为尊。凭借心愿杀血路，年轻有为，所向披靡。叫那风貌换。（仿辛弃疾《青玉案》 东风夜放花千树……） 满江红.学问气定神闲，灯明处、奋发图强。俯仰间，偶然会意。拈花一笑。二十学问风与华，三千疑惑妙和趣。莫浮夸，功夫仔细磨，静思考。愈贪多，反难过。题海边，焉能见。长路漫，自有来相见。埋头下笔灵感显，专心致志要熟练。待那时，行云如流水，有神功。（仿岳飞《满江红》 怒发冲冠……） 浪淘沙.阴冷天暴雨风云涌，阴冷刺骨。自习室外读书声，欲与雷鸣较高低。慷慨雄浑。待到奋笔时，安静沉思。鱼跃龙门千层浪，浴火重生五百载。烈火烧天。（仿李煜《浪淘沙》 帘外雨潺潺） 江城子.难易说书生意起主沉浮，静气生，豪情怀。眼神坚定，踏平天下难！我难人难不畏难，多智谋，善思考。水至柔而能杀人，仔细做，小心验。脚步稳健，莫叫等闲看！我易人易不大易，需反省，规律先。（仿苏轼《江城子.密州出猎》 老夫聊发少年狂……） 钗头凤.劝己言白如玉，红胜火。满心治学思未易。果未凝，察几分。一纸青天，三分禀赋，静，静，静。秋新气，冬未立。时机守住气沉一。深呼吸，创思绪。一鸣惊人，锦绣前程，立，立，立。 忆秦娥.路漫漫秋风急，黑云寒风催人泪。催人泪，绿叶未落，尘起霜重。三分天下逞英雄，罢却意动定乾坤。定乾坤，路漫人叹，夕阳自红？（仿李白《忆秦娥》 萧声咽……） 青玉案.秋意晚风吹过青万年，敢叫叶、漫天飞。岿然不动有形影。萧瑟不寂，雁鸣非悲，鲤鱼跃龙门。待时而动器藏身，沉静思虑有洞天。秋乏倦起需鼓气，虎啸山林，筚路以启，功名震天下。（仿辛弃疾《青玉案》 东风夜放花千树……） 声声慢.说欲躁动不安，蠢蠢欲动，身体炙热传意。金秋九月时候，初见是她。霓裳羽衣新鲜，怎知道、悄然心动。似相识，好风韵，又将往事回忆。无端闯入梦中，贪欢愉，犹恋音悦容丽，睡前醒来，青睐挥之不去。情起便生欲望，总愿得、缠绵悱恻。若相拥，如泰迪欲火焚身。（仿李清照 《声声慢》 寻寻觅觅……） 破阵子.斩妄念温雅暗藏豪气，天赋异禀有为。并肩作战相扶持，龙争虎斗是般配。未来正缘现。疾如风徐如林，动如火安如山。破解疑难智行天，神州大地齐震动。因她共神仙。（仿辛弃疾 《破阵子》 醉里挑灯看剑……） 苏幕遮.莫放松阴沉天，起伏地。鳞次栉比，高低落曲线。繁花尽透炊烟袅。人间美满，喜庆神采奕。压力来，挑战担。隐隐焦躁，生杀调天下。斗志昂扬踏实干。抬头沉思，非得破万难。（仿范仲淹《苏幕遮》碧云天，黄叶地……） 御街行.情商点滴成就人形象。酒桌上，谈笑中。情商暴露眨眼间，人性如此造物。日日本来，灯光鲜艳，错误难自见。克制本能想他感。一念后，晓恰当。砌此反省终身便，观察直指智慧。周周总易，谦谦君子，也让攻击利。（仿范仲淹《御街行》 纷纷坠叶飘香砌……） 沁园春.不仁愚孝无智，道德无功，善良无益。问天几时断？恩怨情仇。人心险恶，丑陋不堪。圣人不仁，霹雳手段，得证菩萨好心肠。总怨道，那家里长短，心思难安。经得些许故事，笑善良总偏受欺凌。阅华夏五千，人人敬畏，强者手段，王者风范。欲说造化，不见善恶窥福祸。四海内，血泪熬汤鲜，铁石成仙。（仿郑板桥 《沁园春》 花亦无知，月亦无聊……） 沁园春.忘怀昨日豪情，今有落魄，明天风光。晓知初试分，大惊失色。飞鸟如笼，不得高飞。会向绝处，零星回忆，欲叫绝处可逢生。修整时，忘林林总总，历经几番。数学如此趣奥，使天才纷纷欲知晓。遂已明心志，专注当下。云遮雾罩，摸索向前。山林风火，风云变幻谁与共？即刻起，人生新气象，万千是晴。（仿毛泽东 《沁园春》 北国风光，千里冰封……） 西江月.漫谈人生自作自受，意识活跃思维。察道原来先贤传，一瞥一无所有。感觉基调常年，超然至此境界。智者洞见只身态，也罢游戏此间。（仿辛弃疾 《西江月》 明月别枝惊鹊……） 摸鱼儿.念陶是四年，收拾旧物，惊呼日记几处。爱恨情仇皆依旧？大方一笑嫣然。身影倩，共携手，其中情意她留言。白纸黑字：幸得汝之心，越明年，有缘自会见。共成全，青春隐约喜欢，年少总归简单。各自前程成锦绣，情意落尽尘埃。雨露润，坤护生，化作水晶向月光。皓月千里，回忆能几何？任它时光，幸我遇见卿。(仿元好问《摸鱼儿.雁丘词》问世间，情为何物…..) 点绛唇.风光艳阳当空，地利湖美又起风。天鹅梳羽，自然百态中。独坐青山，日月同比肩。看河川，延绵不绝，总归向远方。 考研.壮志凌云杀气腾腾当自强，野心勃勃傲群雄。力挽狂澜真骨气，翻天覆地壮气概。热血胜出红日光，眼神坚毅黯磐石。唯有强者尽人事，化作凤凰浴烈火。待到涅槃重生日，一飞冲天不死鸟。 考研期间大概也就只写了这些垃圾玩意儿。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[大三上&20岁的学习生活总结]]></title>
      <url>%2F2018%2F03%2F01%2F%E5%A4%A7%E4%B8%89%E4%B8%8A-20%E5%B2%81%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[今天就要奔三了，2017下半年&amp;大三上是我本科阶段中一个比较重要的转折点了。其中发生了很多很多看上去云淡风轻的事情，却在我的心里留下了不可磨灭的成长痕迹。我犯了很多错误，虽然过去不必执着，但反省和总结的很有必要的。 整体方向与评价大二结束的暑假，七夕后的第一天，我的前任提了分手。那段时间我还在学校做数模，最终我认识了一个我以前没有见过的懦弱的Grantsome。大二结束的暑假，我准备往基础数学方向走，放弃我已经奋斗了一年多的计算机，我认识了一个从头开始学习数学的Grantsome。大二结束的暑假，我认识了一个慢慢沉迷于自慰和色情的Grantsome。大三上的寒假，第一次认识到现实世界的勾心斗角和明争暗斗。我认识了一个毫无心机与防备心的Grantsome。 为伊消得人憔悴–情感谈了接近一年的恋爱之后，才知道那句话：男人最成功的事情是遇到了那个ta、一生中最重要的关系是亲密关系。这场恋爱来的措不及防却又在情理之中，高中时候喜欢了三年的人，再怎么也没有那么容易说放弃就放弃，但结局却早在我的意料之中。我从最开始就觉得我们不太合适，但得不到的永远在骚动，我也尝试和努力了很多，就像一个垂死之人在死亡的边缘挣扎一样，终究改变不了自己即将死亡的事实。终究还是证明了我最开始的感觉是对的，我们并不合适。但我还是不后悔，一方面，有一段感情经历并不是说就证明你多有魅力如何如何，而是重新认识一个未知的自己，而是对自己未来的另一半有了更加清晰的要求与认知。另外一方面，在一段感情经历里面能学会很多东西，只有经历过的人才知道到底能学会什么。既然你看到了这里，送你一点福利：我为我未来的另一半准备的一些还比较好的两性情感的音频与书籍(书籍推荐见2017上半年学习总结一篇)：链接：https://pan.baidu.com/s/1jJNsksu 密码：79ax分手的时候还是很难受，心理忍受着说不出的滋味，还要做数模，到了晚上的时候终于受不了了，找了一位先生聊了两个小时，先生和我说了很多，也给了我一些指点与教导，这时候才好了一些。剩下的就交给了时间。 取次花丛”还”回顾–性与手淫没接受过任何性教育的我，在性的方面受到过诸多困扰，至今为止，才对性有了一些肤浅的认识。至于手淫，虽然是难登大雅之堂的话题，但的确让我沉迷过上瘾过，的确值得我总结一下。最初，还是谈恋爱。个人属于有心理洁癖和感情洁癖的人，对于任何没有什么感情基础的人没什么真正的欲望。但同时对亲密的ta在性的方面却很open，自然会有性的欲望与需求。由于ta的性观念比较传统，所以就变成了相互自慰。有了几次过后，慢慢地发现自己上瘾了，然后慢慢的自己自慰。大概从2017年的5月开始，一直维持着比较高的频率。直到2018年1月，才开始刻意控制：1月份4次，2月份5次。看上去频率并不低，不过比之前好了很多，决心慢慢戒掉这种习惯。虽不知结果如何，但我真切感受到了社会的所谓媒体对年轻人性观念的误导(参见书籍《女孩与性》)以及真正的性教育的缺失以及年轻人在这方面的迷失。但性总归需要面对，我推荐陈见说和女王Cup的科普文章。到最后我的性观念也变成了在没有伴侣的情况下：以克制为美，类似于禁欲修行的那种。有了伴侣之后可以适度的放松，还是以适度为首要。关于如何啪啪啪的教育，个人比较推崇亚当 德永的一系列的书籍(主要针对男性)：《完美伴侣–缓慢性爱》、《Slow sex for girl》、《女人要被爱，男性想爱人–幸福婚姻指南书》当然他还有视频课程，我是看了视频课程之后才对女性身体有了更进一步的认识，还是有福利。链接：https://pan.baidu.com/s/1i6oOspZ 密码：7qkp。上述所提及的资料对于受AV影响的年轻人具有很重要的纠正错误的知识与认识的作用。 万品流形先度量–数学大二结束的暑假，看了一本叫做《负反馈》的书，是关于微分方程与动力系统的。不过没看完，只看到100多页就没看了。看完那本书之后感觉数学还有点意思。又在无意之间看到了《数学分析八讲》辛钦 著，这本书是一本非常经典的书。看完之后竟然越来越觉得数学真的还有点意思。开学了，最开始感觉多元统计有点意思，后来发现全在用高代的一些基本定理，翻来覆去的证明定理还可以。但这门课还是太偏向应用了，所以我并不是特比喜欢，总是用高代+拉格朗日函数，然后吧啦吧啦运算就完了。没什么意思。后来在鲜老师那里借了一本《贝叶斯思维》，看完觉得统计真的没什么意思。然后国庆过了之后，在图书馆翻书的看到了《基础拓扑学》Amstrong 著，这本书我看了第一章之后就觉得还可以，然后一直看到第四章：拓扑群的时候。我就被迫去看抽象代数了，但还没怎么看抽象代数就被迫去看数论了，因为抽象代数里面涉及到了数论里面最基本的一些东西。当时我是看的《数论基础入门》 孙智伟 著。100页不到，非常薄，还没看完的时候就开始数学竞赛了，被迫准备了一周，然后居然才拿一个三等奖，不考零分在数学专业应该都有奖。等我看完数论的那本书已经11月多了，然后继续回到抽象代数，当时我对选书没怎么在意，找了一本史上最垃圾的教材《基础代数》 北京工业大学姚老师编的，实在是看不下去，看了第一章感觉自己就是个傻子，什么也不知道，书里面很多东西都不讲清楚。很难受，然后当时也在数学学习上是否应该做题，做多少题有些疑惑。我几乎要放弃抽象代数了，原因是那本书真的看不懂，呜呼哀哉。然后《基础拓扑学》也没办法继续往下看，也几乎要放弃了。后来由于某位大佬在我面前提及过微分几何，我还有点兴趣，于是就去看微分几何去了，看的书《微分几何》 苏步青 胡生和 沈纯理 2016年出版 黄色封皮的那本，印刷和书的材质。但有人说他是抄的Do cramo的《曲面与曲线上的微分几何》，看看两书的目录的确很像。学微分几何的时候是想做做题的，不过做了几道题给我的感觉是计算量太大了，然后我就不想做了。导致我微分几何那本教材看完的时候就做了几道题等我看完微分几何已经开始复习期末考试了，开始就复习了一些数学物理方程。然后就认真看了一遍实变函数的本校的教材，把周民强的《实变函数论》的第六章看完了，把徐森林的《实变函数论》的第一章看完之后就已经没时间了，已经开始考试了。后来在考《多元统计分析》的时候，由于老师很好，给我们说了考试的一些东西，我就没怎么复习。考试的前一天晚上去图书馆看到了一本《双曲几何》(或非欧罗氏几何)，看了10来页，发现书的定价很便宜，于是就没借，想自己去买一本(结果花了我20大洋)。这样，我的大三上在学校的学习就划上了一个句号。回家之前，我找王老师(良辰兄弟)聊了一些学习上的问题。当时决定在寒假看一下后继的一些课程。还买了接近250元的书。回家了，当然买了这么多书肯定没看完，我就看了看《双曲几何》，这本书还有点意思：讲了罗氏几何里面三角形的面积不能任意大、三角形的内角小于180度、矩形不存在、庞家来模型、勾股定理正玄定理余玄定理的不再成立及其新形式，是真的有点意思。然后就看了看《线性代数的几何意义》，某些代数的几何解释还是不错的。本来准备把徐森林的《实变函数论》看完的，事实上也就看完了第二章，第三章都没有开始看。最后就看了一下本来应该是重点的抽象代数，我用的是《抽象代数基础》丘维声 著的为主要教材，以《近世代数》韩士安 为辅助教材。当然没看完→_→，我就看了丘维声的第一章群论，然后就没有了，就已经到了3月1号了。 且偷浮生半日闲–闲”嗜”终于开始培养自己的兴趣爱好了，当然个人觉得自己对以下东西还有点兴趣：两性情感、心理学、佛学、古典诗词、历史、中国象棋、跑步等。历史的边边角角《他们曾经这样狠》尹剑翔 、经典词品《人间词话》王国维 这两本稍微看了看。听说《为什么佛学是真的》、《第二性》还可以，不过我也没看过。总的来说也没怎么看，基本属于白痴级别。跑步的话，这学期做得还比较好，几乎天天十点以后都去太极操场跑了一会儿的。最喜欢的还是一边在操场散步一边思考数学问题。 谨以此文送给20岁的Grantsome作为生日礼物。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[男女践踏家--不能承受的社会之轻]]></title>
      <url>%2F2017%2F09%2F07%2F%E7%94%B7%E5%A5%B3%E8%B7%B5%E8%B8%8F%E5%AE%B6-%E4%B8%8D%E8%83%BD%E6%89%BF%E5%8F%97%E7%9A%84%E7%A4%BE%E4%BC%9A%E4%B9%8B%E8%BD%BB%2F</url>
      <content type="text"><![CDATA[那些深藏于人性深处并被社会所忽略的需求一直都在，只是你看不见罢了。社会这个无形的杀手恐吓并监视着所有的人，警告着人们不可以展现出了人性的某些部分。慢慢的，人们便以为ta自己没有那部分没有被展现出来的人性了，慢慢的，所有的人都“畸形”了。 从小黄片探索之旅到新世界的发现滴滴，下面要开始开车了。说来惭愧，据说很少有18岁以上的人没有看过小黄片的，截止到2017年开学前(刚过19岁)。我的确还没有看过所谓的“小黄片”，也许是时候未到吧。不过2017年上半年我可是收获了不少“小黄片”，大部分都让我感觉很恶心，一言不合就啪啪啪，有的从开始到结束都一直是那个姿势。终究是新手，不懂得老司机的世界。看小黄片也是要靠眼力的，还是要好好挑一下。有的小黄片看了之后想吐，所以各位看官，小黄片质量很重要，要看还得看质量比较好的小黄片(逃在阅片“无数”之后，我一直在问自己一个问题，我到底在寻找什么？性高潮？放纵？身寸米青？躁动不安的荷尔蒙在诉说着激情、欲望、冲动。但这不是重点，重点在于荷尔蒙消散之后对自己进行的终极拷问：我在寻找什么？又得到了什么？OK我猜你想说这是青春期的正常，没什么关系，食色性也。but这个说法在我这里不成立，甚至都不算一个说法。我想大部分男生(我非女生暂不知道女生是否有过这种经历)应该都有过这样的经历：晚上上床之后在性欲与理智之间不停的挣扎，最终性欲赢了。然后在睡前拷问着自己：我在干什么？又在寻找什么？面对性，终极拷问来了：我在寻找什么？可能也有人想说：哎，你们这些年轻人(大学生)，饱暖思淫欲，果然是没有受过苦的90后。然而你们怎么想我并不是很care(即使我承认饱暖思淫欲是一个人性的弱点)，我关心的是，我的那个问题：面对性，我在寻找什么？在最近几次的体验里面，我终于找到了一些表面且肤浅的答案(鄙人水平有限，想不出也找不到什么惊天地泣鬼神的答案)由于自己的原因，以前的性幻想对象现在已经不再是我的性幻想对象了(PS:如果你是一个在性方面不那么open的人，那么，请不要对我做出什么评价(我拒绝的你的语言暴力)，你没有并不代表其他人不可以有性幻想对象，要懂得尊重)。然后我就不怎么想紫薇了。我一直在思考其中的原因，我知道大脑是最重要的性器官，大脑不兴奋自然会有影响。但问题在于，为什么有性幻想对象的时候大脑兴奋了？因为大脑自身的特点，你在幻想性幻想对象的时候，大脑是分不清现实与幻想的(事实是大脑在任何时候都分不清现实与幻想)，所以自然就比较想紫薇。在幻想性幻想对象到想紫薇的中间似乎总感觉差了点什么。直到我看了一部质量很高的“小黄片”：片名《东京恋爱模样》(这部片子还行，拍的不错，是我目前看过质量最高的小黄片)看着看着忽然感觉这部片子拍的好有爱，竟然忘了我是来看某些激情画面的。前方多图预警：男主帮女主洗头洗完之后男主帮女主吹头接着两个人依偎着对方我感觉我要融化了。然而就在此时，手机突然没电了(哭笑不得不过也正是因为手机突然没电了，让我有时间静下来回忆刚刚所发生的这一切，仔细思考和体会我的感受。重述一次刚刚的经历：我本来是想看小黄片里面的激情画面的，但这部片子拍得太有爱了，具有很强的代入感，以至于我都快融化了。换句话讲，我本来是想寻求性刺激的，最后却被爱(男女之爱)给震撼了。也就是说，我想寻求性，却被爱给震撼了。再加上自己以前看过的一些书：《爱的五种语言》，里面提到了一种爱的表达方式，服务的行动(包括了性行为)，书里面说大部分男性认为服务的行动(主要指性行为)是伴侣爱他们的表现。似乎有着某些共同的东西，在加上我之前看过一些潜意识(还记得某本关于潜意识的书里面提到现在学生近视这么多，有部分原因是学生潜意识想反抗读书、做作业、考试，但他们知道自己没有能力去反抗，不过潜意识知道，所以潜意识“让”眼睛近视了，来表达自己不想读书、做作业)。在联系上进化论的适者生存原则，以及社会对男人的事业和成功的“要求”，慢慢的有一个答案出现在了脑海里面。原来我一直想问的问题终于有了答案：原来我一直认为的我对性的执着，没想到那只是潜意识以假乱真，我真正执着追求的是爱！我当时在纸上写下了我的分析过程和结论，现在原封不动的贴出来：或许男人持续所追求的性(好色等)只是表象，他们实际上是缺爱。由于人性的存在，每个人都需要感受到爱，也需要被爱。但这个社会对男人的要求是事业有成，直接忽略了男人也是需要爱与被爱的(特别是男女之爱)，在社会的规则下他们不得不往前走，很努力让自己的事业/学业更上一层楼(也许“事业机器”这个词更合适)，数千年来都是这样，久而久之，男人们也“以为”自己是不需要爱与被爱的(进化论)，在整个社会似乎都在抑制男性表达自己对爱与被爱、对感情的需要，要求男人“爱江山”，莫计较那些儿女情长，不能沉浸在缠缠绵绵之中，残忍的“阉割了”男人对爱与被爱的需要。但潜意识知道他们(男人)是需要爱与被爱的，所以潜意识在神不知鬼不觉的把这种对爱的不能表达的渴望转化为了对性的渴望，因为这是唯一一种不被社会所排斥而且还可以获取生理上的满足的方式了，当然，最重要的是有性必然会有爱与被爱的感觉(上文提到过的服务的行动)，这种潜藏着内心深处的需求被满足了。又由于用进废退的原则，慢慢的这种方式就演变成了男人对性的渴望比较强烈，接着就有了男人都很好色等几乎每个人都知道的社会“潜规则”了，在这种情况下，甚至连很多男人自己都觉得自己很好色，自己是需要事业有成的，不需要爱的。这也算是人类社会的一大悲剧吧当然，女人也是一样的，在某些方面亦有相似的分析过程和结论：和男人类似，在传统社会中女人所谓的以家庭为重，以感情为重只是一种表象，但她们实际上是缺乏成就感与事业。由于人性的存在，每个人都需要感受到成就感和事业带来的成功的感觉，但社会对女性的压迫更为严重，直接忽略了女人也需要事业和成就，在社会的规则下她们不得不把自己变成传统社会所定义的那种优秀的女人(“生育机器和家庭照顾机器”可能更合适)，数千年来都是这样，久而久之，女人们也“认为”自己不需要事业了，整个社会都在抑制女性追求自己的事业，在家相夫教子才是王道(还好上个世纪有女权运动，现在情况好了一些)，于是女人们把自己的丈夫和孩子看做自己的事业，特别是孩子，紧紧抓着孩子不放(把对事业的执着投射到孩子身上,造成了很多比如结婚之后还要处处管着孩子、不肯放心让孩子自己做事和做决定)，导致的结果往往是两败俱伤从女权运动的角度上说，已经有女人敢于去向男人一样追求自己的事业，这一点，比起男人现在都不敢说一句：“我需要你的陪伴，我需要你的爱”。男人也应该向女人学习一下这种精神，敢于打破社会各种不合理的规则。顺便提一句，我记得有一篇调查报告，是面对已婚家庭的男女的，主要是针对家庭里面是否有“女人分担一些经济负担，男人分担一些家务”这样的情况，调查他们的家庭满意度发现有这种情况的家庭满意度更高，最终他们的平均寿命也比传统的“男主外女主内”家庭要高一些。 发现了然后呢？说明我不知道这是否可以被称之为社会对男女的相互折磨，我想，应该没有什么东西可以向社会压力一样践踏着人性、压抑着我们的需求却让我们发不出声的东西了，它的暴力程度已经超过了身体暴力和语言暴力。而我们，也只是默默的承受着罢了，那么我们到底是与愚昧的？懦弱的？认知不够？还是这仅仅只是人类世界的一场自导自演的悲剧罢了？另外，我不得不承认这篇文章并不严谨，一切只是我的猜测罢了，我无法想数学一样严格的证明它一定是对的，一定存在，我只能尽我所能，尽量表达清楚吧！你在沉思什么？又明白了什么？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017上半年学习总结]]></title>
      <url>%2F2017%2F07%2F24%2F2017%E4%B8%8A%E5%8D%8A%E5%B9%B4%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[时光飞逝这种话我是不会在这里说的，虽然很多人(包括我)都有这种感觉。感叹归感叹，总结还是要写的，算是自己给管山林的一个交代吧。主要是想梳理和回忆一下自己的上半年，做了些什么，对了些什么，又错了些什么。首先说说读书方面吧。 读书不得不说，大二了之后，我也很少看其他的一些课外书，甚至今天写总结我都不想不起来自己上半年到底看了哪些书。当然，看了多少并不是最重要的，读书更需要质量。在这里，不是要推荐什么书单什么的，我记得在蔡崇达的《皮囊》最后的几页上面有句话，原话我记不太清楚了，大概是这个意思：读书只是让读者透过书籍去寻找自己，读者会看见他自己想看见的部分，更加清楚的认识自己。 魅力人格拼心智 – 生活的内在折射《迷因效应》、《暗时间》、《非暴力沟通》、《匠人精神》、《山水尘烟》(贴吧帖子集)、《好好说话》、《好好学习》、《指导生活的算法》、《真实的幸福》、《思考线》、《愚昧者的愚昧》 当然这些书我并没有全部都看完过，简单说一下自己的一些体会:《迷因效应》：这本书给我的震撼与《自私的基因》差不多，作者的观点解释了我们的很多行为。几乎可以说是完美无缺，正如自私的基因解释我们身体规律一样。我首推这本书。《暗时间》:关于思考、心智模式、思考误区等，作者是微软的员工，毕业于南京大学。是他的博客集。《非暴力沟通》：这是一本会改变你说话方式的书，让你明白什么是语言暴力，怎么去处理。让我感受良多，受益匪浅。 其他的书，就不一一阐释了，毕竟今天不是要推荐书。 一笑倾国又倾城 – 两性情感的终极之道《爱的五种语言》、《幸福的婚姻》、《亲密关系》、《永远幸福的科学》、《谁在我家》、《但愿婚前我知道》、《谈钱不伤感情》 两性亲密关系一直是我比较比较感兴趣的领域，可能由于自己处于这种关系之中。虽然我不是这方面的专家，但这方面就像吃饭喝水一样，大部分的人都要去面对，亲密关系就像教育一样，需要用科学的方式去对待，它也是有章可循的。《爱的五种语言》：里面讲述了不同的人表达爱的语言的不同，以及如何发现自己的爱语是属于那种爱语。针对不同的爱语如何让对方感觉到爱，等等。《幸福的婚姻》：听名字似乎是为已经结过婚的人准备的，不过里面的内容对所有处于亲密关系中的人都会有一定的帮助。《亲密关系》：有点学术味的书，它会教你如何化解两性关系里面的冲突与不满，客观冷静的看待你心里的那个“受害者”。 嗯，就这样。 打虎还需身板硬 – 专业知识的广阔天地 自从大二上开始学Java&amp;Android，这学期关于专业书籍也没有看过几本，专业性书籍读起来就像是西天取经一样(敢问路在何方？路在脚下！敢问路在何方？路在脚~下~~)，路途漫长无止境。 《Android编程权威指南》、《Android开发艺术探索》、《Android群英传》、《Android神兵利器》、《Python学习手册》、《Python网络数据采集》、《MATLAB在数学建模中的应用》、《数模建模算法与应用》 这些书并没有完全看懂，有些部分一知半解，有些部分完全不懂。专业性质的书需要多看几遍，慢慢理清楚知识的逻辑以及理解每一本书的思想并融会贯通。 遗憾的是看了一些书，也没有认真的写读书笔记，也没有完全按照我所知道的那些知识来实践，更多的只是一种了解吧。 其他 另外的一些关于心理学和教育方面的一些东西，就不写了，看的很少。不过这些东西对我的自我认知的确很有好处，我也开始反思我到底想要什么，我希望的生活是怎样的，什么会让我感受到幸福，又如何去对待学业、家庭、恋爱等等。看这些书最深的体会有两点。 每个人几乎都不能客观冷静的看待自己，高估自己和以打击他人以获取自信和自尊是灵长类动物的特点。 大脑每一个幻想未来和回忆过去的念头都会让你越来越虚幻和焦虑，活于每一个当下是最明智的选择。 每个人都以为自己是上帝，习惯性指责别人、强迫别人按照自己的方式做事。 做过的事情？ 这学期做的一些小项目，有逼乎(移动问答端)、百思不得姐(视频播放器)。然后就没有什么了。的确没有干什么，似乎啥也没干。 然后看完了Python的基本语法，了解了一下爬虫。 作为一个数学系的学生，了解了数模常用的模型以及算法。数模网络挑战赛三等奖和数模校赛一等奖。(PS:跟着学霸混就是有好处，O(∩_∩)O哈哈~，不过这些奖也没有什么价值) 开了自己的博客，写了几篇文章，不过有时候过于追求数量而忘了追求博客的质量。这一点需要注意。 社会关系那个她 这学期陪她的时间不是很多，有时候因为数模的事情经常都忘了，的确是我的错，希望以后谨记。我也体会到了我有点事情而她需要陪伴的时候她的那种不舒服。希望以后谨记。 父母 我错误的理解了心理学对童年伤害的影响，在头脑中放大了家里的一些不美好的一面。然后产生了一种对家里的一种抵触的心态，这也是我这学期犯得很大的一个错误。和父母的关系还好吧，虽然不会像以前那样什么都告诉她们了，但是也会把自己的打算告诉她们，因为她们有权利知道。 朋友 这学期真的没怎么注意联系那些朋友，由于很想强化自己的专业技能，导致了其他时间朝着那些东西倾斜，朋友真的没有怎么去联系。不过我也发现所谓以前的同学，有些的确是以前关系比较好，但是关系是一种互动，也有的人从未主动找你聊过ＱＱ、微信，更不用提打电话了。有些人的确还有很多共同语言和兴趣。 锻炼 这方面也是，这学期一点都没有做好。都没有跑过几次步，所以这些东西都是需要注意的。而且也是重要的事情。 总体概述 总的来说，2017年上半年，如果满分是100。那我打个80分吧。原因：1、这学期没有怎么进行体育锻炼，这一点我的确要好好反省一下。2、我发现自己还是陷入了某些人性的弱点，当意识到是各种心理因素的组合和潜意识的原因之后才知道自己是多么的愚蠢。3、专业技能还需要好好学习。4、早起早睡方面做的一点都不好。 未来的期望 1、数模比赛获得国家奖； 2、跟着鲜老师发SCI两篇左右； 3、学习一下Python数据分析、自然语言处理； 4、早睡早起(11:30~7:00)、锻炼身体； 5、看1~2个Android开源库的源码； 6、写1~2个Android小项目； 7、上课跟上老师的进度； 8、把以前的那些数学知识复习一下，并整理成博客集(至少把数学分析和高等代数整理了)； 9、看Android的书籍2本以上； 10、践行积极心理学的那些提升幸福感的方法； 11、课外书10本以上； 12、把注意力放在每一个当下、呼吸； 13、注意与朋友和恋人以及父母的沟通和联系； 写了这么多，估计也完成不了这么多，不过还是得有一点追求是不？哈哈哈，管他的呢。写在这里当摆设也不错呀。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从掌上重邮源码知需要学习的Android技能]]></title>
      <url>%2F2017%2F07%2F15%2F%E4%BB%8E%E6%8E%8C%E4%B8%8A%E9%87%8D%E9%82%AE%E6%BA%90%E7%A0%81%E7%9F%A5%E9%9C%80%E8%A6%81%E5%AD%A6%E4%B9%A0%E7%9A%84Android%E6%8A%80%E8%83%BD%2F</url>
      <content type="text"><![CDATA[最近一直在看掌上重邮的源码，感觉自己不知道的东西实在是太多了，所以在这里简单记录记录一下我需要学习的知识以及简单的Demo。 RxJavaRefronitSpinnerEventBus正则表达式与字符替换匹配lambda表达式kotlinMVPanko文件上传到牛七云轮播图自动轮播的实现Git常用命令总结(分支)2017上半年总结朱大的一些库的基本使用EasyRecyclerView RollViewPager EasyPermission RecyclerViewArray等各种注解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017数模Mathcup杯挑战赛A题总结]]></title>
      <url>%2F2017%2F06%2F10%2F2017%E6%95%B0%E6%A8%A1Mathcup%E6%9D%AF%E6%8C%91%E6%88%98%E8%B5%9BA%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[只写一下摘要和问题分析在流程工业中，钢铁冶金等行业是代表性的国民经济支柱性产业，在我国制造业升级的战略背景下，其生产过程要实现节能、优质、环保等要求。本文将以高炉冶炼优质铁水为对象，研究铁水中Si含量的动态预测以及质量指标铁水含硫量的优化设计提出四个问题。本文运用BP神经网络、最优化理论等成功的解决这几个问题，并针对如何提高铁水质量提出我们的改进方案。对于问题一，是一个典型的预测模型，一般的预测模型有神经网络，灰色系统，时间序列等。结合本题的特点我们采用BP神经网络模型和时间序列模型进行一步预测和二步预测。运用MATLAB对数据进行预测，得到预测值和真实值得图像，结果显示我们的预测值和真实值结果相对吻合。进一步得到时间序列的一步预测和二步预测结果分别为0.41476 0.443299；BP神经网络的一步预测结果为0.21603，二步预测结果为0.308044 0.27393。对于问题二，是对问题一的模型验证。我们用均值和方差来表示数值的预测成功率，用百分数来表示炉温升降方向预测成功率。运用MATLAB得到预测值和实际值的误差图像，进一步得到时间序列的数值预测误差的均值为-0.1003，方差为0.1320，炉温升降方向的预测成功率为51.52%；BP神经网络的数值预测误差的均值为-2.1222e-5，方差为0.04956，炉温升降方向的预测成功率为75.8%。由此可见对于动态预测，BP神经网络比时间序列有优势。对于问题三，我们的目的是得到硫含量的最优值。根据附件1的表格数据特点，我们得到了铁水含硅量，铁水含硫量，鼓风量，喷煤量之间的相互约束关系，并建立超定方程组AX=b，并求解得到X=[-0.01631;-0.000440;2.10369*10-5]。通过分析表中数据得到约束条件，运用Lingo，得到硫含量的最优值为0.006714。运用数据观察法，将此最优值与原数据进行比较，可以看出此结果与原始数据的硫含量很小的时候的均值相吻合。对于问题四，我们由前面的模型建立分析得出冶炼优质铁水既要降低硅含量也要降低硫含量。为此我们提出了几点改进方案，1.提高炉渣脱硫能力，2.选择适当的炉热制度，3. 富氧鼓风促使炉温升高。关键字：BP神经网络模型 时间序列模型 超定方程组 最优化理论 （一）问题一的分析问题一，是一个典型的预测模型，一般的预测模型有神经网络，灰色系统，时间序列等。本题要对铁水中的硅含量进行一步预测和二步预测。首先我们对数据表中[Si]-[S]-FL-PML依序号排列的1000炉生产大数据进行筛选，去除异常值，并采用间隔取样（以10为间隔）的方法得到100个样本数据。由于附件一的时间顺序，我们考虑建立时间序列预测模型，并借助MATLAB软件进行预测。由于BP神经网络模型能通过样本数据的训练，不断修正网络权值和阈值使误差函数沿负梯度方向下降，我们考虑使用BP神经网络模型。运用MATLAB对数据进行预测，得到预测值和真实值得图像，进一步得到一步预测和二步预测结果。（二）问题二的分析问题二，是验证问题一的模型的预测成功率。首先我们选取问题一的100个样本数据作为验证样本，并用均值和方差来表示数值的预测成功率，用百分数来表示炉温升降方向预测成功率。运用MATLAB得到预测值和实际值的误差图像，进一步得到数值预测误差的均值、方差和炉温升降方向的预测成功率。为了提高准确率，我们将问题一的BP神经网络模型和时间序列模型的预测成功率进行对比分析，比较在动态预测方面两种模型的可形性，并分析其实际应用价值。（三）问题三的分析问题三，要求解硫含量的最优模型。首先要找到目标函数为硫含量的最小值，根据附件1的表格数据特点，我们得到了铁水含硅量，铁水含硫量，鼓风量，喷煤量之间的关系，并建立超定方程组AX=b用MATLAB求解得到目标函数。其次确定约束条件，通过分析表中数据得到约束条件，由表中数据可知铁水含硅量，铁水含硫量，鼓风量，喷煤量致谢指标的波动范围，再结合他们之间的相互约束关系的到约束条件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017数模校赛总结]]></title>
      <url>%2F2017%2F06%2F10%2F2017%E6%95%B0%E6%A8%A1%E6%A0%A1%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[只稍微写一下摘要和问题分析自工业革命以来，城市化带来的成果彰显出人类经济、科技、文化的辉煌。然而，随着经济的快速发展，当今城市交通拥挤、住房紧张、贫富差距大、就业压力大等问题日益突出。建设人居环境协调发展的宜居城市已经成为了目前所有城市发展的重要目标。因此，建立一个合理的城市宜居性的评价模型对提升城市居民质量、完善城市功能和提高城市运行效率具有重要意义。 针对问题一，本文以宜居城市的内涵和系统构成为基础，讨论了影响宜居城市的指标体系，首先采用基于模糊数学的模糊层次分析法，判断社会文化、经济富裕、环境污染、公共安全、生活便捷、自然资源六个方面对城市评价的综合影响，然后分别分析各子系统下指标的相对权重，最后筛选得出评价宜居城市的主要指标有：意外死亡率、人均可用淡水资源、空气质量、噪音污染等十二个，并根据主要指标建立了基于模糊层次分析法的宜居城市评判模型。 针对问题二，本文以成渝地区为研究对象，随机选取万州、大足、永川等地，利用问题一建立的城市宜居评判模型对这十个区县进行评价。评价结果显示，万州、奉节、南川在我们选取的区县中宜居指数分别排在第一、二、三位。 针对问题三，考虑到各个指标之间有一定的相关性，简单的线性模型并不能完美地表现指标变化对最后评判的影响，这里我们引用灰色关联度矩阵分析指标之间的相关性，利用最小二乘法对方程进行拟合，判断变化会产生显著影响的指标。 针对问题四，引入负反馈地概念，城市综合系统存在某种机制，当其被遭遇不确定因素影响后，会产生抵抗力，以阻止影响地扩大。因此，我们在六个子系统外定义一个新的抵抗力系统，并利用模糊层次分析对新系统的各项指标进行加权。通过新的城市评价模型，得到前三位宜居城市分别为万州、奉节、南川。 针对问题五，我们设置一个表示指标改进难易程度的系数，其能反映改进某个指标所需付出代价的相对大小。针对万州区的实际情况，以代价作为约束条件，建立非线性规划模型，我们得出结论：增加医务人员是提高万州区宜居水平最有效的方法，其次为修建公路和等级高速公路，降低意外死亡率，提高空气质量以及提高居民收入。 关键字：模糊层次分析 灰色关联度矩阵 非线性规划 抵抗力系统 问题一的分析 题目要求筛选对评价宜居城市的主要指标，并根据所筛选的主要指标，建立一个评判城市宜居性的数学模型。由于评判城市宜居性的指标太过驳杂，我们需要先对其进行筛选，这里我们首先想到利用层次分析法，通过建立层次分析结构模型，构造判断矩阵进行层次单排序和层次总排序来求得各项指标的组合权重，以此来得到各指标的重要性。但是，我们考虑到由于判断矩阵阶数n较大时，检验其是否具有一致性非常困难，而且，判断矩阵的一致性与人类思维的一致性具有显著差异。于是，我们引入模糊数学的思想，将模糊法与层次分析法的优势结合起来，利用模糊层次分析将一些边界不清，不易定量的因素定量化，再通过模糊一致判断矩阵给予各项指标权重值，然后根据权重大小筛选主要指标。并利用筛选后的主要指标，构建评价城市宜居性的数学模型。问题二的分析 通过问题一的模型，再结合我们了解到的数据，利用matlab对成渝地区随机选择的十个区县进行研究。问题三的分析 由于某些指标之间会产生强相关性，单纯的线性模型已经不能满足我们寻找使综合评价变化显著的指标的需求，所以，我们对其进行拟合，将具有强相关性的几个指标进行替换，得到关于综合评价的非线性模型，不失一般性，我们随机抽取一个城市，利用控制变量法对相互无相关性的指标进行逐一分析，最后根据其变化趋势得到会对综合评价的变化产生显著性影响的指标。问题四分析 利用构建的模型对任选的城市进行合理性研究，考虑到城市系统在受到外界不确定因素影响时，其存在着某种机制维持整个系统的稳定，于是我们引入负反馈的概念，建立抵抗力指标，它总会在外界因素对系统产生影响时，对其影响效果进行修正。 我们在原有的六大系统外额外添加一个抵抗力系统，利用模糊层次分析法，重新对各指标的权重进行评判，结合第三问相关性模型，得到基于不确定因素的评价城市宜居性的数学模型，最后通过引入各城市的相关数据，对城市宜居指数进行评判。问题五分析 对于不同指标，由于对其进行改进的难易程度不同，所需付出的代价也不同。为了以更少的付出换来综合评价指标更大的提升，以指标的相对变化难以程度与变化指数的乘积和为约束条件，通过非线性规划模型对目标函数进行寻优，找出提升宜居性更有效率的办法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[性感的性知识--在色情作品漫天飞舞的时代老司机和小白们的不知道的真实世界]]></title>
      <url>%2F2017%2F06%2F10%2F%E6%80%A7%E6%84%9F%E7%9A%84%E6%80%A7%E7%9F%A5%E8%AF%86-%E5%9C%A8%E8%89%B2%E6%83%85%E4%BD%9C%E5%93%81%E6%BC%AB%E5%A4%A9%E9%A3%9E%E8%88%9E%E7%9A%84%E6%97%B6%E4%BB%A3%E8%80%81%E5%8F%B8%E6%9C%BA%E5%92%8C%E5%B0%8F%E7%99%BD%E4%BB%AC%E7%9A%84%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%2F</url>
      <content type="text"><![CDATA[一群因动物繁殖的本能的愚昧的雄性动物看着一部又一部的爽片，最终收获了丰满而膨胀的欲望和来之不易的关于女性的“性知识”。并以为，那就是正确而真实的知识。另外一群不解风情的人从未了解关于女性的性知识，并深刻认为，这些是不需要学习的，自认为，自己是纯洁的男人或者害羞的男人，自己是不会去了解这些的，了解这些简直是浪费时间浪费生命，甚至于都不知道女性还有阴蒂…实在不想说我们的性教育。因为对于大多数人而言，根本谈不上有性教育这回事。所以，有些人很听话，继承了父母的思想，直接放弃性教育。有些人自己专研，眼里全是三级片和飞机杯。不想改变这两类人的思想，因为我知道我无法改变一个人的思想，三言两语也之间，要想改变一个人的思想，除非触及灵魂，否则都是空谈。 不想说废话，给那些被影视文化作品洗脑的年轻人重新洗一次脑吧。 她没有出血，她不是处女？如果你现在还不知道女性有处女膜的话，我觉得你真的可以好好买两本《金赛性学报告》和《李银河性学心得》了，或者说，除了你，没人可以拯救你了。因为你自己拒绝了性。电视剧里面经典的画面：(⊙o⊙)…)，额，所以你相信了？只要是处女第一次都会出血？我只能回答你：“那你很棒棒哦”。首先科学的介绍一下处女膜：处女膜的准确名称是阴道前膜，有时候也被成为阴道膜。阴道膜是女性胎儿发育到3~4个月的时候，在从受精卵发育成快出生的胎儿的过程中，慢慢发育成人形的胚胎，再慢慢发育肝脏、腔道等。阴道的初始化状态是非腔化的，它慢慢的从非腔化变成腔道的过程就是腔化。对于胎儿而言，生殖系统和泌尿系统发育是同时进行的，在阴道腔化的同时，尿生殖窦也在发育，为了隔开两者，在阴道外端和尿生殖窦腔之间形成了一层薄膜，这层膜就是阴道前膜，也就是人们常说的处女膜。在逐渐腔化的过程中，这层膜上面开始形成孔洞。在女婴的幼儿期，这层膜会有第二次变化，这是为了适应女性的性成熟。在女性性成熟之后，这层膜仍然存在。但这层膜并不是静态的，它受女性身体激素分泌的影响较大。在没有进入青春期之前，由于女性的雌性激素水平较低，这时候它比较脆弱，有可能在极端的运动中发生撕裂。而在青春期之后，女性的雌性激素的水平上升。这层膜又重新厚实起来。在女性分娩的过程中，这层膜的弹性远远小于阴道，这在个过程中很可能被彻底撕裂。所以，由此可知，女性在不同的阶段发生了某些不可描述的画面，对于处女膜的影响很不一样。对于尚未进入青春期的女性而言，如果发生了某些不可描述的画面，那么处女膜的损伤是极大的。对于已经性成熟的女性而言，处女膜的厚度和弹性都有所增加，不容易被撕裂。当然，这还与处女膜的形态有关:最常见的几种形态是这样子：当女性发生了某些不可描述的话面的时候,处女膜被合适的器具推开(卫生棉条、振动棒、手指、男性命根子)。在大部分的时候，是这样：推开-&gt;后张-&gt;复原简单比喻：一床叠层豆腐块的被子，你用力按下去，被子会陷下去，你松开手，被子会弹起来。而你却想着要把被子按坏，手松开的时候手上还带有被子坏了的碎片。也就是影视文化作品教你的“初夜见红”。由于处女膜的孔洞原因或者器具的尺寸原因，有可能导致无法顺利处女膜推开，这时候，有可能处女膜发生撕裂。但处女膜即使被撕裂，出血的概率也很低(调查数据显示：荷兰80%的成年女性第一次未落红)。疼痛的概率也比较低。因为处女膜上面神经末梢并不丰富，处女膜破裂本身不会引起明显疼痛。但是自古以来人们都会有一个心理预设，即初夜会疼痛，因此女性才会把阴道被首次撑开的胀满的感觉和阴道粘膜被摩擦的感觉定义为痛觉。造成了很多女性性恐惧的悲剧。甚至有的传统一点的女性因为自己初夜没有出血而紧张和恐慌。男性同胞们可以想象一下：女性落红和男性落红的感觉并不会有很大的区别。如果一个男性初夜发现自己的命根子已经落红了，那么你会不会有心理阴影？时代发展到今天，女性为自己不落红而苦恼，担心自己第一次会很疼。而男性视处女如命，视初夜落红为忠诚。不得不说是人类集体的悲剧吧。送你们一句诗：初夜并非疼痛事，灵肉结合即天使。落红不是贞洁牌，化作阴影悲剧她。 (⊙o⊙)…),感染了HPV？关于HPV，不得不说几点，为了大家以后的性福生活。首先给小白们科普一下：HPV，人乳头瘤病毒是一种属于乳多空病毒科的乳头瘤空泡病毒A属，是球形DNA病毒，能引起人体皮肤黏膜的鳞状上皮增殖。表现为寻常疣、生殖器疣（尖锐湿疣）等症状。 随着性病中尖锐湿疣的发病率急速上升和宫颈癌、肛门癌等的增多，人乳头瘤病毒（hpv）感染越来越引起人们的关注。那么HPV是怎么传播给我们的呢？首先要说的是，HPV的传播包括直接性行为和间接两种，这里的性行为不单单只是插入式性交。与性行为有关的传播：(最为普遍)：接吻、口交、插入式性交、菊花交、相互自慰都有可能成为HPV的传播途径。非性行为传播：母婴传播、输血、器官移植等。一项最新的HPV研究结果表明，HPV在人体的潜伏期比较短，其感染会在性行为不久后出现。某女子学院的研究数据表明，40%的人在发生第一次性行为过后两年内都感染了HPV。HPV一共有100多种类型，常见的有HPV16，这种类型占实验感染比例的10.4%HPV=宫颈癌？先说一个数据：全球有50%的宫颈癌都是由HPV16导致的，70%的宫颈癌是由HPV16和HPV18导致的。但这并不意味着它是致癌元凶。大部分感染HPV的人并没有因此感染宫颈癌。好的是目前已经有了宫颈癌疫苗。不过疫苗并不是万能的，因为现在的疫苗只能预防HPV16和HPV18。不过疫苗的作用只能持续5~6年，而且不一定没有副作用。其次，不用害怕HPV，因为它就像感冒病毒一样常见，不用担心它，因为免疫系统会帮你清除它。怎么办呢?预防措施：避孕套、性伴侣调查数据显示，拥有固定性伴侣并长期坚持使用避孕套的人HPV传播率比较低，而且安全性行为的重要性你们都知道吧？ 活塞运动女性都很享受？我已经不想贴出来在某些动作片里面的经典的一幕了。广大男同胞们谜之相信这阴茎在性交中起到了重要作用，唯有深入阴道才能让女性获得性高潮，所以黄瓜和胡萝卜已经成为了男性认为女性想要的时候的阴茎替代品。没办法，岛国片看多了，是这样的。然而我不得不告诉你，能够在活塞运动中获得快感，不会感受到无聊和不舒服的女性，不足40%。没办法，孔子有句话，己所不欲勿施于人，也就是说我想要的别人也会想要，所以男同胞们自己想要插入却以为女性也很渴望被插入，也很会从中获得快感……另外一方面，岛国片的消费群体大多是男性，所以拍摄也是以男性视角拍摄的，所以岛国片会迎合男性。拍摄的大多都是男性粗暴的对待女性，然而女性却很享受的那种。但事实上这种事情在现实生活中发生的概率和你买彩票中奖的概率差不多。那些被毒害的男同胞们，想一下：假如你是女性，男性粗暴的插入你的身体里面你会很享受？简单比喻：一个男人饿了，以为女性自然也会和他一样饿，想要给女性喂吃的，不问对方想不想吃，直接塞进对方的嘴里……如果你是那位女性，你会很享受？还是想把那位男性小丁丁给割了，免得祸害别人？不懂得尊重伴侣的男人，也不会得到伴侣的尊重，亲密关系的基础是尊重，包括性的尊重。所以这种男人应该被割掉小丁丁，如果你是女性，一旦你的男友在性方面不尊重你，记住，只要有过。我的建议是分手吧。如果他以分手在你不情愿的情况下威胁你啪啪啪，分手吧，他不配和你在一起。如果这时候女性妥协了，放心，你已经有了90%的几率让他抛弃你，因为你不懂得尊重自己而拒绝别人。一个不懂得尊重自己的人，也不会得到别人的尊重。爱的真正含义是尊重，不是自私！！！性爱亦然。自私会获得暂时的快乐，而尊重会获得持久的快乐。被色情作品影响的男同胞们，粗暴的对待伴侣并不能使对方快乐，只能显露你的无知与愚昧。醒醒吧，男同胞们，你们所需要的不是岛国片，而是正确的性教育，你所需要的不是不仅仅是知识，更重要的换位思考与尊重！！！那么女性的性高潮大多来自哪儿呢？怎么做才会让她更舒服呢？答案是：阴蒂。在这里普及一个冷知识，勃起并不只是男人的专利。女性也勃起的工具。纳里？是的，你没有听错，它就是阴蒂。阴蒂与阴茎同源，分为三个部分，阴蒂头、阴蒂体、阴蒂脚，形状像一个倒置的Y。它的主要作用是什么呢？阴蒂是女性的身体中神经末梢最多的一个部位，没有之一。早上男性会闻鸡起”舞”，女性受到自身睾酮的影响也有可能”勃起”,唤醒自己的欲望。是的，你没有听错，女性也有睾酮。因为神经末梢很多，所以它的主要作用是负责性愉悦。嗯，事实就是女性自慰一般不会用”类阴茎”物品代替阴茎，因为大多数女性根本不需要，她们可以通过刺激阴蒂达到高潮和获得快感。 大丁丁男人让女性更满足？我的某位朋友在某些地方公然炫耀：屌大就是有自信。对于这种人，我真的无话可说，因为你无法与一只没有什么正确的性知识的雄性动物谈论性。简单比喻：你无法与一个没学过加减乘除的小学生谈论微积分。你觉得男性和女性谁更在意丁丁的大小?男性可能会说是女性，而女性会说：当然是男性，因为他们焦虑着自己的大小。事实证明男性的确对自己的丁丁有一种莫名的焦虑，而有些人表达焦虑的方式变成了自夸，比如我的那位朋友。当然这与他的岛国性知识分不开。2015年英国泌尿学会在期刊上面发表了一篇论文，我选取了一些主要的结论：在勃起状态下，男性的平均阴茎的长度在13.12cm。女性阴道在未兴奋的状态下的长度在8cm左右。针对女性的调查还表示她们的确在意阴茎的尺寸，但是大部分的男人的尺寸都在可接受范围内。女性阴道的最敏感区域在前1/3段，大概阴道入口的3~5cm。刺激到那个位置，并不需要你得丁丁有多长。男性同胞们，放下阴茎崇拜，阴茎神话一去不复返。一个可以好好前戏，懂得如何刺激阴蒂，配合伴侣的节奏的男性不需要用丁丁证明自己。就像一个真正精神丰富的人不需要通过豪车、金钱证明自己的优秀。 来一次飘飘欲仙？告诫男性：请尽力配合伴侣的节奏，你不需要前戏并不代表你的伴侣不需要。女性不想男性，女性的性，有点像烧开水，慢慢的才会沸腾，沸腾之后过一段时间才会散去。男性更像到写的V，来的快，去的也快。至于如何前戏：慢慢来，从不敏感部位开始，让伴侣做好准备。猴急是没用的(不要相信岛国片里面演的！！！那只是为了满足你的幻想而已！！！)。(脸-&gt;脖子-&gt;腿-&gt;小腹-&gt;耳洞-&gt;胸)，慢慢的进入正题，后面的画面太美我不敢描述。后戏主要是降温，不是升温，动作应越来越轻。或者亲密的对话。注意事项：如果你不想让你的伴侣躲在不正规的人流医院的某个角落里抽泣，你在旁边焦急着给你朋友打电话筹钱的话，请你做好避孕措施。不要以你一时射精的快感，毁掉你的伴侣的生育能力或者让你的伴侣终身落下某些病痛！！！如果是宫外孕那就更惨了。(受精卵本来在子宫着床的，但它迷路了待在输卵管内。简单比喻：你吃饭吃到一半饭卡在食管里面，既吐不出来也下不到胃里去)啪啪啪事后注意事项：事后不宜洗澡，男女都不宜。事后男性不宜马上起来排尿，女性可以。事后不要马上睡觉，不然疲劳感会延续到第二天。事后不要玩手机。 至于处女情结、婚前性行为等话题不在本文讨论范围之内。 好了，写到最后。我们来总结一下：第一次不见红很正常，HPV就像感冒病毒一样常见，女性一般是刺激阴蒂获得快感，而不是依靠插入式性交，女人没有阴茎崇拜，好男人不需要考丁丁证明自己，前戏对女性很重要，要做请注意避孕。 本文言论些许偏激，若有不当，请多多包含，如有得罪，作者在此道歉。另外，由于作者水平有限，难免有错误的地方，希望各位读者多多指教。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手机的阴谋--信息时代的最大骗局]]></title>
      <url>%2F2017%2F06%2F10%2F%E6%89%8B%E6%9C%BA%E7%9A%84%E9%98%B4%E8%B0%8B-%E4%BF%A1%E6%81%AF%E6%97%B6%E4%BB%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AA%97%E5%B1%80%2F</url>
      <content type="text"><![CDATA[在被偷走的时光里面，和你最亲密的，不是你的伴侣或者朋友，而是你的手机。你最离不开的，不是你的朋友和伴侣，而是你的手机。某一天忽然静下来才发现，这才是手机的阴谋–在不知不觉中偷走你的生命。科技进步的同时，需要伴随着道德的提升和人性的进步。如果科技进度太快了，那么科技终将绽放人性的黑暗与扭曲。手机带给你的感觉，本身只是一场幻觉，它让你以为你不孤独了，不无聊了，有朋友了，不被孤立了。你以为是这样子，你以为你是被迫玩手机的：一下课所有人都默默拿出了手机 ，并不是因为它好玩，也不是因为有什么重要的消息要回复。从众心理和假装自己不孤独。以及无意识的玩手机。或者说，逃避着当下应该做的事情。其实你是这样子的：有些东西只是一个死循环，但大多数人不会意识到它是一个死循环。因为无聊然后掏出手机，完了一会儿手机过后发现更无聊。因为更无聊更加想逃避这种感觉，更加沉迷于手机的恶心循环。 要深入这个话题，不得不提到一个东西：人类的感情系统的本质。人类感情系统的本质是为了保证群体存活延续，进化而来的一种内在赏罚机制。感情存在的基础往往与自身之外的事物有关。列举一些常见的感觉机制爱–感觉奖励机制让个体专注于自身之外的同类个体，更多的是保证子孙后代和繁衍对象之间的生存关系。后悔–感觉惩罚机制因为某些错误的行为，使其他亲密个体受到伤害或导致和其他个体的关系失去协调，从而不利于群体的发展和繁殖。后悔的化学反应在大脑中产生，让该个体刻骨铭心的想要通过弥补来挽回，如果无法挽回，这种感觉会促使个体在其他类似群体社会行为中尝试去补偿，从而有利于群体，避免类似的情况再次发生。快乐–感觉奖励敦促机制用来奖励个体设置的目标的达成，这种目标不分好坏，是一种奖励和敦促的混合机制，人会为了获得更多的快乐设定和完成更多的目标。无聊–感觉敦促机制当个体长时间不行动，不参与社会行为，不和其他个体互动，无法为团队生存发展做出贡献，这种内在的感觉就是敦促该个体参与到各种社会同类行为之中。痛苦–感觉惩罚敦促机制当自身目标和需求无法达成的时候，这种感觉会督促个体反省自己，改变自身的行为模式来达成目标和需求。 随着生命的繁殖与进化，感情奖励惩罚系统弥补了生物体之间的相互的生存需求，从单一的感情组合变成了复杂的感情组合。 当你看见周围的人都拿出手机在玩的时候，你也会拿出来，虽然你知道你只是因为无聊不知道该干什么而掏出了手机。你只是在逃避那种无聊的感觉，仅此而已。你只是想让自己不再感到无聊和孤独而已，而为了达到这个目的你的做法是玩手机。现实世界版的掩耳盗铃，自欺欺人，不过因为大家都在这样做，所以也显得很合理了。 当然，脑神经学家的研究结果不止于此。每一次当你刷新新闻、即时通讯的社交消息、各种新的音视频等东西的时候。大脑会分泌多巴胺(一种让你产生快乐而让你逐渐上瘾的物质) 这样做的后果是：在不知不觉中时间已经过去，等意识到时间已经过去很多的时候，又陷入后悔和痛苦之中。 那么我们该怎么办呢？百度一下，你还是不知道。其实没有答案，因为这种事情本来就要靠你的自制力与主动觉知能力。也有答案：观察自己。至于为什么，你先试试看吧，去理解什么是观察。 那你不相当于没说嘛？对，我就是什么都没说。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一次Android面试总结]]></title>
      <url>%2F2017%2F06%2F03%2F%E7%AC%AC%E4%B8%80%E6%AC%A1Android%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[学习Java&amp;Android已经有8个月的时间了，最近蠢蠢欲动，去面试了学校的某一高大上的组织。咳咳，发现自己很多东西都不太清楚，学得似是而非，Java的基础真的还需要加强，虽然我面试之前没有复习Java。那么就开始解决问题和疑惑吧，一个问题一个问题的解决，希望下次能够长点记性。 Java篇面向对象与面向过程的概念(区别和好处)我承认这个是一个很基础的问题，但还是感觉不好阐述。面向过程：面向过程是一种以事件/问题为中心的编程思想。就是分析一个事件/问题的解决步骤，用函数实现步骤，最后按照顺序调用函数。主要是该怎么做，“怎么”是重点。(程序=算法+数据)面向对象：面向对象是一种以事物为中心的编程思想。就是把事件/问题分解，然后抽象出来各种对象，接着给对象发送“消息”，让对象去完成某些步骤。主要是谁去做，“谁”是重点。(程序=对象+消息)举个栗子：以老师给学生上课为例。面向过程的思路是这样子：1、打铃后开始上课。2、老师开始讲课 3、学生开始听课 4、老师提问 5、学生回答问题 6、老师布置作业 7、学生写作业 8、学生交作业 9、老师给学生打平时成绩 10、打铃后下课而面向对象的思路却是：1、教室广播系统对象，主要行为是播放上下课铃声 2、老师对象，主要行为有讲课、提问和布置作业 3、学生对象，主要行为有听课和回答问题以及写作业等 4、评分规则系统感受到了什么？没错，面向对象是以功能块为划分的。假如现在有一个 老师给学生上课的时候有校领导来检查老师上课的质量如果是面向过程的话，几乎就要全盘改写顺序了，校领导要在打铃之前从后门进来，在老师提问和讲课的时候要认真观察学生的反应，下课之后还要和老师聊一下对老师的评价。假如是面向对象的话，那就不一样了。增加一个校领导对象，然后在增加一个校领导对老师的评价规则就可以了。得出结论，使用面向对象的编程思想更容易适应需求的变化，也就是程序的可扩展性比较好。 说明一下static和final关键字的用法和特点static概述：static直接翻译过来是静态的，就是静态成员修饰符，其修饰的静态变量脱离具体对象独立存在。举个栗子：学生读书的时候都有一个班级，但这个班级不属于任何一个人，这个班的班主任、班费也不属于任何人，班级、班主任、班费属于所有学生的整体，所以可以脱离具体的某个学生而独立存在。我们在定义学生类的时候就可以定义班级为static。由于可以不依附任何对象而独立存在，所以访问这些static成员的时候，可以通过类名加“.”进行直接访问。常见的static的用法有几种，分别是static修饰变量,static修饰方法,static修饰代码块,static修饰类一个一个的来看,首先看看static修饰变量。JVM只为static修饰的变量分配一次内存直接看Demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * Created by Grantsome on 2017/06/03 * static修饰静态变量Demo */public class StaticVariableDemo&#123; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 //声明一个叫做demo1的StaticVariableDemo的对象并将其实例化 StaticVariableDemo demo01 = new StaticVariableDemo(); &#125; //构造方法 public StaticVariableDemo()&#123; StaticStudent studentOne = new StaticStudent("Grantsome",2015213041,19,84); StaticStudent studentTwo = new StaticStudent("Grantsome",2015213041,19,84,666666); StaticStudent studentThree = new StaticStudent("Grantsome",2015213041,19,84); studentOne.getStaticStudent(); studentTwo.getStaticStudent(); studentThree.getStaticStudent(); NormalStudent studentFour = new NormalStudent("Grantsome",2015213041,19,84,777777); NormalStudent studentFive = new NormalStudent("Grantsome",2015213041,19,84); studentFour.getNormalStudent(); studentFive.getNormalStudent(); &#125;&#125;//定义有静态变量的学生类class StaticStudent&#123; String name;//姓名 int number;//学号 int age;//年龄 float score;//分数 static int inClass = 11121501;//所在班级 public StaticStudent(String mName,int mNumber,int mAge,int mScore)&#123; this.name = mName; this.number = mNumber; this.age = mAge; this.score = mScore; &#125; //构造方法 public StaticStudent(String mName,int mNumber,int mAge,int mScore,int mInClass)&#123; this.name = mName; this.number = mNumber; this.age = mAge; this.score = mScore; this.inClass = mInClass; &#125; public void getStaticStudent()&#123; System.out.println("StaticStudent "+"name="+name+" number="+number+" age="+age+" score="+score+" inClass="+inClass); &#125;&#125;//定义有没有变量的学生类class NormalStudent&#123; String name;//姓名 int number;//学号 int age;//年龄 float score;//分数 int inClass = 11121501;//所在班级 //构造方法 public NormalStudent(String mName,int mNumber,int mAge,int mScore)&#123; this.name = mName; this.number = mNumber; this.age = mAge; this.score = mScore; &#125; public NormalStudent(String mName,int mNumber,int mAge,int mScore,int mInClass)&#123; this.name = mName; this.number = mNumber; this.age = mAge; this.score = mScore; this.inClass = mInClass; &#125; public void getNormalStudent()&#123; System.out.println("NormalStudent "+"name="+name+" number="+number+" age="+age+" score="+score+" inClass="+inClass); &#125;&#125; 猜一下运行结果,由于static inClass属于一个类的整体,所以不管怎样前三个的输出结果都是一样的都是inClass=666666;没有静态变量的自然看有没有传入参数了，有传入inClass参数就输出那个参数，没有就是默认的参数。运行结果截图： 和我们想的一样。看一看直接访问Static里面的静态变量的代码：在main()里面加了一行123456public static void main(String[] args) &#123; // TODO 自动生成的方法存根 //声明一个叫做demo1的StaticVariableDemo的对象并将其实例化 StaticVariableDemo demo01 = new StaticVariableDemo(); System.out.println(StaticStudent.inClass); &#125; 运行结果截图： 接下来看看static修饰方法static修饰方法的意义和修饰变量的意义是一样的，都是可以单独调用：对象名.方法名。并且该方法不属于任何实例的对象，可以脱离于具体的对象而独立存在，它属于整个类。举个栗子：用班费这个行为不属于任何一个学生，它属于学生的整体。静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问非静态成员变量和非静态方法；非静态方法则无此限制。 提示报错，原因是不能在静态方法里面访问非静态变量，可以访问静态变量。但非静态方法可以访问静态变量。 提示报错，原因是不能在静态方法里面调用非静态方法，可以调用静态方法。但非静态方法可以调用静态方法。前面说了，static修饰的方法不能可以独立于任何实例对象而存在，那么static方法里面可以使用this和super等关键字吗？答案是不能，因为this是需要一个具体的对象的，this指向了这个具体的对象，而static方法可以不需要具体的对象，同理super也是。 没有错吧？接下来看看static修饰代码块1234567891011121314151617181920212223242526272829303132333435363738import kotlin.reflect.jvm.internal.FunctionCaller;/** * Created by Grantsome on 2017/06/03 * static修饰静态代码块Demo */public class StaticMethodDemo&#123; public static String MY_NAME = "Grantsome"; public static String HER_NAME = "Doris"; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 //声明一个叫做demo1的StaticMethodDemo的对象并将其实例化 StaticMethodDemo demo01 = new StaticMethodDemo(); &#125; //构造方法 public StaticMethodDemo()&#123; &#125; static &#123; System.out.println(MY_NAME); StaticMethodDemo.MY_NAME = "男神"; System.out.println(MY_NAME); &#125; static &#123; System.out.println(HER_NAME); StaticMethodDemo.HER_NAME = "女神"; System.out.println(HER_NAME); &#125;&#125; 运行结果截图： 静态内部内没什么好说的，都差不多，就不在赘述了。接下来说说finalfinal：最终的，不可变的，也就是具有最终态的特征的数字。首先看看final修饰变量的时候能不能被改变 编译器报错，指出final变量不能重新被赋值。所以final关键字修饰的变量是不可改变的在看看final修饰的方法。final修饰的方法，如果final方法(私有类型方法除外)是在父类里面，那么子类继承父类的时候是不能重写这个方法的。final修饰的方法，如果final方法是在父类里面，那么子类继承父类的时候是不能重写这个方法的。 接着看final修饰类。当一个类被final修饰的时候，那么这个类就不允许被继承了，按照国人的话来讲这个类就绝后了。 当final遇上static：final与static final的区别是：final在一个对象类唯一，static final在多个对象中都唯一。也就是对于某一个类的对象的整体唯一，它属于整体的不可变且唯一。一个既是static又是final的域只占据一段不能改变的存储空间，只有一份。 简要说一下继承与多态这两种特性。继承：复用代码是 Java 众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对加以改变是不够的，它还必须能够做更多的事情。在这句话中最引人注目的是“复用代码”,尽可能的复用代码使我们程序员一直在追求的，现在介绍一种复用代码的方式，也是 Java 三大特性之一—继承。概念的引入：假如我们现在要写一个班的学生类(属性有姓名、编号、年龄、班级、性别、成绩等)，又要写学院的教师类(姓名、编号、年龄、授课班级、性别、课程编号，课程名称等)，如果我们去写的话会发现他们两者具有很多相同的属性(姓名，编号，性别，年龄等)。写重复代码对于程序猿而言可不是什么光荣的事情，这时候怎么办呢？这就有了继承：我们可以抽象一个person类出来(具有姓名，编号，性别，年龄等属性)，让student混合teacher分别继承person类，继承过后person的属性和方法teacher和student也都有了。注意点：Java只支持单继承 使用父类的方法(非私有方法)的时候 super.方法名 就可以了。 多态：主要分两种多态：方法的重载与覆写 对象的多态性(向上转型和向下转型)。重载：@Overloading 指的是方法名称相同，参数类型或者个数不同，存在与一个类里面。覆写：@Override 方法名称、参数类型、返回值全部相同，并且被覆写的方法不能比父类的方法权限严格(即是说：如果一个方法在父类里面是public,那么在覆写的时候不能低于public权限(private&lt;default&lt;public))，存在与继承的时候。转型规则：向上转型：父类 具体父类对象名 = 子类实例; 向下转型：子类 子类对象 = (子类) 父类实例;注意：向下转型之前必有向上转型。egg:Father father = new Child(); Child child = (Child) father; 抽象类和接口的区别抽象类可以有默认的实现方法，而接口不允许有默认实现的方法。抽象类可以有默认的构造器，而接口不允许有。抽象类的子类通过继承(extends)抽象类来实现抽象类里面的抽象方法，如果子类不是抽象类，需要实现所有的抽象方法。接口通过实现(implments)所有的抽象方法。抽象类访问修饰符自己定义，而接口的访问修饰符只能是默认的public,不能写其他的访问修饰符。抽象类里面加入新方法可以自己实现，也可以由子类实现，而接口必须有子类实现。 “==”和equals()的区别==是比较两个变量所指向的地址(内存区域)是否相同，而equals()是比较值//内容是否相同(没有覆写的情况下，也就是默认情况)。例子：123456789101112131415161718public static void main(String[] args) &#123; String s1 = "Hello World"; String s2 = new String("Hello World"); String s3 = "Hello World"; if(s1==s2)&#123; System.out.println("s1==s2"); &#125; if(s1.equals(s2))&#123; System.out.println("s1.equals(s2)"); &#125; if(s1==s3)&#123; System.out.println("s1==s3"); &#125; if(s1.equals(s3))&#123; System.out.println("s1.equals(s3)"); &#125; &#125; 输出结果： 分析原因：程序在运行的时候会创建一个字符串缓冲池当使用 s1 = “Hello World” 这样的表达是创建字符串的时候，程序首先会在这个String缓冲池中寻找相同值的对象，在第一个程序中，s1先被放到了池中，所以在s3被创建的时候，程序找到了具有相同值的 s1，将s3引用s1所引用的对象”Hello World”.s2创建的时候使用了 new 操作符，也即：明白的告诉程序：”我要一个新的！不要旧的！”于是一个新的”Hello World”的Sting对象被创建在内存中。他们的值相同，但是位置不同，所以才出现了上面的结果。稍微修改一下代码：12345678910111213141516171819public static void main(String[] args) &#123; String s1 = "Hello World"; String s2 = new String("Hello World"); String s3 = "Hello World"; s2 = s2.intern(); if(s1==s2)&#123; System.out.println("s1==s2"); &#125; if(s1.equals(s2))&#123; System.out.println("s1.equals(s2)"); &#125; if(s1==s3)&#123; System.out.println("s1==s3"); &#125; if(s1.equals(s3))&#123; System.out.println("s1.equals(s3)"); &#125; &#125; 执行结果： 分析原因：检查字符串池里是否存在”Hello World”这么一个字符串，如果存在，就返回池里的字符串；如果不存在，该方法会 把”Hello World”添加到字符串池中，然后再返回它的引用。 set和list的区别List的接口实现类：LinkedList ArrayList Vector ，而Set的接口实现类：HashSet LinkedHashSetList放入有顺序，可重复 而Set不可重复并且无顺序。List适合经常追加数据、插入删除数据。 反射的原理JAVA反射机制是:在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。也就是提供如下功能：在运行时判断任意一个对象所属的类。在运行时构造任意一个类的对象。在运行时判断任意一个类所具有的成员变量和方法。在运行时调用任意一个对象的方法。 先看一个简单的例子：123456789Class ReflectDemo&#123;&#125;public class GetClassNameDemo&#123; public static void main(String args[])&#123; ReflectDemo reflect = new ReflectDemo(); System.out.println(reflect.getClass().getName()); &#125;&#125; 运行结果：ReflectDemo为什么会有一个getClass()的方法呢？因为这个类默认继承Object。返回的class是反射的源头。正常情况下，我们实例化一个对象的时候都是这样子：首先引入需要的路径(包名.类名)，然后通过new得到实例化对象，有没有其他方法呢？有，通过反射。再来看一个小例子： 12345678910111213141516171819202122Class ReflectDemo&#123;&#125;public class GetClassNameDemo&#123; public static void main(String args[])&#123; ReflectDemo r = new ReflectDemo(); System.out.println(r.getClass().getName()); Class&lt;?&gt; c1 = null; Class&lt;?&gt; c2 = null; Class&lt;?&gt; c3 = null; try&#123; c1 = Class.forName("ReflectDemo"); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; c2 = new ReflectDemo().getClass(); c3 = ReflectDemo.class; System.out.println("c1的类名称 " + c1.getName()); System.out.println("c2的类名称 " + c2.getName()); System.out.println("c3的类名称 " + c3.getName()); &#125;&#125; 运行结果：ReflectDemoReflectDemoReflectDemo 接着我们看如何实例化一个对象：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Person&#123; private String name; private int age; public Person()&#123; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "姓名: " + name + " 年龄: " + age; &#125; &#125;public class GetClassNameDemo&#123; public static void main(String args[])&#123; Class&lt;?&gt; c = null; try&#123; c = Class.forName("Person"); &#125;catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125; Person person = null; try&#123; person = (Person) c.newInstance(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; person.setName("Grantsome"); person.setAge(19); System.out.println(person); &#125;&#125; 运行结果：姓名: Grantsome 年龄: 19 再看看如何取得类的结构： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283interface China&#123; public static final String NATIONAL = "China"; public static final String AUTHOR = "Grantsome"; void sayChina(); String sayHello(String name,int age);&#125;class Person implements China&#123; private String name; private int age; public Person(String name,int age)&#123; this.age = age; this.name = name; &#125; public Person()&#123; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "姓名: " + name + " 年龄: " + age; &#125; @Override public void sayChina() &#123; System.out.println("作者：" + AUTHOR +" 国家：" + NATIONAL); &#125; @Override public String sayHello(String name, int age) &#123; return name + ",你好！我今年" +age + "岁了"; &#125;&#125;public class GetClassNameDemo&#123; public static void main(String args[])&#123; Class&lt;?&gt; c1 = null; try&#123; c1 = Class.forName("Person"); &#125;catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125; Method m[] = c1.getMethods();//得到全部方法 for(int i=0;i&lt;m.length;i++)&#123; Class&lt;?&gt; r = m[i].getReturnType();//得到方法的返回值 Class&lt;?&gt; p[] = m[i].getParameterTypes();//得到全部参数的类型 System.out.print(Modifier.toString(m[i].getModifiers()) + " " + r.getName() + " " + m[i].getName() + "("); for (int j = 0; j &lt; p.length; j++) &#123; System.out.print(p[j].getName() + " " + "arg" + j); if (j &lt; p.length - 1) &#123; System.out.print(","); &#125; &#125; System.out.print(")"); System.out.println(""); &#125; &#125;&#125; 先就写这么多吧。 Android篇]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈思考--决定命运的上帝之手]]></title>
      <url>%2F2017%2F05%2F10%2F%E6%B5%85%E8%B0%88%E6%80%9D%E8%80%83--%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90%E7%9A%84%E4%B8%8A%E5%B8%9D%E4%B9%8B%E6%89%8B%2F</url>
      <content type="text"><![CDATA[保持宇宙般的冷静与理智，改变你自身固有的观念，你就是在改变命运。你的命运来源于你的行为，你的行为来源于你的思考。无形的思考影响着生活的点点滴滴。思考来源于你的经历和信息，你的经历和信息来源于外界规则（物理规则、人性规则、社会运行规则、概率规则等）的运作。很多东西看上去很简单，但却没有一个具体的概念，比如思考，如果你要对思考下一个定义，你的定义是什么？ 什么是思考来自百度百科的定义：思考是思维的一种探索活动，源于主体对意向信息的加工。思考力则是在思维过程中产生的一种具有积极性和创造新的作用力。来自Wikipedia的定义：思考是高级的心理活动形式，人脑对信息的处理包括分析、抽象、概括、综合、对比系统和具体的过程。通俗一点的定义：思考是一个大脑与自我对话的过程，举个例子，比如说一个小学生在做一道3+7=？的题目，如果这个小学生的自我对话的过程是这样子的：3+7=？，我不知道哎，怎么办呢？到底等于什么呢？我不知道哎，怎么办呢？到底等于什么呢？然后陷入死循环……最后放弃思考。假如这个小学生的自我对话的过程是这样子的：3+7=？呢，我不知道哎，让我扳扳手指头，1,2,3,加7,再数七个4,5,6,7,8,9,10。10，3+7的答案是10。这就是思考。思考的质量决定了你的行为，进一步决定你的命运。思考才是真正拉开人与人之间差距的地方。会思考的人引领着时代。那么，思考的关键是什么呢？先想一下这个问题，不要急着看下面的内容。 思考的关键1、分解问题2、寻找信息3、得出结论首先来看一个经典的例子。 此时此刻地球上有多少人正在经历性高潮？无厘头的问题对吧？这个不是关键。关键是，这个问题我们要怎么思考？到底此时此刻有多少人在经历性高潮呢？怎么入手呢？1、问题分解：(1)、时间(一天内)与性高潮次数的分布情况是怎样的？(2)、性高潮持续的时间是多久？(3)、性高潮可能发生的人群占全球总人数的比例是多少？(4)、在可能发生性高潮的人群中性高潮发生的频率(一天内)是多少?(5)、全球总人口是多少？来一张思维导图：现在知道怎么解决了吧？接下来就是查阅数据就可以知道答案了。理工科的问题可以这样试着去解决，如果有人做过数模，就会明白这些常见的思维方式了。 思考的误区死循环学过计算机语言的人都知道死循环是什么吧？在这里就没有必要用C/C++/Java写个死的for循环了。也就是我们经常说的瓶颈。例如：考试的时候一道题苦思冥想很久还是没有做出来导致后面的题目没有做。上课的时候有一个地方没听懂导致自己后面半节课都在想那个问题，至于老师后面讲了什么，完全不知道了。选择题，在A和B之间纠结，选A之后觉得B也对，选B之后觉得A也对，不停的循环着相同的纠结。导致死循环的原因：信息量不够的时候想的太多。当然原因可能不止这一个。思维的死循环有很多体现：因为觉得无聊所以玩手机，玩手机之后感觉自己越来越无聊，然后循环：玩手机-&gt;无聊，无聊-&gt;玩手机，陷入其中无法自拔。大一新生往往因为觉得没什么事情可做觉得迷茫，因为迷茫所以不想学习，不想学习不吸收新的思想观念和知识加重迷茫的感觉。自制力差一点的青少年在青春期因对性的渴望容易沉迷于色情影视作品和小说，看了色情影视作品和小说之后又增加了对性的渴望。那么我们究竟应该怎么办呢？可以避免出现思维的死循环吗？我的答案是：NO，你无法避开它。最好的做法就是意识到自己已经陷入死循环之中，然后转移你的注意力，和你的挚友、老师、大牛聊聊陷入死循环的地方，或者去看看相关的资料。改变你自身的固有的意见。还是没有办法解决的话，先停止思考它，等过一段时间再来思考。你可能会说了，你不相当于没说嘛，是的，我只是告诫一下不要沉溺于思维的循环里面，做些别的事情，让大脑放松一下。因为你不放松想也想不出来什么东西。 思考的方法核心:可视化下面说的一些观点你们可能不是很赞同，但我还是要说。在大多情况下你的思考都是混乱的，原因很简单，大脑并不喜欢线性的思考，也就是大脑不擅长一个问题一个问题的想清楚在去思考下一个，大脑没有这么强大。大脑最喜欢的就是在思考的时候制造噪音。举个例子：你在思考文化的本质是什么，没想两分钟，突然冒出来一个念头：今天中午吃什么？然后你意识到你应该思考问题的，思考文化的本质是什么，但这时候你已经不知道刚刚想到的那个观点是什么了，你已经忘了。就像在做题的时候，你突然想到了思路，旁边的同学不小心推了一下你，你问他他要干嘛？他说他是不小心碰到你了，然后你回去继续做题，却发现自己已经忘了之前的思路了。大脑的思考方式是跳跃性的，并不是按部就班的。大家都记得数学老师吧，数学老师上课的时候会写满满一黑板。特别是公式的推到，定理的证明的时候。为什么，只有把思路写出来，才更容易理清思路，克服大脑的先天性特点。也就是可视化，可视化是思维的工具。把思考的过程写出来、画出来就是可视化。目的是减少跳跃性思考带来的遗忘和清空需要大脑费精力去记忆的东西以及减少大脑在思考过程中的混乱感。画思维导图、在纸上写下来都是不错的方式。 零秒思考法解决复杂的问题，你需要一个大的内存。我们的大脑的工作内存和认知负荷都是有限的，只能同时处理3~5个认知单元，当我们集中全部精力思考某一个问题的时候，需要抑制其他脑区的运作。但一个问题越复杂，需要推导的步骤越多，需要调用的知识也就越多。这像一个悖论：我们一边要聚焦问题，一边要发散思考。所以我们办不到，大多数的情况：你苦思冥想，聚焦问题，还是百思不得其解。所以，天才第一步：清空大脑,并处理好情绪。不要在有情绪的时候思考问题，情绪作用于潜意识，虽然你看不见它在影响你的思考。比如你在不同的情绪下敲键盘的力度和写字的力度都是不一样的，敲出来的字和写出来的字的内容也不一样。也就是保持宇宙般的冷静与理智。如果你没有做好第一步，那么接下来的步骤即使你完成了，效果也会大打折扣。但不得不告诉你，很少有人可以做好第一步。所以，好好加油吧。1、一张A4纸横放，左上角写上问题的题目2、写4~6行你对于这个问题的思路、疑惑(大概15-20个字)3、2分钟之内完成4、坚持写10页，写15~20分钟好了，步骤到此为止了。至于例子，(⊙o⊙)…，懒得写，不写了，实践出真知。 换位思考法知道别人的真实想法的最好方法–换位思考法举个简单的例子：哪种男性在婚恋市场上最不受欢迎？这时候如果你是一个男性，想象一下如果你是女性，你讨厌哪种男性？随便说几点：1、不负责任 2、不独立 3、不懂得照顾别人不负责任，不用说了。不独立：指妈宝男这一类人，还有永远不会分担家务的人，假如你是一个女人，你愿意嫁给一个什么家务都不会做的“小男孩”？照顾自己都照顾不好的人，你还指望他照顾你们未来的孩子？ 参考书籍：《超级思维》 《清晰思考的艺术》 《批判性思考》 《零秒思考》 总结一下：思考是一个大脑与自我对话的过程，思考的关键在于分解问题，思考的误区在于死循环，思考的方法核心是可视化，方法常见的有零秒思考和换位思考。以上均是个人观点，各位不要盲信，选择性吸收。如发现有值得探讨的地方，欢迎私下交流。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android常用的工具类]]></title>
      <url>%2F2017%2F05%2F10%2FAndroid%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[Android开发的时候为了减少重复代码，封装和解耦是必要的。简洁清晰的代码给人如沐春风的感觉。而工具类就可以办到这一点。今天就先简单谈谈我对经常使用的工具类。 SharedPreferences工具类SharedPreferences是我们进行轻量级数据存储的时候经常使用的工具，比如记住密码和账号功能(密码的话，使用这个有点不安全哎)，还有区分已读未读新闻等功能都可以使用SharedPreferences。但如果每次都要创建一个SharedPreferences和editor最后apply的话，也太麻烦了吧，而且重复代码看起来让人很不舒服。那么怎么封装呢？1234567891011121314151617181920212223import android.content.Context;import android.content.SharedPreferences;import android.preference.PreferenceManager;/** * Created by Grantsome on 2017/2/15. * 轻量级存储工具类(SharedPreferences) */public class PreUtil &#123; public static void putStringToDefault(Context context,String key,String value)&#123; SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context); sharedPreferences.edit().putString(key,value).commit(); &#125; public static String getStringFromDefault(Context context,String key,String value)&#123; SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context); return sharedPreferences.getString(key,value); &#125;&#125; 使用的时候，以阅读新闻并记录新闻的id为例,对于每一个item,点击过后会都记录在SharedPreferences里面1234567891011121314151617181920212223242526272829listViewNews.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; //实例化stories,目的是后面的传值(这里不重要) Stories stories = (Stories) adapterView.getAdapter().getItem(i); Intent intent = new Intent(activity, LatestContentActivity.class); intent.putExtra("stories",stories); intent.putExtra("isLight",((MainActivity) activity).isLight()); isRead = true; intent.putExtra("isRead",isRead); //自己定义的getStringFromDefault方法 //主要是利用了SharedPreference实现已读和未读的区分 //首先加载以前的读过的新闻的id; String readSequence = PreUtil.getStringFromDefault(activity, "read", ""); //给readSequence里面的id用逗号,隔开 String[] splits = readSequence.split(","); //当读过的记录里面没有刚刚点开的id的时候,加入id if (!readSequence.contains(stories.getId() + "")) &#123; readSequence = readSequence + stories.getId() + ","; &#125; //把读过的新闻的id重新写入SharedPreference PreUtil.putStringToDefault(activity, "read", readSequence); startActivity(intent); activity.overridePendingTransition(0,0); &#125; &#125;); return view; &#125; 我想写到这里大家都明白了吧？ Log工具类在开发的时候,我们经常会用到Log,但我们开发完成之后就不需要使用log了，难道要一行一行删掉？显然不科学，好像这个是很高级的功能，不过你看看就明白了。来自《第一行代码》1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import android.util.Log;/** * Created by Grantsome on 2017/2/12. * 打印日志工具 */public class LogUtil &#123; public static final int VERBOSE = 1; public static final int DEBUG = 2; public static final int INFO = 3; public static final int WARN = 4; public static final int ERROR = 5; public static final int NOTHING = 6; public static int level = VERBOSE; public static void v(String tag,String msg)&#123; if(level&lt;=VERBOSE)&#123; Log.v(tag,msg); &#125; &#125; public static void d(String tag,String msg)&#123; if(level&lt;=DEBUG)&#123; Log.d(tag,msg); &#125; &#125; public static void i(String tag,String msg)&#123; if(level&lt;=INFO)&#123; Log.i(tag,msg); &#125; &#125; public static void w(String tag,String msg)&#123; if(level&lt;=WARN)&#123; Log.w(tag,msg); &#125; &#125; public static void e(String tag,String msg)&#123; if(level&lt;=ERROR)&#123; Log.e(tag,msg); &#125; &#125;&#125; 使用的时候很简单，在开发的时候上面的可以不用变，发布的时候就可以直接改变level的值控制了。 network检查工具12345678910111213141516171819202122import android.content.Context;import android.net.ConnectivityManager;import android.net.NetworkInfo;/** * Created by tom on 2017/4/27. * network检查工具 */public class NetworkUtils &#123; public static boolean isNetWorkConnected(Context context)&#123; if(context!=null)&#123; ConnectivityManager manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = manager.getActiveNetworkInfo(); if(networkInfo!=null)&#123; return networkInfo.isAvailable(); &#125; &#125; return false; &#125;&#125; 一定要注意网络权限12&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; CircleImage工具图片圆形化工具，虽然有开放的库，但这个实现不是很难，于是就自己写了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.grantsome.newbihu.View;import android.content.Context;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Matrix;import android.graphics.Paint;import android.graphics.PorterDuff;import android.graphics.PorterDuffXfermode;import android.graphics.drawable.BitmapDrawable;import android.graphics.drawable.Drawable;import android.util.AttributeSet;import android.widget.ImageView;/** * Created by Grantsome on 2017/4/27. * 图片圆形化工具 */public class CircleImage extends ImageView &#123; private Paint mPaint = new Paint(); public CircleImage(Context context) &#123; super(context); &#125; public CircleImage(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; public CircleImage(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; private Bitmap scaleBitmap(Bitmap bitmap)&#123; float scale = (float) getWidth()/bitmap.getHeight(); Matrix matrix = new Matrix(); matrix.postScale(scale,scale); return Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),matrix,true); &#125; @Override protected void onDraw(Canvas canvas)&#123; Drawable drawable = getDrawable(); if(drawable!=null)&#123; Bitmap rawBitmap = ((BitmapDrawable) drawable).getBitmap(); Bitmap newBitmap = scaleBitmap(rawBitmap); Bitmap circleBitmap = getCircleBitmap(newBitmap); mPaint.reset(); canvas.drawBitmap(circleBitmap,0,0,mPaint); &#125; &#125; private Bitmap getCircleBitmap(Bitmap bitmap)&#123; Bitmap circleBitmap = Bitmap.createBitmap(bitmap.getWidth(),bitmap.getHeight(), Bitmap.Config.ARGB_4444); Canvas canvas = new Canvas(circleBitmap); mPaint.setAntiAlias(true); canvas.drawARGB(0,0,0,0); int radius = bitmap.getWidth()/2; canvas.drawCircle(radius,radius,radius,mPaint); //SRC_IN 上下层都显示,下层居上显示。 mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(bitmap,0,0,mPaint); return circleBitmap; &#125;&#125; 使用的时候在xml文件里面初始化就可以了。 ApplicationContext获取工具有时候不是很好获取context，怎么办呢？这时候网上的代码直接复制过来就好了。修改manifest1234567891011121314151617181920212223242526272829303132333435&lt;application android:name=".Util.ApplicationContext" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/Theme.AppCompat.Light.NoActionBar"&gt;```'=android:name=".ApplicationContext"很重要，不然程序会崩溃```javaimport android.app.Application;import android.content.Context;/** * Created by tom on 2017/4/27. * context获取工具 */public class ApplicationContext extends Application &#123; private static Context mContext; @Override public void onCreate()&#123; super.onCreate(); mContext = getApplicationContext(); &#125; public static Context getContext()&#123; if(mContext==null)&#123; return null; &#125; return mContext; &#125;&#125; fragment commit工具每一个fragment需要commit到add和commit到我们FragmentManager上面,这个如果每一个fragment都这样写那就太没有效率了，我们可以考虑封装一下。1234567891011121314151617181920212223242526272829import android.os.Bundle;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v7.app.AppCompatActivity;import com.grantsome.newbihu.R;/** * Created by tom on 2017/3/22. * Fragment工具类 */public abstract class SuperFragmentActivity extends AppCompatActivity &#123; protected abstract Fragment createFragment(); @Override public void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_fragment); FragmentManager fragmentManager = getSupportFragmentManager(); Fragment fragment = fragmentManager.findFragmentById(R.id.activity_main_fragment_container); if(fragment == null)&#123; fragment = createFragment(); fragmentManager.beginTransaction().add(R.id.activity_main_fragment_container,fragment).commit(); &#125; &#125;&#125; 命名为activity_fragment.xml的文件123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main_fragment_container" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context="com.grantsome.newbihu.Activity.LoginActivity"&gt;&lt;/RelativeLayout&gt; 在每一个Activity里面，继承SuperFragmentActivity，然后在implement里面的抽象类方法。实现该方法,也就是构造一个fragment的实例。这样就可以安心的使用了。 Toast工具类虽然这个只需要一行，可是很长的情况下也可以考虑封装一下。123456789101112131415161718import android.widget.Toast;/** * Created by tom on 2017/4/27. * Toast工具类 */public class ToastUtils &#123; public static void showError(String error)&#123; Toast.makeText(ApplicationContext.getContext(), error, Toast.LENGTH_SHORT).show(); &#125; public static void showHint(String result)&#123; Toast.makeText(ApplicationContext.getContext(),result,Toast.LENGTH_SHORT).show(); &#125;&#125; 动态权限申请建议是写一个BaseActivity,在这个activity里面写onRequestPermissionsResult()方法，然后其他的activity继承这个类就可以了1234567891011121314151617181920212223242526272829303132333435/** * Created by tom on 2017/4/13. */public class BaseActivity extends AppCompatActivity &#123; protected static final int OPEN_ALBUM = 0; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); &#125; @Override protected void onDestroy()&#123; super.onDestroy(); &#125; //用户同意/拒绝,activity的onRequestPermissionsResult会被回调来通知结果 @Override public void onRequestPermissionsResult(int requestCode, @Nullable String[] permissions,@Nullable int[] grantResults)&#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); if(requestCode == 1 &amp; grantResults.length &gt; 0 &amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; //逻辑操作 &#125; &#125; public void check()&#123; if(ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)!=PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(this,new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,OPEN_ALBUM); &#125;else &#123; //逻辑操作 &#125; &#125;&#125; 然后每一个申请的时候调用super.check()就可以了。 toolbar工具很多时候不想用默认的toolbar，自己写的话每一个activity都写太麻烦，所以思路和上面的一样,写在BaseActivity里面,要注意导包的时候是import android.support.v7.widget.Toolbar，还有一点最重要的是manifest里面写1234567&lt;application android:name=".Util.ApplicationContext" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/Theme.AppCompat.Light.NoActionBar"&gt; android:theme=”@style/Theme.AppCompat.Light.NoActionBar”很重要1234567891011121314151617181920212223242526272829303132public class BaseActivity extends AppCompatActivity &#123; protected static final int OPEN_ALBUM = 0; protected Handler mHandler; public static Context sContext; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); mHandler = new Handler(); sContext = this; &#125; @Override protected void onDestroy()&#123; super.onDestroy(); &#125; public void setUpToolbar()&#123; Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); ActionBar actionBar = getSupportActionBar(); if(actionBar!=null)&#123; actionBar.setDisplayHomeAsUpEnabled(true); actionBar.setHomeAsUpIndicator(R.drawable.ic_arrow_back_black_24dp); &#125; &#125;&#125; 前提是你的每一个toolbar的id都是android:id=”@+id/toolbar”,记住。 bitmap工具加载图片的时候经常会用到的123456789101112131415161718192021222324252627282930313233343536373839404142434445import android.content.ContentUris;import android.content.Intent;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.os.Build;import android.provider.DocumentsContract;import android.provider.MediaStore;import android.support.annotation.Nullable;import android.support.annotation.RequiresApi;import com.grantsome.newbihu.Activity.BaseActivity;import java.io.ByteArrayOutputStream;import java.io.InputStream;/** * Created by tom on 2017/4/28. */public class BitmapUtils &#123; public static Bitmap toBitmap(byte[] src)&#123; return BitmapFactory.decodeByteArray(src,0,src.length); &#125; @Nullable public static Bitmap toBitmap(Uri uri)&#123; try &#123; InputStream inputStream = ApplicationContext.getContext().getContentResolver().openInputStream(uri); return BitmapFactory.decodeStream(inputStream); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125; public static byte[] toBytes(Bitmap bitmap)&#123; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.JPEG,100,outputStream); return outputStream.toByteArray(); &#125;&#125; 网络请求工具这个有点小复杂，首先看第一个方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public static String getElement(String data, String name) &#123; try &#123; return new JSONObject(data).getString(name); &#125; catch (JSONException e) &#123; e.printStackTrace(); Log.w("tag", e.toString()); &#125; return null; &#125;``` 这个方法是返回data里面的string,但一般会返回null，价值不是很大。```javapublic static class Response&#123; private int mStatus; private String mInfo; private byte[] mData; Response(byte[] response)&#123; String rawData = new String(response); mInfo = JsonParser.getElement(rawData,"info"); if(mInfo==null)&#123; mStatus = 200; mData = response; &#125;else &#123; mStatus = Integer.parseInt(JsonParser.getElement(rawData,"status")); if(JsonParser.getElement(rawData,"data")!=null)&#123; mData = JsonParser.getElement(rawData,"data").getBytes(); &#125;else &#123; mData = null; &#125; &#125; &#125; public int getStatusCode()&#123; return mStatus; &#125; public String getInfo() &#123; return mInfo; &#125; //是否成功相应网络请求 public boolean isSuccess()&#123; return mStatus == 200; &#125; //返回状态消息 public String message()&#123; return "status:" + mStatus + "\ninfo:" + mInfo; &#125; //返回请求回来的String类型的数据 public String bodyString()&#123; return new String(mData); &#125; //返回byte[] 类型的数据 public byte[] bodyBytes()&#123; return mData; &#125; &#125; 这是工具类里面得一个内部类,主要的作用是提供方法返回服务器响应之后的数据。首先判断通过getElement()的值是否为空，如果是则赋值给mData，否则把构造函数里面的参数赋值给对应mData。然后是一些常见的提供返回值的方法，没什么好说的。123456public interface Callback &#123; void onResponse(Response response); void onFail(Exception e); &#125; 定义了一个接口，没什么好说的。是不是觉得Callback似曾相识？对，我们在依赖别人的库的时候有时候就会出现callback，里面定义的方法含义也是类似的。12345678910private static byte[] read(InputStream is) throws IOException &#123; final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); byte[] temp = new byte[1024]; int len; while((len=is.read(temp))!=-1)&#123; outputStream.write(temp,0,len); &#125; is.close(); return outputStream.toByteArray(); &#125; 读数据的方法,几乎是模板了。没什么好说的。1234567891011121314public static void sendHttpRequest(String address,String param)&#123; sendHttpRequest(address, param, new Callback() &#123; @Override public void onResponse(Response response) &#123; &#125; @Override public void onFail(Exception e) &#123; ToastUtils.showError(e.toString()); &#125; &#125;); &#125; 发送网络请求的第一个方法,里面什么也没有，调用了下面即将要写的一个函数。重点要来了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static void sendHttpRequest(final String address,final String param,final Callback callback)&#123; if(!NetworkUtils.isNetWorkConnected(ApplicationContext.getContext()))&#123; callback.onFail(new Exception("无法连接到网络")); return; &#125; final Handler handler = new Handler(); new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection =null; try&#123; URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); connection.setReadTimeout(5000); connection.setConnectTimeout(10000); if(param==null)&#123; connection.setRequestMethod("GET"); &#125;else &#123; //如果参数不为空则设置为post方法。 connection.setRequestMethod("POST"); connection.setDoInput(true); OutputStream os = connection.getOutputStream(); os.write(param.getBytes()); os.flush(); os.close(); &#125; if(connection.getResponseCode()==200)&#123; final byte[] temp = read(connection.getInputStream()); handler.post(new Runnable() &#123; @Override public void run() &#123; callback.onResponse(new Response(temp)); &#125; &#125;); if(connection.getRequestMethod().equals("GET"))&#123; //截取的address里面/的部分+1 String name = address.substring(address.lastIndexOf('/')+1); //通过Context.getExternalCacheDir()方法可以获取到 SDCard/Android/data/你的应用包名/cache/目录，一般存放临时缓存数据 File file = new File(ApplicationContext.getContext().getExternalCacheDir(),name); FileOutputStream os = new FileOutputStream(file); os.write(temp); os.close(); &#125; &#125;else &#123; throw new Exception("无法连接到服务器"); &#125; &#125;catch (final Exception e)&#123; e.printStackTrace(); handler.post(new Runnable() &#123; @Override public void run() &#123; callback.onFail(e); &#125; &#125;); &#125;finally &#123; if(connection!=null)&#123; connection.disconnect(); &#125; &#125; &#125; &#125;).start(); &#125; 这里的逻辑有点复杂，我们来慢慢看。首先新建了一个handler,然后新开了一个线程处理耗时操作，并且是Thread.start()。线程里面实现了runnable，并在网络请求中设置如果参数为空就用get方法，不为空即post方法。如果返回成功就用handler.post()里面写一个待实现的callback.onResponse(Response response)方法。并且如果方法为get就把文件写入temp赋值给response。仔细看一下看完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185package com.grantsome.newbihu.Util;import android.os.Handler;import com.qiniu.android.common.Zone;import com.qiniu.android.http.ResponseInfo;import com.qiniu.android.storage.Configuration;import com.qiniu.android.storage.UpCompletionHandler;import com.qiniu.android.storage.UploadManager;import org.json.JSONObject;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.HttpURLConnection;import java.net.URL;/** * Created by tom on 2017/4/27. */public class HttpUtils &#123; public static void sendHttpRequest(String address,String param)&#123; sendHttpRequest(address, param, new Callback() &#123; @Override public void onResponse(Response response) &#123; &#125; @Override public void onFail(Exception e) &#123; ToastUtils.showError(e.toString()); &#125; &#125;); &#125; public static void sendHttpRequest(final String address,final String param,final Callback callback)&#123; if(!NetworkUtils.isNetWorkConnected(ApplicationContext.getContext()))&#123; callback.onFail(new Exception("无法连接到网络")); return; &#125; final Handler handler = new Handler(); new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection =null; try&#123; URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); connection.setReadTimeout(5000); connection.setConnectTimeout(10000); if(param==null)&#123; connection.setRequestMethod("GET"); &#125;else &#123; connection.setRequestMethod("POST"); connection.setDoInput(true); OutputStream os = connection.getOutputStream(); os.write(param.getBytes()); os.flush(); os.close(); &#125; if(connection.getResponseCode()==200)&#123; final byte[] temp = read(connection.getInputStream()); handler.post(new Runnable() &#123; @Override public void run() &#123; callback.onResponse(new Response(temp)); &#125; &#125;); if(connection.getRequestMethod().equals("GET"))&#123; //截取的address里面/的部分+1 String name = address.substring(address.lastIndexOf('/')+1); //通过Context.getExternalCacheDir()方法可以获取到 SDCard/Android/data/你的应用包名/cache/目录，一般存放临时缓存数据 File file = new File(ApplicationContext.getContext().getExternalCacheDir(),name); FileOutputStream os = new FileOutputStream(file); os.write(temp); os.close(); &#125; &#125;else &#123; throw new Exception("无法连接到服务器"); &#125; &#125;catch (final Exception e)&#123; e.printStackTrace(); handler.post(new Runnable() &#123; @Override public void run() &#123; callback.onFail(e); &#125; &#125;); &#125;finally &#123; if(connection!=null)&#123; connection.disconnect(); &#125; &#125; &#125; &#125;).start(); &#125; private static byte[] read(InputStream is) throws IOException &#123; final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); byte[] temp = new byte[1024]; int len; while((len=is.read(temp))!=-1)&#123; outputStream.write(temp,0,len); &#125; is.close(); return outputStream.toByteArray(); &#125; public interface Callback &#123; void onResponse(Response response); void onFail(Exception e); &#125; public static class Response&#123; private int mStatus; private String mInfo; private byte[] mData; Response(byte[] response)&#123; String rawData = new String(response); mInfo = getElement(rawData,"info"); if(mInfo==null)&#123; mStatus = 200; mData = response; &#125;else &#123; mStatus = Integer.parseInt(JsonParser.getElement(rawData,"status")); if(getElement(rawData,"data")!=null)&#123; mData = JsonParser.getElement(rawData,"data").getBytes(); &#125;else &#123; mData = null; &#125; &#125; &#125; public int getStatusCode()&#123; return mStatus; &#125; public String getInfo() &#123; return mInfo; &#125; public boolean isSuccess()&#123; return mStatus == 200; &#125; public String message()&#123; return "status:" + mStatus + "\ninfo:" + mInfo; &#125; public String bodyString()&#123; return new String(mData); &#125; public byte[] bodyBytes()&#123; return mData; &#125; &#125; public static String getElement(String data, String name) &#123; try &#123; return new JSONObject(data).getString(name); &#125; catch (JSONException e) &#123; e.printStackTrace(); Log.w("tag", e.toString()); &#125; return null; &#125;&#125; 暂时就这么多，感觉没有几个。可能是我写的代码不多的结果吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017数模网络赛C题总结]]></title>
      <url>%2F2017%2F04%2F23%2F2017%E6%95%B0%E6%A8%A1%E7%BD%91%E7%BB%9C%E8%B5%9BC%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[上周做了数模的网络挑战赛（认证杯第一阶段）的C题，由于自我感觉还不错，就是论文感觉没有写清楚。不能说怪队友吧，怪我喽（不当喷子）。先看看题目，C题题目。拿到这道题的时候，感觉还好做，于是乎就选择了这道题。 思路：对于第一问，我首先想到的是先把模糊的调查数据转化为数值，然后在对数据进行回归分析、主成分分析、相关性分析等东西。最后做题的时候是用的灰色关联度矩阵完成的第一问。对于第二问，价格区间，我们采用的是把调查数据里面的一些有用的东西转化为VIP会员率（也就是忠实用户的比例）。然后通过网上查询的数据，结合实际的移动端开发过程，模拟了从生产到成熟盈利的整个过程的收益和支出。并比较了大规模和小规模的产品。最终确定了价格区间和建议定价。市场占有率很明显是一个预测模型，我们首先会想到时间序列分析、灰色模型、神经网络、马尔科夫链等模型。最后我们是通过马尔科夫链以及通过正态分布改进的马尔科夫链得到市场占有率。对于第三问，我们采用的是模糊综合评价的方式对产品进行一个“打分”，最后通过考虑经济社会技术等多方面得出移动端考研产品的可行性。 要点：对于第一问，我们通过对调查数据进行筛选，最后找出问题19（花费在移动端考研产品上的时间），问题20（倾向选择的移动端考研产品内容），问题21（是否认同移动端考研产品人数使用会增长），问题22（移动端考研产品优势）和问题23（对移动端考研产品期待）对移动端考研产品的发展具有影响。首先，我们将调查问卷的文字表达转化为数值矩阵，对于我们所需研究问题的相关选项，我们先对其按照重要程度进行评分（数值为0~10），对于多选项，我们按照其每项内容分值进行累加，再利用matlab进行数据处理，得出相关数据数列。再决定以问题20（倾向选择的移动端考研产品内容）,问题23（对移动端考研产品期待）和问题22（移动端考研产品优势）作为灰色关联度矩阵的待比较数列，以问题21（是否认同移动端考研产品人数使用会增长）和问题19（花费在移动端考研产品上的时间）作为灰色关联度矩阵的参考数列。对于第二问，要找到该产品合理的价格区间，首先要对该产品的各项成本以及维护费用进行评估。我们以2017年的数据为例，根据调查问卷，得到报考研究生的总人数为201万人，而愿意选择移动端考研类产品学习的比例为53.63%。我们通过上网数据查找，将移动端产品的开发成本分为两类，利用三个不同的模型进行探讨：A． 假设用户人数稳定且不随时间变化并且盈利模式只有VIP会员收费 B、logistic模型模拟用户的变化情况。C、有第三方广告费和考虑推广时的价格比成熟的时候低的情况下。并考虑到大学生的消费能力，进行综合的考虑，得到定价区间。移动端在整个市场占有率不妨近似为移动端在填问卷调查的人中的占有率。首先将数据进行处理，假设PC端和移动端的市场占有率与它的使用时间成正比，利用附件二里在PC端和移动端的使用时间，为了方便取最下值处理，即0~1小时转换为0小时，1~2小时转换为1小时。我们可以得到PC端的使用总时间为7592小时，移动端的使用总时间为8038小时，我们就可以得到起始市场占有率，PC端为0.4857，移动端为0.5143。再统计出既不使用PC端也不使用移动端的人数，为3256人。从而我们可以把使用既PC端也使用移动端的人按照市场占有率分开，将仅使用PC端的人数为近似为（10000-3256）*0.4857=3275.6人，同理将仅使用移动端的人看作3468.4人，就可以得到初始状态。根据查找数据以及调查得到，在一个月内使用PC端的用户转移到移动端的概率为16%，转移到都不使用的概率为3%，使用移动端的用户转移到PC端的概率为8%，转移到都不使用的概率为6%，都不使用的人转移到PC端的概率是8%，转移到使用移动端的概率是14%。我们可以得到一个马尔可夫链。求解之后改进该模型：考虑到每个月转移的概率不是固定的，而转移的概率又大致服从正态分布，所以对马尔可夫模型进行改进，矩阵A的每个转移的概率都满足期望为 ，方差为0.05 的正态分布。除此之外又因为现在互联网时代的到来假设PC端和移动端都不使用的人转移概率随着月份的增加而增加，即是不转移的概率减小。对于第三问，分析移动端产品在条件比较好的城市投放的可行性，而且主要的三个因素是经济可行性，社会可行性，技术可行性。比较适合这个模型。产品可行性 A.市场分析B、技术可行性分析(支出)C、时间和资源可行性分析D、推广可行性分析(支出)E、经济可行性(收益)F、社会可行性：按照这个思路进行模糊综合评价。 论文就不在这里献丑了，需要MATLAB代码的发我邮箱，我就不在这里贴MATLAB代码了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读书的认知]]></title>
      <url>%2F2017%2F04%2F23%2F%E8%AF%BB%E4%B9%A6%E7%9A%84%E8%AE%A4%E7%9F%A5%2F</url>
      <content type="text"><![CDATA[今天是世界读书日，提到读书，很多人可能就想滔滔不绝一番了。与我而言，却有几分“欲说还羞”……我不会给你推荐什么书单，亦不会告诉你什么读书的方法，更不会和你谈读书的意义。因为，对于你我而言，说这些毫无意义，你不会因为我的一篇文章而改变太多，我亦不会因为这篇文章而变得和以前有什么不一样。先自我剖析一下，如果我不自剖，我相信你也不会的。如果我自剖了，我相信你也不会的。（毕竟大家都只有这么喜欢思考） 声明：我是不会读书的看到这里你完全可以点击返回键退出，不继续看下去。毕竟现在是成功学泛滥的时代，谁会听一个不会读书的人谈读书呢？还不如自己自己多撸两把。 ①、注意力十分的不集中可以这样说，我的大脑在一般的状态下是停不下来的，看书一个小时很可能有半个小时都在走神或者想其他的事情。原因我分析过，人性的法则里面，幻想（是幻想不是思考）是情绪和潜意识的需要，潜意识不会接受现实生活中发生的一些事情，它总是幻想一些场景满足大脑的需求或焦虑，满足情绪的需求。比如说你的写作水平不怎么样，你就可能幻想在某个写作比赛获奖的时候的慷慨陈词；如果你看小说或者打游戏，你就可能幻想你就是小说中的某个人物（风流潇洒、玉树临风、沉鱼落雁…省略1000字）或者在某一次游戏里面怎样怎样怎样；又或者幻想自己未来的男女朋友、公公婆婆等等对未来的期待和焦虑。因为潜意识不接受现实，大脑看似接受了现实但是大脑并未得到满足，所以只有幻想才会满足这种需求，所以大脑对幻想上瘾。潜藏于人性的枷锁，或许只有智者会发现并超越吧。 ②、不怀疑书中的观点我看过的书，基本都没有怀疑过书中的观点。最开始接触成功学的时候就连成功学的观点(比如陈安之的书里面的：成功是可以复制、潜意识幻想改变现实这些观点)都没有怀疑过，什么都相信，最后发现这所谓的相信只是一个大脑的阴谋，也是大脑的特点，我们的大脑总是很懒惰，能不思考的就尽量不思考。思考要花时间和精力嘛，你的大脑可你比机灵多了。但是相信是没有必要的，正如你不必要相信我的这篇文章里面的观点。如果你相信了，恭喜你，又被你的大脑欺骗了（为什么这样说？看下一段）。几乎所有人都是会被大脑欺骗的。我也是，所以我一直都觉得我是一个比较愚笨的人。而且具有严重的大脑依赖症。 ③、理解书中的内容是我的渴望上面那句话只是一个比较委婉一点的措辞，翻译成大白话就是：我理解能力比较差。在人的认知里面，对某一事物的认知总是需要一个认知模型来理解这个世界的，尽管这个认知模型有可能是错的，但是人总是需要这么一个东西来理解，不然它就无法理解。举个简单的例子：古代的人不理解天气的不同是由什么原因造成的，于是就有了认为天气的好坏是有神灵（雷公、电母、龙王等）控制的这个认知模型，没有这个模型人们是无法理解天气形成的原因的。但是现在这个认知模型在我们眼中很可笑，因为我们有了科学技术，知道了天气形成的原因是纬度位置、大气环流、海陆分布、洋流和地形等等。我的理解能力比较差，因为我一般找不到类似的东西（认知模型）去理解书中的内容（这也有可能是没有怎么动手实践的原因吧）。好了，说了这么多，可以得出结论，Grantsome（我的英文名）果然不会读书。是的，我接受这个结论，我不会读书。会不会读书不重要，重要的是，我终于要讲到文章的主题了: 以不相信一切的态度接受一切。 以不相信一切的态度接受一切这或许是我在大学里面学到的最重要的两句话了吧：不相信一切。接受一切。不理解吗？没关系，慢慢来，你会慢慢理解的。即使你理解了。相信我。你也做不到的。（我说你相信我你就要相信我？）首先举一个简单的例子：大家都有手机吧，大部分手机的系统是iOS和Android。我们以Android手机为例，很多人离不开手机，沉迷于各种APP无法自拔。而各种APP不管是炫酷的界面，还是人性化的功能。它的本质是什么？Android手机里面的APP本质不过是一堆代码而已。只不过不同的Android版本的系统会有一些不同而已。而这一堆代码就好像你的基因，里面蕴藏的信息随着时间和环境得到表达之后，这便形成了你的生活，就像手机里面的APP各种丰富的界面和功能。按下手机上面的电源键，手机变休眠了，就像你睡着了一样。一切依然发生，只是你不知道发生了什么而已。所以你的生活是真实的吗？接受一切，说道这个不得不说道佛教或者其他宗教，为什么那些宗教徒每天获得乐呵呵的，其中的一个原因就是：他们认为这一切都是佛的安排。或者说一些都是上帝/神灵的安排，他们作为信徒接受这一切。体会到其中的智慧了吗？对，接受一切。但是这不仅仅只是一句话而已，其中的道理，自己可以去摸索。为什么说不相信一切。世界本身就是一场阴谋，理性的观察者，才能觉察到这一切。不过要劳记无法改变的一点，优胜劣汰，弱肉强食。这些是无法改变的现实。阴谋，小到被别人算计，被公式社会组织利用，被社会国家组织(共产党)包裹。大到外种族的入侵等无不身处各种阴谋。我们不可能知道别人的真正目的是什么，正如你，知道我写这篇文章的真正目的是什么？你知道吗？没有阴谋？我为什么要告诉你？所以你应该相信你读过的书吗？你应该相信这个世界吗？送你们一张图仔细体会一下这一张图所要表达的东西。随时间流逝的木板，背后的真相之路，直见曙光。人一生或许都无法察觉，直至，坠落，消逝。和其他动物一样，不过是无尽黑暗的食物链和能量链上面的一环，存在之后默默消散。就像不存在之前一样。平淡，陨落。做一个彻底面对真实的行者吧，在静谧中从中体会平稳意识后的那一份观察。千载悠悠一瞬而过，多数的存在，注定只是永恒的过客，又或许每一刻的当下即是永恒。只有能摆脱一切所谓的形式，彻底面对未知的行者，也许方才有一丝可能。或许文字里面存在着一种微弱的自由意志，代表着从物质世界中觉醒的渴望。世界从来没有给过生命使命，一切根据自然规则运行发展，世界不会关心某个人的生死，就像这个世界不关心一只蚂蚁的生死，无论是经历或者其他。这一点上我们的生命是毫无意义的，当你明白了这一点，你才有可能去明白自身的意义以及进化赋予生命的无限可能。你在期待什么？又幻想了什么？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ImageLoader的简单实现]]></title>
      <url>%2F2017%2F04%2F10%2FImageLoader%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[加载图片在Android开发过程中经常会用到，当加载的图片的数量不是很多的时候还好，但是如果图片数量一旦很多的话，就很有可能出现OOM异常和卡顿的现象。当然，这个是不能忍的，所以我们必须要想办法解决它。如何解决呢？我们知道，现在GitHub上面的开源库还是不少的，比如Universal-ImageLoader、Glide、Picasso等，这里不是要教你如何使用这些开源库，而是用我们自己的思维做一个类似的ImageLoader。首先我们来看一个简单的ImageLoader,这个ImageLoader是我自己写的，思路很简单，也比较好用，因为太复杂了我也写不出来(苦笑)。我们来一个方法一个方法的写，这样思路会更清晰，容易梳理自己的思维。 1、我自己的ImageLoader先写一个网络请求123456789101112131415161718192021#### 1、loadFileFromHttp(URL mURL)private void loadFileFromHttp(URL mURL)&#123; Bitmap mBitmap = null; try &#123; HttpURLConnection mHttpConnection = (HttpURLConnection) mURL.openConnection(); mHttpConnection.setConnectTimeout(5000); mHttpConnection.setUseCaches(true); mHttpConnection.setDoInput(true); InputStream mInputStream = mHttpConnection.getInputStream(); final BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = 3; mBitmap = BitmapFactory.decodeStream(mInputStream,null,options); handler.sendMessage(handler.obtainMessage(666,mBitmap)); saveFile(mBitmap,mURL.toString()); if(mInputStream!=null) &#123; mInputStream.close(); &#125; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; 这个网络请求方法得到了bitmap并把bitmap保存下来了,并且调用了handler.sendMessage()。这个不是有一个saveFile()方法吗？它的具体内容如下: 2、saveFile(Bitmap bm, String fileName)1234567891011protected void saveFile(Bitmap bm, String fileName) throws IOException &#123; File myCaptureFile = new File(sContext.getExternalCacheDir() + fileName); myCaptureFile.getParentFile().mkdirs(); myCaptureFile.createNewFile(); Log.d("ImageLoader","save里面的path"+myCaptureFile.getPath()); FileOutputStream out; out = new FileOutputStream(myCaptureFile); bm.compress(Bitmap.CompressFormat.JPEG, 100, out); out.flush(); out.close(); &#125; 既然写了保存的方法,那么肯定要判断本地里面是否含有这个已经保存的文件，有的话就不用网络请求浪费流量而且还花时间了。 3、isSaveFile()12345678private boolean isSaveFile() throws Exception&#123; File myCaptureFile = new File(sContext.getExternalCacheDir() + url); if(myCaptureFile.exists())&#123; return true; &#125;else &#123; return false; &#125; &#125; 4、getBitmapFile(String uri)如果已经保存直接从本地获取该文件12345678910111213public void getBitmapFile(String uri) throws Exception&#123; File dirFile = new File(sContext.getExternalCacheDir()+uri); if(dirFile.exists())&#123; final BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = 3; Bitmap mBitmap = BitmapFactory.decodeFile(dirFile.toString(),options); Log.d("ImageLoader","get里面的path"+dirFile.toString()); handler.sendMessage(handler.obtainMessage(555,mBitmap)); &#125; if(!dirFile.exists())&#123; Log.d("ImageLoader","get里面的path不存在"); &#125; &#125; 5、getHttpBitmap(final String mUri)当然，这些操作都是在一个新开的线程里面执行的1234567891011121314151617181920212223private void getHttpBitmap(final String mUri)&#123; new Thread(new Runnable() &#123; URL mURL = null; @Override public void run() &#123; try&#123; if(!isSaveFile())&#123; mURL = new URL(mUri); loadFileFromHttp(mURL); &#125;else if(isSaveFile())&#123; getBitmapFile(mUri); Log.d("ImageLoader","已经执行getBitmap方法"); &#125; &#125;catch (Exception e)&#123; handler.sendMessage(handler.obtainMessage(444,"网络连接失败")); e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; 在主线程里面更新UI 6、handleMessage()123456789101112131415161718192021Handler handler = new Handler()&#123; @Override public void handleMessage(android.os.Message msg) &#123; switch (msg.what)&#123; case 666: Bitmap bitmap = (Bitmap) msg.obj; imageView.setImageBitmap(bitmap); break; case 555: Bitmap mBitmap = (Bitmap) msg.obj; imageView.setImageBitmap(mBitmap); break; case 444: //Toast.makeText(sContext, (String) msg.obj, Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125; &#125;; 7、ImageLoader.get()单例构造方法和构造器123456789101112131415161718192021222324private String url;private ImageView imageView;private static ImageLoader sImageLoader;private static Context sContext;public static ImageLoader get(Context context, String mUri, ImageView mImageView)&#123; sImageLoader = new ImageLoader(mUri,mImageView); sContext = context; return sImageLoader;&#125;private ImageLoader(String mUri,ImageView mIageView)&#123; this.url = mUri; imageView = mIageView; try&#123; getHttpBitmap(url); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;&#125; 好了,这个图片加载器的主要方法就已经说的很清楚了，我们来看完整代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package com.grantsome.imageloader;import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Handler;import android.util.Log;import android.widget.ImageView;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.Serializable;import java.net.HttpURLConnection;import java.net.URL;/** * Created by tom on 2017/3/21. */public class ImageLoader implements Serializable &#123; private String url; private ImageView imageView; private static ImageLoader sImageLoader; private static Context sContext; public static ImageLoader get(Context context, String mUri, ImageView mImageView)&#123; Log.d("ImageLoader","geHttpBitmap执行在ImageLoader初始化"); sImageLoader = new ImageLoader(mUri,mImageView); sContext = context; return sImageLoader; &#125; private ImageLoader(String mUri,ImageView mIageView)&#123; this.url = mUri; imageView = mIageView; try&#123; getHttpBitmap(url); Log.d("ImageLoader","geHttpBitmap执行在ImageLoader里面"); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; Handler handler = new Handler()&#123; @Override public void handleMessage(android.os.Message msg) &#123; switch (msg.what)&#123; case 666: Bitmap bitmap = (Bitmap) msg.obj; imageView.setImageBitmap(bitmap); break; case 555: Bitmap mBitmap = (Bitmap) msg.obj; imageView.setImageBitmap(mBitmap); break; case 444: //Toast.makeText(sContext, (String) msg.obj, Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125; &#125;; private void getHttpBitmap(final String mUri)&#123; new Thread(new Runnable() &#123; URL mURL = null; @Override public void run() &#123; try&#123; if(!isSaveFile())&#123; mURL = new URL(mUri); loadFileFromHttp(mURL); &#125;else if(isSaveFile())&#123; getBitmapFile(mUri); Log.d("ImageLoader","已经执行getBitmap方法"); &#125; &#125;catch (Exception e)&#123; handler.sendMessage(handler.obtainMessage(444,"网络连接失败")); e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void loadFileFromHttp(URL mURL)&#123; Bitmap mBitmap = null; try &#123; HttpURLConnection mHttpConnection = (HttpURLConnection) mURL.openConnection(); mHttpConnection.setConnectTimeout(5000); mHttpConnection.setUseCaches(true); mHttpConnection.setDoInput(true); InputStream mInputStream = mHttpConnection.getInputStream(); final BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = 3; mBitmap = BitmapFactory.decodeStream(mInputStream,null,options); handler.sendMessage(handler.obtainMessage(666,mBitmap)); saveFile(mBitmap,mURL.toString()); Log.d("ImageLoader","已经执行saveBitmap方法"); if(mInputStream!=null) &#123; mInputStream.close(); &#125; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; private boolean isSaveFile() throws Exception&#123; File myCaptureFile = new File(sContext.getExternalCacheDir() + url); if(myCaptureFile.exists())&#123; return true; &#125;else &#123; return false; &#125; &#125; protected void saveFile(Bitmap bm, String fileName) throws IOException &#123; File myCaptureFile = new File(sContext.getExternalCacheDir() + fileName); myCaptureFile.getParentFile().mkdirs(); myCaptureFile.createNewFile(); Log.d("ImageLoader","save里面的path"+myCaptureFile.getPath()); FileOutputStream out; out = new FileOutputStream(myCaptureFile); bm.compress(Bitmap.CompressFormat.JPEG, 100, out); out.flush(); out.close(); &#125; public void getBitmapFile(String uri) throws Exception&#123; File dirFile = new File(sContext.getExternalCacheDir()+uri); if(dirFile.exists())&#123; final BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = 3; Bitmap mBitmap = BitmapFactory.decodeFile(dirFile.toString(),options); Log.d("ImageLoader","get里面的path"+dirFile.toString()); handler.sendMessage(handler.obtainMessage(555,mBitmap)); &#125; if(!dirFile.exists())&#123; Log.d("ImageLoader","get里面的path不存在"); &#125; &#125;&#125; 到这里，我的ImageLoader就已经结束了，不过还是要贴一下我的GitHub地址:https://github.com/Grantsome/ImageLoader 2、Simonla(我的导师)的PhotoLoader来，我们一起来欣赏一下大神的代码(对比之下就能看出来我有多弱了)。首先，定义一个接口： 1、interface DrawableCallbackListener123456789/*** 回调接口*/ public interface DrawableCallbackListener &#123; void onBitmapFinish(Bitmap response); void onError(Exception e); &#125; 还是把声明的一些东西简要的粘贴一下。 2、常量声明123456789private static boolean sIsFailTouchToReload = false; public static final String LOADING = "loading"; public static final String FAIL = "fail"; private static Context sContext; private static int sResLoad; private static int sResFail; private static int sCompressionRatio = 100; private static int sResamplingRate = 1; private static LruCache&lt;String, Bitmap&gt; mMemoryCache; 3、getHttpBitmap(final String address, final ImageView iv, final DrawableCallbackListener listener)判断缓存并网络请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*** * 缓存判断。以及网络取得 * * @param address 网址 * @param iv ImageView * @param listener 回调方法 */ private static void getHttpBitmap(final String address, final ImageView iv, final DrawableCallbackListener listener) &#123; //网址为空的时候调用 有主线程的Looper的handler.setFail(); if (address == null) &#123; new Handler(Looper.getMainLooper()).post(new Runnable() &#123; @Override public void run() &#123; setFail(iv); &#125; &#125;); &#125; else &#123; //如果LruCache缓存(这里是mMemoryCache)不为空并且listener已经实例化，就直接从调用接口类的onBitmapFinsh()方法 //如果LruCache缓存为空,就去本地SD卡里面找,如果有就先Put到LruCache(这里是mMemoryCache),然后直接从调用接口类的onBitmapFinsh()方法。 //如果LruCache缓存为空,并且本地SD卡也没有,那就只有先调用主线程的setLoading()方法,然后再进行网络请求,并保存到本地，而且Put到LruCache。 final int hashName = address.hashCode(); Bitmap inCache = mMemoryCache.get(hashName + ""); if (inCache != null) &#123; if (listener != null) &#123; listener.onBitmapFinish(inCache); &#125; &#125; else &#123; Bitmap inSD = getBitmapFromNative(hashName); if (inSD != null) &#123; if (listener != null) &#123; mMemoryCache.put(hashName + "", inSD); listener.onBitmapFinish(inSD); &#125; &#125; else &#123; new Handler(Looper.getMainLooper()).post(new Runnable() &#123; @Override public void run() &#123; setLoading(iv); &#125; &#125;); HttpURLConnection connection = null; try &#123; URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.setUseCaches(true); connection.setConnectTimeout(10000); connection.setReadTimeout(10000); InputStream in = connection.getInputStream(); final BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = sResamplingRate; Bitmap response = BitmapFactory.decodeStream(in, null, options); in.close(); saveFile(hashName, response); if (listener != null) &#123; mMemoryCache.put(hashName + "", response); listener.onBitmapFinish(response); &#125; &#125; catch (Exception e) &#123; if (listener != null) &#123; listener.onError(e); &#125; &#125; finally &#123; if (connection != null) &#123; connection.disconnect(); &#125; &#125; &#125; &#125; &#125; &#125; 这个方法稍微复杂了那么一点点，不过应该也解释清楚了吧？看下一个方法 4、saveFile(int name, Bitmap bitmap)12345678910111213141516171819202122232425262728293031323334/*** * 保存到SD卡 * * @param name 文件名字 * @param bitmap bitmap */ private static void saveFile(int name, Bitmap bitmap) &#123; FileOutputStream outputStream = null; ByteArrayOutputStream out = new ByteArrayOutputStream(); if (bitmap != null) &#123; bitmap.compress(Bitmap.CompressFormat.JPEG, sCompressionRatio, out); &#125; byte[] result = out.toByteArray(); try &#123; out.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; //写入数据，第一个参数是文件名,不存在就创建，保存在/data/data/&lt;package name&gt;/files/目录中，第二个参数是写入方式(这里是每次写入覆盖原文件) outputStream = sContext.openFileOutput(String.valueOf(name), Context.MODE_PRIVATE); outputStream.write(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (outputStream != null) &#123; outputStream.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 5、getBitmapFromNative(int name)从本地获取bitmap1234567891011121314151617181920212223/*** * 从本地取得图片 * * @param name 文件名 * @return bitmap */ @Nullable private static Bitmap getBitmapFromNative(int name) &#123; FileInputStream in = null; try &#123; in = sContext.openFileInput(String.valueOf(name)); return BitmapFactory.decodeStream(in); &#125; catch (Exception ignored) &#123; &#125; try &#123; if (in != null) &#123; in.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; 6、initLruCache()这个方法不需要解释,初始化Lru。123456789101112131415/** * 初始化LRU */private static void initLruCache() &#123; //运行时最大的缓存的兆数 int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); int cacheSize = maxMemory / 8; mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getRowBytes() * value.getHeight() / 1024; &#125; &#125;; setDefaultLRU();&#125; 7、reLoad(final ImageView iv, final String url)加载失败后重新加载12345678910111213141516171819202122232425262728293031323334353637/** * 失败后的重新加载 * * @param iv ImageView * @param url 网址 */ private static void reLoad(final ImageView iv, final String url) &#123; new Handler(Looper.getMainLooper()).post(new Runnable() &#123; @Override public void run() &#123; setFail(iv); &#125; &#125;); iv.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; new Handler(Looper.getMainLooper()).post(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(sContext, "重新加载中", Toast.LENGTH_SHORT).show(); loadAgain(); &#125; private void loadAgain() &#123; if (sIsFailTouchToReload) &#123; iv.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; open(url, iv); &#125; &#125;); &#125; &#125; &#125;); &#125; &#125;); &#125; 这里有个open()方法没有写，所以我们马上就要看看这个方法了。 8、open(final String url, final ImageView iv, final DrawableCallbackListener listener)/* * 有回调的打开 * * @param url 网址 * @param iv ImageView * @param listener 回调接口 */ public static void open(final String url, final ImageView iv, final DrawableCallbackListener listener) { new Thread(new Runnable() { @Override public void run() { getHttpBitmap(url, iv, new DrawableCallbackListener() { //获取成功就调用这个方法 @Override public void onBitmapFinish(final Bitmap response) { //主线程里面更新UI new Handler(Looper.getMainLooper()).post(new Runnable() { @Override public void run() { // 如果tag对应上了 if (iv.getTag() == url) { iv.setImageBitmap(response); // 让外面也可以自己添加额外的操作 if (listener != null) listener.onBitmapFinish(response); } } }); } //获取失败重新加载 @Override public void onError(final Exception e) { e.printStackTrace(); reLoad(iv, url); } } ); } }).start(); } 1好了，主要的方法就解释到这里了，我们看一下完整的代码。 package com.grantsome.imageloader; import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Handler;import android.os.Looper;import android.support.annotation.Nullable;import android.util.LruCache;import android.view.View;import android.widget.ImageView;import android.widget.Toast; import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL; /** Created by Simonla on 2016/3/28.*/ public class PhotoLoader { private static boolean sIsFailTouchToReload = false; public static final String LOADING = &quot;loading&quot;; public static final String FAIL = &quot;fail&quot;; private static Context sContext; private static int sResLoad; private static int sResFail; private static int sCompressionRatio = 100; private static int sResamplingRate = 1; private static LruCache&lt;String, Bitmap&gt; mMemoryCache; /*** * 设置采样率。默认为1，不压缩。如果数字不是2的指数，那么会向下取小 * * @param resamplingRate 采样率 */ public static void setResamplingRate(int resamplingRate) { sResamplingRate = resamplingRate; } /*** * 设置加载失败是否重新加载。默认为否 * * @param isFailTouchToReload 是否重新加载 */ public static void setIsFailTouchToReload(boolean isFailTouchToReload) { sIsFailTouchToReload = isFailTouchToReload; } /*** * 方便的得到上下文 * * @return Context */ public static Context getContext() { return sContext; } /*** * 初始化 * * @param context 上下文 */ public static void init(Context context) { sContext = context; initLruCache(); } /*** * 必选项，设置默认加载 * * @param res 资源ID */ public static void setLoadDefault(int res) { sResLoad = res; } /*** * 必选项，设置默认失败图 * * @param res 资源ID */ public static void setFailDefault(int res) { sResFail = res; } /** * 设置压缩率，0-100，默认100 * * @param compressionRatio 压缩率 */ public static void setCompressionRatio(int compressionRatio) { sCompressionRatio = compressionRatio; } /*** * 没有回调的打开 * * @param url 网址 * @param iv ImageView */ public static void open(String url, ImageView iv) { open(url, iv, null); } /*** * 有回调的打开 * * @param url 网址 * @param iv ImageView * @param listener 回调接口 */ public static void open(final String url, final ImageView iv, final DrawableCallbackListener listener) { new Thread(new Runnable() { @Override public void run() { getHttpBitmap(url, iv, new DrawableCallbackListener() { @Override public void onBitmapFinish(final Bitmap response) { new Handler(Looper.getMainLooper()).post(new Runnable() { @Override public void run() { // 如果tag对应上了 if (iv.getTag() == url) { iv.setImageBitmap(response); // 让外面也可以自己添加额外的操作 if (listener != null) listener.onBitmapFinish(response); } } }); } @Override public void onError(final Exception e) { e.printStackTrace(); reLoad(iv, url); } } ); } }).start(); } /*** * 缓存判断。以及网络取得 * * @param address 网址 * @param iv ImageView * @param listener 回调方法 */ private static void getHttpBitmap(final String address, final ImageView iv, final DrawableCallbackListener listener) { if (address == null) { new Handler(Looper.getMainLooper()).post(new Runnable() { @Override public void run() { setFail(iv); } }); } else { final int hashName = address.hashCode(); Bitmap inCache = mMemoryCache.get(hashName + &quot;&quot;); if (inCache != null) { if (listener != null) { listener.onBitmapFinish(inCache); } } else { Bitmap inSD = getBitmapFromNative(hashName); if (inSD != null) { if (listener != null) { mMemoryCache.put(hashName + &quot;&quot;, inSD); listener.onBitmapFinish(inSD); } } else { new Handler(Looper.getMainLooper()).post(new Runnable() { @Override public void run() { setLoading(iv); } }); HttpURLConnection connection = null; try { URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(&quot;GET&quot;); connection.setUseCaches(true); connection.setConnectTimeout(10000); connection.setReadTimeout(10000); InputStream in = connection.getInputStream(); final BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = sResamplingRate; Bitmap response = BitmapFactory.decodeStream(in, null, options); in.close(); saveFile(hashName, response); if (listener != null) { mMemoryCache.put(hashName + &quot;&quot;, response); listener.onBitmapFinish(response); } } catch (Exception e) { if (listener != null) { listener.onError(e); } } finally { if (connection != null) { connection.disconnect(); } } } } } } /*** * 初始化LRU */ private static void initLruCache() { int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); int cacheSize = maxMemory / 8; mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) { @Override protected int sizeOf(String key, Bitmap value) { return value.getRowBytes() * value.getHeight() / 1024; } }; setDefaultLRU(); } /** * 设置默认图 * * @param iv ImageView */ private static void setLoading(ImageView iv) { if (mMemoryCache.get(LOADING) != null) { iv.setImageBitmap(mMemoryCache.get(LOADING)); } else { iv.setImageResource(sResLoad); } } /** * 设置默认图 * * @param iv ImageView */ private static void setFail(ImageView iv) { if (mMemoryCache.get(FAIL) != null) { iv.setImageBitmap(mMemoryCache.get(FAIL)); } else { iv.setImageResource(sResFail); } } /*** * 设置默认图进到LRU */ private static void setDefaultLRU() { if (sResFail != 0 &amp;&amp; sResLoad != 0) { Bitmap loading = BitmapFactory.decodeResource(sContext.getResources(), sResLoad); Bitmap fail = BitmapFactory.decodeResource(sContext.getResources(), sResFail); mMemoryCache.put(LOADING, loading); mMemoryCache.put(FAIL, fail); } } /*** * 保存到SD卡 * * @param name 文件名字 * @param bitmap bitmap */ private static void saveFile(int name, Bitmap bitmap) { FileOutputStream outputStream = null; ByteArrayOutputStream out = new ByteArrayOutputStream(); if (bitmap != null) { bitmap.compress(Bitmap.CompressFormat.JPEG, sCompressionRatio, out); } byte[] result = out.toByteArray(); try { out.close(); } catch (Exception e) { e.printStackTrace(); } try { outputStream = sContext.openFileOutput(String.valueOf(name), Context.MODE_PRIVATE); outputStream.write(result); } catch (Exception e) { e.printStackTrace(); } finally { try { if (outputStream != null) { outputStream.close(); } } catch (Exception e) { e.printStackTrace(); } } } /*** * 从本地取得图片 * * @param name 文件名 * @return bitmap */ @Nullable private static Bitmap getBitmapFromNative(int name) { FileInputStream in = null; try { in = sContext.openFileInput(String.valueOf(name)); return BitmapFactory.decodeStream(in); } catch (Exception ignored) { } try { if (in != null) { in.close(); } } catch (Exception e) { e.printStackTrace(); } return null; } /** * 失败后的重新加载 * * @param iv ImageView * @param url 网址 */ private static void reLoad(final ImageView iv, final String url) { new Handler(Looper.getMainLooper()).post(new Runnable() { @Override public void run() { setFail(iv); } }); iv.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Handler(Looper.getMainLooper()).post(new Runnable() { @Override public void run() { Toast.makeText(sContext, &quot;重新加载中&quot;, Toast.LENGTH_SHORT).show(); loadAgain(); } private void loadAgain() { if (sIsFailTouchToReload) { iv.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { open(url, iv); } }); } } }); } }); } /** * 回调接口 */ public interface DrawableCallbackListener { void onBitmapFinish(Bitmap response); void onError(Exception e); } }``` 3、《Android开发艺术探索》里面的ImageLoader高级工程师写的东西,总是很有逼格。这个也不例外,虽然感觉思路不是很难理解。但是函数多了,调用过来调用过去很容易让人犯迷糊,不过不要着急,慢慢消化,把别人的东西变成自己的东西,写代码就是这样子,感觉上也不是很难,但是自己就是写不出来。电脑太卡了,AS已经崩溃，晚上还有课,下次再写。 4、GitHub上面的Android-Universal-Image-Loader这个可是大佬级别的代码,让我们去仰慕一下,仰慕的同时学点东西,看看人家是怎样构建自己的代码的, 记得代码家曾经有一篇文章就写到说少看别人的文字描述,多看别人的代码，这样才有利于提高。不要害怕看别人很复杂的代码,慢慢梳理自己的思路,有时候记得画个思维导图什么的,有助于自己理解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AsyncTask和HandlerThread完全解析--入门级]]></title>
      <url>%2F2017%2F04%2F09%2FAsyncTask%E5%92%8CHandlerThread%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90-%E5%85%A5%E9%97%A8%E7%BA%A7%2F</url>
      <content type="text"><![CDATA[本来打算每周写一篇博客的，但是上一周没有写，原因很简单：放清明三天去玩了，缓了好几天回过神来。所以这一周打算写两篇，就当做是自己对自己的一个交代吧。话不多说，进入正题。AsyncTask，翻译过来的字面意思是异步任务,我们习惯上说异步操作(换句话说，也就是在主线程中新开线程进行的操作)。简单比喻：假设你饿了，你肯定会去饭店地方吃东西，但是饭店为你准备食物需要一定的时间，所以你饿了必须要到了饭店等一会儿才能吃饭，这就是异步操作，你不能马上做下一件事情，因为它需要当前事情完成之后才能做下一件事情。至于为什么需要异步操作，Android主线程里面不能进行耗时操作，也就是只能在子线程里进行耗时操作比如网络请求，并且只能在主线程里面更新UI。简单例子，从网上加载图片数据并显示图片，现在你要通过网络请求获取一段数据给你，其中有图片的url，得到url转化成bitmap或者drawable，然后在回到主线程里面给imageview设置图片。 现在我们来看看AsyncTask，它就是一个封装过的抽象的后台任务类，一个使用后台线程的工具类，使用的时候直接继承AsyncTask类就行了 1、参数AsyncTask里面有三个泛型参数，分别表示：Params: 启动任务时执行的输入参数Progress: 任务执行的进度Result: 返回执行的结果当不需要设置这三个参数的时候，设置Void类型，表示没有。 2、重写的方法(1)、必须要重写的方法123protected Result doInBackground(Params...param)&#123; /* your code here*/&#125; 在这个方法里面执行需要耗时的操作（一般执行网络请求等操作），它的参数是一个Params类型的数组，返回一个Result类型的结果。这个方法里面也可以调用publish Progress(Progress … values)用于执行网络请求的时候更新进度。 (2)、不用重写(但会自动调用的方法)123protected void onPostExecute(Result result)&#123; /*your code here*/&#125; 这个方法在doInBackground()方法完成之后被执行的，根据doIBackground的返回结果进行后面的更新UI的操作,所以该方法是在主线程里面工作的。 123protected void onPreExecute()&#123; /*your code here*/&#125; 当调用AsyncTask.excute();方法之后,第一个执行的方法就是这个方法。执行在主线程中。 用于初始化一些UI控件。 123protected void onProgressUpdate(Progress ... values)&#123; /*your code here*/&#125; 如果在doInBackground()方法里面执行了publishProgress()方法，那么这个方法就会得到执行, 根据进度调整对应value的值，也是在主线程中执行的。 当然，如果你英语够好，可以去官方文档https://developer.android.com/reference/android/os/AsyncTask.html 好了，有了这个介绍，我们下面来看一个简单的例子。12345678910private class FetchItemsTask extends AsyncTask&lt;Void,Void,Void&gt;&#123; @Override protected Void doInBackground(Void... params) &#123; //网络请求 new HttpUtil().fetchItems(); return null; &#125;&#125; 这个是工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.grantsome.photogallery;import android.content.Context;import android.net.ConnectivityManager;import android.net.NetworkInfo;import android.net.Uri;import android.util.Log;import org.json.JSONArray;import org.json.JSONObject;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL;import java.security.KeyManagementException;import java.security.NoSuchAlgorithmException;import java.util.ArrayList;import java.util.List;import javax.net.ssl.HttpsURLConnection;/** * Created by tom on 2017/4/8. */public class HttpUtil &#123; public static final String TAG = "HttpUtil"; public static final String API_KEY = "89b13c41adafc85b80edbadc4a655b60"; public byte[] getUrlBytes(String urlSpec) throws IOException, NoSuchAlgorithmException, KeyManagementException &#123; URL url = new URL(urlSpec); HttpsURLConnection connection = (HttpsURLConnection)url.openConnection(); try &#123; ByteArrayOutputStream out = new ByteArrayOutputStream(); InputStream in = connection.getInputStream(); if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) &#123; throw new IOException(connection.getResponseMessage() +": with " +urlSpec); &#125; int bytesRead = 0; byte[] buffer = new byte[1024]; while ((bytesRead = in.read(buffer)) &gt; 0) &#123; out.write(buffer, 0, bytesRead); &#125; out.close(); return out.toByteArray(); &#125; finally &#123; connection.disconnect(); &#125; &#125; public String getUrlString(String urlSpec) throws IOException, KeyManagementException, NoSuchAlgorithmException &#123; return new String(getUrlBytes(urlSpec)); &#125; public void fetchItems()&#123; List&lt;GalleryItem&gt; galleryItemList = new ArrayList&lt;&gt;(); try &#123; String url = Uri.parse("https://api.flickr.com/services/rest/").buildUpon().appendQueryParameter("method", "flickr.photos.getRecent").appendQueryParameter("api_key", API_KEY).appendQueryParameter("format", "json").appendQueryParameter("nojsoncallback", "1").appendQueryParameter("extras", "url_s").build().toString(); Log.i(TAG, "HttpUrl: " + url); String jsonString = getUrlString(url); PreUtil.putStringToDefault(AppContext.getInstance(), TAG, jsonString); Log.i(TAG, "Receive Json From Internet " + jsonString); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; 这里例子很简单吧？得到的json:12345678910111213141516171819202122&#123;"photos": &#123; "page":1,"pages":10,"perpage":100,"total":1000,"photo": [ &#123; "id":"33079594864","owner":"135557505@N08","secret":"4aa208ddb9","server":"3841","farm":4,"title":"upload","ispublic":1,"isfriend":0,"isfamily":0,"url_s":"https:\/\/farm4.staticflickr.com\/3841\/33079594864_4aa208ddb9_m.jpg","height_s":"240","width_s":"194" &#125;, &#123; "id":"33079595044","owner":"33255825@N07","secret":"e7cc46dc7c","server":"2902","farm":3,"title":"2017-04-09_09-54-25","ispublic":1,"isfriend":0,"isfamily":0,"url_s":"https:\/\/farm3.staticflickr.com\/2902\/33079595044_e7cc46dc7c_m.jpg","height_s":"240","width_s":"240" &#125;, &#123; "id":"33079596844","owner":"153628499@N08","secret":"c51b00fcfb","server":"679","farm":1,"title":"Dako Island, Siargao #throwback #summerfeels #sheenamariephotography","ispublic":1,"isfriend":0,"isfamily":0,"url_s":"https:\/\/farm1.staticflickr.com\/679\/33079596844_c51b00fcfb_m.jpg","height_s":"240","width_s":"240" &#125;, &#123; "id":"33079598224","owner":"142581045@N07","secret":"94ed8ea590","server":"581","farm":1,"title":"B.M.W Entertainment presents Urban Spalsh 6 Music Fest to kick off the Summer Splash Pool Series at BLK Live in Scottsdale AZ is going to be an insane summer. Artist and celebrity host every week for the sexiest day party in the state. better reserve","ispublic":1,"isfriend":0,"isfamily":0,"url_s":"https:\/\/farm1.staticflickr.com\/581\/33079598224_94ed8ea590_m.jpg","height_s":"240","width_s":"240" &#125;, &#123;"id":"33079598584","owner":"75860432@N02","secret":"59211f9a1a","server":"3943","farm":4,"title":"Cr\u00e9met d'Anjou","ispublic":1,"isfriend":0,"isfamily":0,"url_s":"https:\/\/farm4.staticflickr.com\/3943\/33079598584_59211f9a1a_m.jpg","height_s":"180","width_s":"240" &#125; ]&#125;, "stat":"ok"&#125; 没有写完json。这个不重要。没关系。简单理解一下它的用法就可以了。 下面再来看一个比较全面一点的例子12345678910111213private class FetchItemsTask extends AsyncTask&lt;Void,Void,List&lt;GalleryItem&gt;&gt;&#123; @Override protected List&lt;GalleryItem&gt; doInBackground(Void... params) &#123; return new HttpUtil().fetchItems(); &#125; @Override protected void onPostExecute(List&lt;GalleryItem&gt; items)&#123; mItems = items; setupAdapter(); &#125; &#125; 说完了AysncTask我们再来讨论一下它的优缺点，这个抽象的工具类虽然好用，但是它也只是一种轻量级的工具而已，只适合只有几秒的短时间的异步操作而已，并且有可能导致内存泄漏的问题。我们当然要要去寻找其他的替代的东西以写出更好的程序。 这时候Looper、Handler、HandlerThread就闪亮登场了。Message:汉语翻译过来是消息的意思，顾名思义，就是在线程之间传递的消息，可以携带message.what的int类型,也可以携带一个object类型的obj.Handler:处理者,主要用于发送和处理消息，发送是handler.sendMessage()，最终传递到handler.handlerMessage();说简单一点就是异步更新UI，并且更新UI的时候，是主线程与子线程之间的通信。这里讲的最清楚不过了https://developer.android.com/reference/android/os/Handler.htmlMessageQueue:消息队列，主要用于存放所有通过handler.sendMessage();的所有消息，这部分会一直存储着MessageQueue()里面，等待被处理，每一个线程只会有一个MessageQueue对象。Looper:消息的循环者，也就是MessageQueue的管家,每发现MessageQueue里面有一个message的时候,就会将它取出，并传递给handler.handlerMessage();每一个线程也只会有一个looperHandlerThread:HandlerThread继承与Thread，但是又有不同，唯一的不同之处在于，建立了一个单独的线程以及创立了一个消息队列,有自己单独的looper。前面有说过Handler用于主线程和子线程之间的通信。而假如你现在需要子线程与子线程之间的通信和传递数据呢？我们要在子线程中调用Looper.prepare() 为一个线程开启一个消息循环，默认情况下Android中新诞生的线程是没有开启消息循环的。（主线程除外，主线程系统会自动为其创建Looper对象，开启消息循环。） Looper对象通过MessageQueue来存放消息和事件。一个线程只能有一个Looper，对应一个MessageQueue。 然后通过Looper.loop() 让Looper开始工作，从消息队列里取消息，处理消息。比如这样子 12345678910111213141516Handler mHandler;private void createManualThreadWithHandler() &#123; new Thread() &#123; @Override public void run() &#123; super.run(); //调用Looper.prepare 创建与当前线程绑定的Looper实例 Looper.prepare(); //使用上面创建的Looper生成Handler实例 mHandler = new Handler(Looper.myLooper()); //调用Looper.loop()实现消息循环 Looper.loop(); &#125; &#125;.start();&#125; 如果每次使用都这样写的话 感觉也不是太方便。这时候Google就很贴心的早就为我们封装好了一个类，就是HandlerThread。Google大门常打开，开怀容纳天地：https://developer.android.com/reference/android/os/HandlerThread.html 让我们来看看它最简单的使用1234567891011121314151617private Handler mHandler;private UseHandlerThread() &#123; //创建实例化对象,参数的作用仅仅是一个标记作用。 HandlerThread workerThread = new HandlerThread("LightTaskThread"); //启动线程 workerThread.start(); //创建Handler,时任务投放到该先线程中, //复写Handler的CallBack接口类当中的的handlerMessger,调用getLooper()得到looper对象 mHandler = new Handler(workerThread.getLooper(),new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; //实现自己的消息处理 return true; &#125; &#125;);&#125; 是的,你没看错，就是这么简单。 下面我们来看一个稍微复杂一点点的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.grantsome.photogallery;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Handler;import android.os.HandlerThread;import android.os.Message;import android.util.Log;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;/** * Created by tom on 2017/4/9. */public class ThumbnailDownloader&lt;T&gt; extends HandlerThread &#123; public static final String TAG = "ThumbnailDownloader"; private static int MESSAGE_DOWNLOAD = 0; private Handler mRequestHandler; private Handler mResponseHandler; private ConcurrentMap&lt;T,String&gt; mRequestMap = new ConcurrentHashMap&lt;&gt;(); private boolean mHashQuit = false; private ThumbnailDownloaderListener&lt;T&gt; mThumbnailDownloader; public interface ThumbnailDownloaderListener&lt;T&gt;&#123; void onThumbnailDownloaded(T target,Bitmap thumbnail); &#125; public void setThumbnailDownloadListener(ThumbnailDownloaderListener&lt;T&gt; listener)&#123; mThumbnailDownloader = listener; &#125; public ThumbnailDownloader(Handler responseHandler) &#123; super(TAG); mResponseHandler = responseHandler; &#125; @Override protected void onLooperPrepared()&#123; mRequestHandler = new Handler()&#123; @Override public void handleMessage(Message msg)&#123; if(msg.what == MESSAGE_DOWNLOAD)&#123; T target = (T) msg.obj; Log.i(TAG,"Got a request for URL: " + mRequestMap.get(target)); handleRequest(target); &#125; &#125; &#125;; &#125; private void handleRequest(final T target)&#123; try&#123; final String url = mRequestMap.get(target); if(url==null)&#123; return; &#125; byte[] bitmapBytes = new HttpUtil().getUrlBytes(url); final Bitmap bitmap = BitmapFactory.decodeByteArray(bitmapBytes,0,bitmapBytes.length); Log.i(TAG,"Bitmap created"); mResponseHandler.post(new Runnable() &#123; @Override public void run() &#123; if(mRequestMap.get(target)!=url||mHashQuit)&#123; return; &#125; mRequestMap.remove(target); mThumbnailDownloader.onThumbnailDownloaded(target,bitmap); &#125; &#125;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; @Override public boolean quit()&#123; mHashQuit = true; return super.quit(); &#125; public void queueThumbnail(T target,String url)&#123; Log.i(TAG,"Got a URL " + url); if(url == null)&#123; mRequestMap.remove(target,url); &#125;else &#123; mRequestMap.put(target,url); mRequestHandler.obtainMessage(MESSAGE_DOWNLOAD,target).sendToTarget(); &#125; &#125; public void clearQueue()&#123; mRequestHandler.removeMessages(MESSAGE_DOWNLOAD); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.grantsome.photogallery;import android.graphics.Bitmap;import android.graphics.drawable.BitmapDrawable;import android.graphics.drawable.Drawable;import android.os.AsyncTask;import android.os.Bundle;import android.os.Handler;import android.support.v4.app.Fragment;import android.support.v4.content.ContextCompat;import android.support.v7.widget.GridLayoutManager;import android.support.v7.widget.RecyclerView;import android.util.Log;import android.view.LayoutInflater;port android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import java.util.ArrayList;import java.util.List;public class PhotoGalleryFragment extends Fragment &#123; private ThumbnailDownloader&lt;PhotoHolder&gt; mThumbnailDownloader; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setRetainInstance(true); new FetchItemsTask().execute(); Handler handler = new Handler(); //传入参数以切换到主线程 mThumbnailDownloader = new ThumbnailDownloader&lt;&gt;(handler); //设置ThumbnailDownloadListener mThumbnailDownloader.setThumbnailDownloadListener(new ThumbnailDownloader.ThumbnailDownloaderListener&lt;PhotoHolder&gt;() &#123; @Override public void onThumbnailDownloaded(PhotoHolder target, Bitmap thumbnail) &#123; Drawable drawable = new BitmapDrawable(getResources(),thumbnail); target.bindDrawable(drawable); &#125; &#125;); //执行start mThumbnailDownloader.start(); //执行getLooper mThumbnailDownloader.getLooper(); Log.i(TAG,"Background thread started "); &#125; private class PhotoAdapter extends RecyclerView.Adapter&lt;PhotoHolder&gt;&#123; @Override public void onBindViewHolder(PhotoHolder holder, int position) &#123; GalleryItem galleryItem = mGalleryItemList.get(position); mThumbnailDownloader.queueThumbnail(holder,galleryItem.getUrl()); &#125; @Override public int getItemCount() &#123; return mGalleryItemList.size(); &#125; &#125; @Override public void onDestroy()&#123; super.onDestroy(); mThumbnailDownloader.quit(); Log.i(TAG,"Background thread destroyed"); &#125; @Override public void onDestroyView()&#123; super.onDestroyView(); mThumbnailDownloader.clearQueue(); &#125;&#125; 为此我特地为你准备了一张思维导图，请看 代码没有粘贴完整，有兴趣看源码吧，这里：https://github.com/Grantsome/PhotoGallery]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[支持向量机SVM完全解析--入门级]]></title>
      <url>%2F2017%2F04%2F01%2F%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90-%E5%85%A5%E9%97%A8%E7%BA%A7%2F</url>
      <content type="text"><![CDATA[支持向量机（SVM：Support Vector Machine）是新一代基于统计理论基础的学习系统 Grantsome（管山林）编写，转载请注明出处：http:http://www.grantsome.com/2017/03/26/SVM%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90-%E5%85%A5%E9%97%A8%E7%BA%A7/1、概念：支持向量机是新一代基于统计理论基础的学习系统。支持向量机方法是建立在统计学习理论的VC维理论和结构风险最小原理基础上的，根据有限的样本信息在模型的复杂性（即对特定训练样本的学习精度）和学习能力（即无错误地识别任意样本的能力）之间寻求最佳折中，以求获得最好的推广能力 。可能看到这里大家就有疑惑了，什么是VC理论？什么又是结构风险最小呢？什么是VC理论？简单易理解的解释是：VC是统计学理论用来衡量函数集性能的一种指标。准确的定义：对于一个指示函数集，如果存在h个数据样本能够被函数集中的函数按所有可能的2^h种形式分开 ，则称函数集能够把h个数据样本打散（shatter）。函数集的VC维就是能打散的最大数据样本数目h。若对任意数目的数据样本都有函数能将它们shatter，则函数集的VC维为无穷大。还是不懂对吧?没关系，下面举一个例子，你就大概能够明白什么是VC维了。（1）平面内只能找到3个点能被直线打散：直线只能把一堆点分成两堆，对于3个点，要分成两堆加上顺序就有2^3种。其中A、B、C表示3个点，+1，-1表示堆的类别， {A→-1,BC→+1}表示A分在标号为-1的那堆，B和C分在标号为+1的那堆。这就是一种分发。以此类推。则有如下8种分法：{A→-1,BC→+1}，{A→+1,BC→-1}{B→-1,AC→+1}，{B→+1,BC→-1}{C→-1,AB→+1}，{C→+1,BC→-1}{ABC→-1}，{ABC→+1}函数集的VC维就是能打散的最大数据样本数目，这里VC维就是8。（2）找不到4个点。假设有，则应该有2^4=16分法，但是把四个点分成两堆有：一堆一个点另一对三个点（1，3）；两两均分（2，2）；一堆四个另一堆没有（0，4）三种情况。对于第一种情况，4个点可分别做一次一个一堆的，加上顺序就有8种：{A→-1,BCD→+1}，{A→+1,BCD→-1}{B→-1,ACD→+1}，{B→+1,ACD→-1}{C→-1,ABD→+1}，{C→+1,ABD→-1}{D→-1,ABC→+1}，{D→+1,ABC→-1}对于第二种情况有4种：{AB→-1,CD→+1}，{AB→+1,CD→-1}{AC→-1,BD→+1}，{AC→+1,BD→-1}没有一条直线能使AD在一堆，BC在一堆，因为A、D处在对角线位置，B、C处在对角线位置。（这是我直观在图上找出来的）对于第三种情况有2种；{ABCD→-1}{ABCD→+1}所以总共加起来只有8+4+2=14种分法，不满足2^4=16分法，所以平面找不到4个点能被直线打散。你可能又想问了，那么到底怎么计算VC维呢？不好意思，遗憾的是，目前尚没有通用的关于如何计算任意函数集的VC维的理论，只有对一些特殊的函数集的VC维可以准确知道。第一个概念，我想我大概也只能解释到这里了,如果还有什么不明白的，欢迎留言，觉得我写得哪里有问题的，请指出。下面我们来看看第二个概念，结构风险最小原理。结构化风险 = 经验风险 + 置信风险经验风险 = 分类器在给定样本上的误差置信风险 = 分类器在未知文本上分类的结果的误差对于给定的样本数量越大，学习结果越有可能正确，此时置信风险越小。分类函数的VC维，显然VC维越大，推广能力越差，置信风险会变大。提高样本数量，降低VC维，降低置信风险。这就是SVM的基础和目标，也是使用SVM的优势所在（优势和具体应用将在下面进行说明）。概念就大概说到这里，下面进入正题。 2、基本思想SVM，可以说它是一种算法，因为在机器学习的领域当中，常常把算法看做是一个机器，这种算法被称为学习机器或者学习系统。SVM属于有导师监督的学习算法(利用一组已知类别的样本调整分类器的参数，使其达到所要求性能的过程)，即已知训练及其所对应的类别，求训练点和类别之间的关系，以便将训练集按照类别分开，或者是预测新的训练点所对应的类别。首先讲解一个概念。超平面：数学中超平面是n维欧氏空间中余维度等于一的线性子空间。这是平面中的直线、空间中的平面之推广。超平面H是从n维空间到n-1维空间的一个映射子空间，它有一个n维向量和一个实数定义。设d是n维欧式空间R中的一个非零向量，a是实数，则R中满足条件dX=a的点X所组成的集合称为R中的一张超平面。这个概念有点抽象，直观一点的理解是这样子：实3维空间中，满足三元一次方程ax+by+cz=d的点(x,y,z)的全体在几何上是空间的一张平面。推而广之，n维空间中, 满足n元一次方程a1x1+a2x2+…+anxn=b的点(x1,x2,…,xn)的全体就叫空间的一张超平面（即广义平面）。由于3维以上的线性空间是比较抽象的概念，无法用现实世界中的具象物来比拟，所以唯有定义才能刻画它。SVM构建了一个分割两类的超平面，在构建的过程中试图实现使两类之间的分割达到最大化。有人可能又不明白了，为什么要使得两类之间的分割达到最大化呢？有什么好处吗？当然有好处，分割最大化（以一个很大的边缘分割）可以使得期望的泛误差化最小。泛误差最小的含义是：当对于新的样本（数据未知的数据点）进行分类时，基于学习系统或者学习机器所得到的分类器（超平面）,使得我们对其分类的预测错误的几率被最小化。直观来讲，这样的分类器（超平面）实现了两个类别之间的分离边缘最大化。来上图片，请看下图。问如何画两条直线使得平面上的两种点能够得到最好的区分？先想一下，马上揭晓答案。来看下面这张图片的划分，你觉得怎么样？这一张图片的划分呢?哪一个更准确？划分的误差更小？我们要的就是让它误差最小（图中所画的不一定是最小的）。当然第二张图片的划分比第三张误差更小（因为第二张图片有3个误差点，第三张图片不止4个误差点）。所以分割最大化这个概念应该能够理解了吧。和分类器平面平行，分别穿过平面数据集中的一个或者多个点的两个平面就是边界平面。这些边界平面称为边缘，而SVM学习就是为了找到这个最大化的边缘超平面。落在边界平面上面的点称为支持向量。如图所示现在明白了吧?简单总结一下，支持向量机就是与分类器平行的两个超平面，这两个超平面能够很好的分开两类不同的数据，且穿越两类数据区域中集中的点，现预找到最佳超几何分布平面使之与两个超平面之间的距离最大，如此便能实现分类的总误差变小。 3、理论基础支持向量机最初是在研究线性可分问题的过程中提出来的。所以先来介绍线性SVM的基本原理，过程有点小复杂，还请各位耐心看完。一般使用X表示输入空间，Y表示输出域。通常X∈Rn，对于两类问题，Y = {-1, 1};对于多类问题，Y = {1,2,…,m}; 训练集是训练数据（样本）的集合，通常S=((x1,y1),..(xn, yn)) ∈（X×Y）n，其中n是样本数目，xi是样本(向量)，yi是它们的标记。假设样本容量为n的训练样本点集{(x{i},y{i}),i=1,2,3,4…n}，由两个类别组成。若x{i}属于第一类，则记为y{i}=1；同样的道理,若x{i}属于第二类，则记为y{i}=-1。若存在超平面： w^{T}x+b=0其中 x_{i}、x、w、b表示的是向量,而不是一个值。 为什么呢？为什么b也是一个向量呢？还记得线性代数或者常微分方程吗？ 不记得了的话请看这里这个是不是我们的超平面方程很像？是的，没错。你把b移到右边来就是这个方程组。所以，b可以是一个向量。现在理解了吗？能够将样本正确的划分成两类,即相同的类别落在超平面的同一侧，则称样本点集是线性可分的，即满足 w^{T}x+b ≥1 yi=1 w^{T}x+b≤-1 yi=-1此处,可知平面w^Txi+b=1;w^Txi+b=-1该问题的超平面。但或许大家又想问了：为何用y取1 或者 -1来表示两个不同的类别呢？其实，这个1或-1的分类标准起源于logistic回归，我们就先来看看这个logistic回归，这里只是简单介绍一下logistic回归。Logistic回归为概率型非线性回归模型，是研究二分类观察结果与一些影响因素之间关系的一种多变量分析方法。通常的问题是，研究某些因素条件下某个结果是否发生，比如医学中根据病人的一些症状来判断它是否患有某种病。 在讲解Logistic回归理论之前，我们先从LR分类器说起。LR分类器，即Logistic Regression Classifier。在分类情形下，经过学习后的LR分类器是一组权值，当测试样本的数据输入时，这组权值与测试数据按w0,w1,w2…..wn照线性加和得到这里是每个样本的个特征。之后按照sigmoid函数的形式求出由于sigmoid函数的定义域为负无穷到正无穷，值域为（0，1），因此最基本的LR分类器适合对两类目标进行分类。所以Logistic回归最关键的问题就是研究如何求得这组权值.下面正式地来讲Logistic回归模型。考虑具有个独立变量的向量星x={x1,x2,x3,x4….xn}，设条件慨率P(y=1|x)=p为根据观测量相对于某事件x发生的概率。那么Logistic回归模型可以表示为这里称为Logistic函数。图像如图所示其中那么在条件下不发生的概率为所以事件发生与不发生的概率之比为这个比值称为事件的发生比（the odds of experiencing an event），简记为odds。取对数得到其中0&lt;p&lt;1可以看出Logistic回归都是围绕一个Logistic函数来展开的。当我们要判别一个其他的数据点属于哪个类时，只需求，p若大于0.5就是y=1的类，反之属于y=0类。我们这次使用的结果标签是y=-1,y=1，替换在logistic回归中使用的y=0和y=1。w^Tx=w1x1+w2x2+w3x3+w4x4+…+wnxn。从而第一个分类超平面就得到了解释。我们回到刚刚那里， w^{T}x+b ≥1 yi=1 w^{T}x+b≤-1 yi=-1此处,可知平面w^Txi+b=1;w^Txi+b=-1该问题的超平面。 并且对于平面w^T*xi+b=1而言到超平面的原点的距离为：|b-1|//||w||,该方程不仅仅适用于二维平面（在 二维平面上是很好证明的）和三维。也是用于高维。为什么呢？我们先在二维平面上面看看，也就是一条直线 ax+by+c=1;那么这个点到原点的距离是不是就是|a0+b0+c-1|/|(a^2+b^2)^0.5|?也就是|c-1|/|(a^2+b^2)^0.5|。同理,在三维ax+by+cz+d=0上面,结果：|d-1|/|(a^2+b^2+c^2)^0.5|继续拓展到高维，结果是不是已经不言而喻了？ 所以超平面的原点的距离为：|b-1|//||w||。这个一定是对的。不要怀疑同理，对于w^Txi+b=1而言，到超平面的原点的距离为：|b+1|//||w||。所以两个超平面之间的距离是2/||w||（这两个超平面之间思想相互平行的）。根据SVM的思想，应该使得两个超平面之间的距离最大化，也就是（2/||w||）max,转换一下，相当于对（||w||/2）min.即是说：min: ||w||/2=sqrt(w^Tw)/2为了求解该超平面方程,可以最小化上式。又要满足刚刚的那两个方程，可以表达成 yi(w^Txi+b)≥1现在转化成为如下目标规划 min ||w||/2=sqrt(w^Tw)/2s.t. yi(w^T*xi+b)≥1也就是二规划问题（QP问题）。并且约束条件是线性的。将约束条件变化一下：可得现在我们通过拉格朗日变换到拉格朗日对偶变量。拉格朗日变换的作用，简单来说就是：通过给每一个约束条件乘以一个拉格朗日乘值α,然后带入目标函数中。那么我们的问题的拉格朗日表达式为： 其中 b=-1/2w(xr+xs);xr和xs是任意一对支持向量。那么怎么知道xr和xs呢？我们刚刚看到带入到这里里面就可以进行求解对应的支持向量了。这是一般的情况，假如是下面这种情况呢？在输入空间中，如果它是线性不可分的呢？这时候，我们的处理方法稍微变换了一下。让支持向量机通过非线性映射φ：n维度的R -&gt; F将数据映射到某个其他维度点集空间（称为特征空间），然后在F中执行上述线性算法，这需要φ^Tφ完成映射，这一函数称之为核函数。一图胜过千言假如我们映射到高维空间之后还是不可分怎么样？想一下？不卖关子了。先看图这一张图片不怎么明显，这一张图片看到那一个黄色的方块了吧。那一个点是不是让你觉得很烦？想把它舍弃？可以看到一个离群点（可能是噪声）可以造成超平面的移动，间隔缩小，可见以前的模型对噪声非常敏感。再有甚者，如果离群点在另外一个类中，那么这时候就是线性不可分了。这时候我们应该允许一些点游离并在在模型中违背限制条件（函数间隔大于1）。我们设计得到新的模型如下（也称软间隔）：引入非负参数εi后（称为松弛变量），就允许某些样本点的函数间隔小于1，即在最大间隔区间里面，或者函数间隔是负数，即样本点在对方的区域中。而放松限制条件后，我们需要重新调整目标函数，以对离群点进行处罚，目标函数后面加上，松弛变量的求和乘以C，表示离群点越多，目标函数值越大，而我们要求的是尽可能小的目标函数值。这里的C是离群点的权重，C越大表明离群点对目标函数影响越大，也就是越不希望看到离群点。我们看到，目标函数控制了离群点的数目和程度，使大部分样本点仍然遵守限制条件。引入松弛变量（惩罚因子）后，有一种很常用的变形可以用来解决分类问题中样本的“偏斜”问题。 这个式子有这么几点要注意： （1）并非所有的样本点都有一个松弛变量与其对应。实际上只有“离群点”才有，或者也可以这么看，所有没离群的点松弛变量都等于0（对负类来说，离群点就是在前面图中，跑到H2右侧的那些负样本点，对正类来说，就是跑到H1左侧的那些正样本点）。 （2）松弛变量的值实际上标示出了对应的点到底离群有多远，值越大，点就越远。 （3）惩罚因子C决定了你有多重视离群点带来的损失，显然当所有离群点的松弛变量的和一定时，你定的C越大，对目标函数的损失也越大，此时就暗示着你非常不愿意放弃这些离群点，最极端的情况是你把C定为无限大，这样只要稍有一个点离群，目标函数的值马上变成无限大，马上让问题变成无解，这就退化成了硬间隔问题。 （4）惩罚因子C不是一个变量，整个优化问题在解的时候，C是一个你必须事先指定的值，指定这个值以后，解一下，得到一个分类器，然后用测试数据看看结果怎么样，如果不够好，换一个C的值，再解一次优化问题，得到另一个分类器，再看看效果，如此就是一个参数寻优的过程，但这和优化问题本身决不是一回事，优化问题在解的过程中，C一直是定值，要记住。 （5）尽管加了松弛变量这么一说，但这个问题仍然是一个优化问题，解它的过程比起原始的硬间隔问题来说，没有任何更加特殊的地方。对于解决引入了松弛变量的SVM问题，我们也有我们的解法。我们现在再来看一下这一个引入了松弛变量之后的方程这个模型经过一个叫做Mangasarian的证明之后，得到如下可以近似求解的方程组也就是把1/2||w||^2去掉了，我们只需要利用这个结果就可以了。好了，理论就暂时解释到这里。简单总结一下。支持向量机的四个要点：①最大化距离②核函数③对偶理论④松弛变量。当然，如果你觉得我没有讲清楚，戳这里：http://www.matlabsky.com/thread-10309-1-1.html 4、案例分析+代码实现一个银行的商业贷款经理想要建立一个规则来决定是否批准各种贷款要求。经理认为在做决策的时候，一个公司业绩的三个关键特征是非常重要的：资产折现能力，盈利能力，活性。这个经理以目前资产和负债比作为资产的折现力的度量。盈利能力以净利润和销售额之比度量，活性以销售额和固定资产之比作为度量。这个经理收集了银行在过去五年内的18个样本于下表中。这些贷款被分为两组：1表示批准贷款，-1表示拒绝贷款。试着建立该问题分类的SVM模型。数据在这里： 首先我们来分析一下这个问题。该问题很明显是一个分类的问题， 具体的解法是：我们首先对给出的三个重要的指标进行数据标准化处理，至于为什么要进行数据标准化以及怎么进行数据标准化处理，戳这里。http://blog.sina.com.cn/s/blog_4ee13c2c0100o92b.html数据标准化处理过后，首先得到标准化处理过后的矩阵的行数m和列数n。首先生成一个m1的元素都为1的向量e。然后令b=-e,就是一个m1的元素都为-1的向量。这个向量b就是我们的线性规划模型里面的方程组Ax&lt;=b里面的b。接着取出我们已有数据的分类结果，也就是类别一列的数据。所形成的的向量为D。我们之前数据化标准化之后的三列分别点乘-D，这里是点乘，点乘是阶数相同的向量或矩阵之前对应的位置相乘。为什么是-D呢？因为我们之前的方程是: 约束条件≥B.而MATLAB里面求解线性规划的格式是对应的约束条件≤F,所以要在约束条两边同时乘以-1，现在就变成了： -约束条件≤-B。而乘以D的原因，还记得那个公式吗？这样应该很明显了吧？然后在取一个初始解，到此为止，模型的求解就算基本完成了。还有最后一步，模型的验证与结果显示，这一步也很关键。我们之求得了一个解x=(x1,x2,x3,x4);该超平面是ax1+bx2+c*x3-x4=0;因为线性方程组的原因，这里是-x4;可以去推导看看。（如果A的第四列那里改负的，这里就是+ x4了）。然后计算一下超平面的分类结果,并使用sign(R)函数（该函数的作用：如果R&gt;0,就输出1,R=0;输出0，R&lt;0，输入-1）最后输出就可以了。代码在这里： function [] = svm_first() %UNTITLED ´线性规划求解SVM模型 % 清空环境变量，读入数据 clc clear all X0=xlsread(&#39;G:\MATLAB\Function\svm_data.xlsx&#39;,&#39;B2:E19&#39;); for i = 1:3 X(:,i)=(X0(:,i)-mean(X0(:,i)))/std(X0(:,i)); %数据标准化处理 end % 数据预处理 [m,n]=size(X); e=ones(m,1); D=[X0(:,4)]; B=zeros(m,m); C=zeros(m,m); for i=1:m B(i,i)=1; C(i,i)=D(i,1); end % 转化成线性规划来求解 A=[-X(:,1).*D,-X(:,2).*D,-X(:,3).*D,D,-B]; b=-e; f=[0,0,0,0,ones(1,m)]; lb=[-Inf,-Inf,-Inf,-Inf,zeros(1,m)]&#39;; x=linprog(f,A,b,[],[],lb); % 模型的验证和输出 W=[x(1,1),x(2,1),x(3,1)]; CC=x(4,1); X1=[X(:,1),X(:,2),X(:,3)]; R1=X1*W&#39;-CC; R2=sign(R1); disp(&#39;³ÌÐòÊä³ö½á¹û£º&#39;); disp(&#39;³¬Æ½Ãæ·½³Ì£º&#39;); disp(&#39;X1&#39;); disp(num2str(x(1,1))); disp(&#39;X2&#39;); disp(num2str(x(2,1))); disp(&#39;X3&#39;); disp(num2str(x(3,1))); disp(&#39;intercept:&#39;); disp(num2str(x(4,1))); disp(&#39;³¬Æ½Ãæ·ÖÀà½á¹û&#39;); R=[R1,R2] end 运行结果：源码和数据下载地址:(电脑上面可能需要翻墙，手机可以直接进去)https://github.com/Grantsome/SVM_First 5、模型的优缺点及其改进(1)优点：①SVM 是一种有坚实理论基础的新颖的小样本学习方法。它基本上不涉及概率测度及大数定律等,因此不同于现有的统计方法。从本质上看,它避开了从归纳到演绎的传统过程,实现了高效的从训练样本到预报样本的“转导推理”,大大简化了通常的分类和回归等问题。②SVM 的最终决策函数只由少数的支持向量所确定,计算的复杂性取决于支持向量的数目,而不是样本空间的维数,这在某种意义上避免了“维数灾难”。③少数支持向量决定了最终结果,这不但可以帮助我们抓住关键样本、“剔除”大量冗余样本,而且注定了该方法不但算法简单,而且具有较好的“鲁棒”性。这种“鲁棒”性主要体现在:增、删非支持向量样本对模型没有影响;支持向量样本集具有一定的鲁棒性;有些成功的应用中,SVM 方法对核的选取不敏感(2)缺点① SVM算法对大规模训练样本难以实施由于SVM是借助二次规划来求解支持向量，而求解二次规划将涉及m阶矩阵的计算（m为样本的个数），当m数目很大时该矩阵的存储和计算将耗费大量的机器内存和运算时间。针对以上问题的主要改进有有J.Platt的SMO算法、T.Joachims的SVM、C.J.C.Burges等的PCGC、张学工的CSVM以及O.L.Mangasarian等的SOR算法② 用SVM解决多分类问题存在困难经典的支持向量机算法只给出了二类分类的算法，而实际应用中，一般要解决多类的分类问题。可以通过多个二类支持向量机的组合来解决。主要有一对多组合模式、一对一组合模式和SVM决策树；再就是通过构造多个分类器的组合来解决。主要原理是克服SVM固有的缺点，结合其他算法的优势，解决多类问题的分类精度。如：与粗集理论结合，形成一种优势互补的多类问题的组合分类器。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android拍照并显示Demo]]></title>
      <url>%2F2017%2F03%2F29%2FAndroid%E6%8B%8D%E7%85%A7%E5%B9%B6%E6%98%BE%E7%A4%BADemo%2F</url>
      <content type="text"><![CDATA[拍照并显示这是一个很常见的功能，各个APP几乎都有这个功能，作为一个Android程序猿，你想怎么实现呢？拍照直接进入正题吧。思路分析如下：先来一张图通过Context.getExternalCacheDir()方法可以获取到 SDCard/Android/data/你的应用包名/cache/目录，一般存放临时缓存数据创建File对象 实现图片存储的路径File(direction,filename)的这个构造方法传入的参数是我们需要的两个参数,第一个是文件路径，第二是文件名将file转化为uri如果BuildSDK&gt;24通过FileProvider.getUriForFile()来得到我们在Manifest.xml里面注册过的FileProvider的文件的路径,里面的参数有三个,第一个就是content,第一个就是唯一的表示的名称，一般使用Android的文件的包名加上provider,第三个就是文件名如果不是,就使用直接Uri.FromFile(),创建隐式intent拍照,将图片输入到指定位置的URI然后用new Intent()直接新建一个拍照的变量里面的参数为”android.media.action.IMAGE_CAPTURE”(PS:android.media.action.IMAGE_CAPTURE：Intent的Action类型，从现有的相机应用中请求拍摄一张图片)MediaStore.EXTRA_OUTPUT:拍照生成的图片由于没有保存在data,需要有个地方保存图片,而这key-value就是指图片保存的URI，指向文件的地址.intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri)-此设置需要一个Uri对象，这个对象指定了一个保存图像的路径和文件名．启动相机并传递参数startActivityForResult();在对应onActivityResult里面进行处理使用bitmap = Bitmapfactory.decodeStream();里面的参数填写getContentResolver().openInputStream();其中contentProvider().openInputStream(imageUri)：一定要的内容其提供器里面的方法；里面的参数是本地图片的uri。之前我们已经获取然后在使用imageView.setImageBitmap(bitmap);用来显示图片贴上代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MainActivity extends AppCompatActivity &#123; private ImageView mImageView; private Button mTakePhotoButton; private static final int TAKE_PHOTO = 1; private Uri imageUri; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mImageView = (CircleImageView) findViewById(R.id.civ); String uri = null; mTakePhotoButton = (Button) findViewById(R.id.take_photo); setTakePhotoButtonOnClickListener(); &#125; private void setTakePhotoButtonOnClickListener()&#123; mTakePhotoButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; File outputImage = new File(getExternalCacheDir(),"output_image.jpg"); try&#123; if(outputImage.exists())&#123; outputImage.delete(); &#125; outputImage.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if(Build.VERSION.SDK_INT&gt;24)&#123; imageUri = FileProvider.getUriForFile(MainActivity.this,"com.grantsome.mycicleimage.provider",outputImage); &#125;else &#123; imageUri = Uri.fromFile(outputImage); &#125; Intent intent = new Intent("android.media.action.IMAGE_CAPTURE"); intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri); startActivityForResult(intent,TAKE_PHOTO); &#125; &#125;); &#125; @Override protected void onActivityResult(int requestCode,int resultCode,Intent data)&#123; switch (requestCode)&#123; case TAKE_PHOTO: if(resultCode ==RESULT_OK) &#123; try &#123; Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri)); mImageView_1.setImageBitmap(bitmap); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; break; default: break; &#125; &#125;&#125; 之前不是说过这里有一个内容提供器吗？现在我们就来看看这个内容提供器的具体的实现123456789&lt;provider android:exported="false" android:grantUriPermissions="true" android:authorities="com.grantsome.mycircleimage.provider" android:name="android.support.v4.content.FileProvider"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/path"/&gt;&lt;/provider&gt; 我们来意义分析一下是这里面的一些属性的意义和作用首先看provider里面的属性属性：android:authorities:一个或多个URI权限的列表，用于标识内容提供器提供的数据，通过用分号分隔他们的名字列出多个权限。为了避免冲突，权限名称应该使用Java风格的命名约定（如com.example.provider.cartoonprovider ）。 通常，它是实现提供者的ContentProvider子类的名称没有默认值。必须至少指定一个权限。 android:exported内容提供商是否可供其他应用使用：true ：提供程序可用于其他应用程序。 任何应用程序都可以使用提供者的内容URI来访问它，但必须遵守为提供者指定的权限。false ：提供程序不适用于其他应用程序。 设置android:exported=”false”以限制对您的应用程序的提供程序的访问。 只有与提供者具有相同用户ID（UID）的应用程序才能访问它。因为这个属性是在API级别17中引入的，所以运行API级别16和更低级别的设备就像这个属性设置为”true” 。 如果将android:targetSdkVersion设置为17或更高版本，则运行API级别17及更高版本的设备的默认值为”false” 。您可以设置android:exported=”false” ，并通过权限属性设置权限来限制对您的提供者的访问。 android:grantUriPermissions通常无权访问内容提供者数据的用户是否可以获得这样做的权限，暂时克服readPermission ， writePermission和permission属性所施加的readPermission ，如果可以授予权限， true “ true ”，而“ false “如果没有。 如果为“ true ”，则可以向任何内容提供者的数据授予权限。 如果为“ false ”，则只能授予子元素（如果有）中列出的数据子集的 。 默认值为“ false ”。授予权限是向应用程序组件一次访问受权限保护的数据的一种方式。 例如，当电子邮件消息包含附件时，邮件应用程序可以呼叫适当的查看者来打开它，即使观众没有一般权??限来查看所有内容提供商的数据。在这种情况下，在FLAG_GRANT_READ_URI_PERMISSION FLAG_GRANT_WRITE_URI_PERMISSION的Intent对象中由FLAG_GRANT_READ_URI_PERMISSION和FLAG_GRANT_WRITE_URI_PERMISSION标志授予权限。 例如，邮件应用程序可能FLAG_GRANT_READ_URI_PERMISSION FLAG_GRANT_READ_URI_PERMISSION放入传递给Context.startActivity()的Intent中。 该权限特定于Intent中的URI。如果启用此功能，通过将此属性设置为“ true ”或通过定义子元素，必须在从提供程序中删除被覆盖的URI时调用Context.revokeUriPermission() 。简单来说就是这样子：比如当application A需要使用Component B去访问Provider C，但是Component B并未添加Provider C的Read/Write permission，如果这个Provider设置了属性android:grantUriPermissions，那么就有办法使Component B访问C。 android:name实现内容提供者的类的名称，ContentProvider的子类。 这应该是一个完全限定的类名（如“ com.example.project.TransportationProvider ”）。 但是，作为一个简写，如果名称的第一个字符是一个句点，它将附加到元素中指定的包名称中。没有默认值。 必须指定名称。 其他的属性，官方文档欢迎你https://developer.android.com/guide/topics/manifest/provider-element.html 接着看一看meta-date里面的属性meta-data可以提供给父组件的附加任意数据项的名称 - 值对。 组件元素可以包含任意数量的子元素。 所有这些值都收集在一个Bundle对象中，并作为PackageItemInfo.metaData字段提供给PackageItemInfo.metaData 。通过value指定普通值。 但是，要分配资源ID作为值，请改用resource属性。 例如，以下代码将@string/kangaroo资源中存储的任何值分配给“ zoo ”名称： 另一方面，使用resource属性将分配“ zoo ”资源的数字ID，而不是资源中存储的值： 强烈建议您避免将相关数据提供为多个单独的条目。 相反，如果您有复杂的数据与组件关联，则将其作为资源存储，并使用resource属性通知组件的ID。 属性：android:name该项目的唯一名称。 为了确保名称是唯一的，请使用Java风格的命名约定，例如“ com.example.project.activity.fred ”。android:resource对资源的引用。 资源的ID是分配给项目的值。 可以通过Bundle.getInt()方法从元数据包中Bundle.getInt() 。android:value分配给该项目的值。 可以分配为值的数据类型和组件用于检索这些值的Bundle方法列在下表中：觉得还不够？满足不了你对知识的渴望？戳这里：https://developer.android.com/guide/topics/manifest/meta-data-element.html好了 做完了介绍我们在回头看一下这几行xml文件代表的意思：123456789&lt;provider android:exported="false" android:grantUriPermissions="true" android:authorities="com.grantsome.mycircleimage.provider" android:name="android.support.v4.content.FileProvider"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/path"/&gt;&lt;/provider&gt; 该内容提供器不可供其他应用程序使用，只能在本应用程序中使用，且对于本应用程序中没有访问权限的元素也可以访问该内容提供器。设置了一个唯一的标识符authorities。里面的附加了一个mete-data的数据项，在数据项里面引用了一个xml文件里面的path。现在应该清楚明白了吧？这个上面不是写了一个path文件吗？我们在resource下面新建一个文件夹xml然后在xml里面新建一个path.xml123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;paths&gt; &lt;external-path name="images" path="" /&gt; &lt;/paths&gt;&lt;/resources&gt; 下面这个说明可以帮助你理解为什么是这样子： //相当 Context.getFilesDir() + path, name是分享url的一部分 12345678&lt;cache-path name="name" path="path" /&gt; //getCacheDir()&lt;external-path name="name" path="path" /&gt; //Environment.getExternalStorageDirectory()&lt;external-files-path name="name" path="path" /&gt;//getExternalFilesDir(String) Context.getExternalFilesDir(null)&lt;external-cache-path name="name" path="path" /&gt; //Context.getExternalCacheDir() path路径的值表示共享的具体路径，这里设置空值表示整个SD卡都进行共享.其中path=””,代表根目录,如果是path=”images”,表示可以向其他应用共享根目录以及其子目录的任何文件. 则表示目录名为:/storage/emulated/0/images,如果你向其他应用分享images目录范围之外的文件是不行.现在我们要画一个思维导图来梳理一下我们的思维。当然 GitHub地址是不可缺少的，戳这里 https://github.com/Grantsome/MyCircleImage好了，拍照就写到这里，觉得我写得有问题的请指出，在下万分感谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RecyclerView完全解析--入门级]]></title>
      <url>%2F2017%2F03%2F26%2FRecyclerView%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90-%E5%85%A5%E9%97%A8%E7%BA%A7%2F</url>
      <content type="text"><![CDATA[第一篇博客,里面并没有什么特别的东西,只是为了测试一下。复制粘贴我之前已经写好一些文章。关于RecyclerView.ViewHolder的第一次总结，由于本人水平有限,比较垃圾,总结一下希望自己能够理解 第一步首先继承RecyclerView.ViewHolder1234567891011121314151617181920public class ViewHolder extends RecyclerView.ViewHolder&#123; //首先把需要的控件简单声明一下,暂时不用实例化 public TextView textView; public ImageView imageView; //调用父类的构造方法,实现实例化功能 public ViewHolder(View itemView)&#123; //必须写的super方法 super(itemView); //初始化需要的控件,注意必须是itemView.findViewById(); textView = (TextView) itemView.findViewById(R.id.); imageView = (TextView) itemView.findViewByIf(R.id.); &#125;&#125; 下面写一下如何在其他地方使用ViewHolder;一般在public ViewHolder onCreateViewHolder(ViewGroup parent,int viewType)里面写这个方法123456 public ViewHolder onCreateViewHolder(ViewGroup parent,int viewType)&#123; LayoutInflater layoutInflater = LayoutInflater.from(context); View viewItem = layoutInflater.inflate(R.layout. ,parent,false); ViewHolder viewHolder = new ViewHolder(viewItem); return viewHolder;&#125; 当然这里少不了RecyclerView.Adapter首先继承RecyclerView.Adapter 12345678910111213141516171819202122232425262728293031323334353637public class MyAdapter extends RecyclerView.Adapter&#123; //把需要的数据简单声明一下,暂时不用实例化 private List&lt;Crime&gt; crimes; private Context context; //然后调用父类的构造器,实现实例化功能 public MyAdapter(Context context,List&lt;Crime&gt; crimes)&#123; this.context = context; this.crimes = crimes; &#125; //复写的第一个方法 //主要的作用是实例化ViewHolder,一般格式都是这样子 public ViewHolder onCreateViewHolder(ViewGroup parent,int viewType)&#123; LayoutInflater layoutInflater = LayoutInflater.from(context); View itemView = layoutInflater.inflate(R.layout. ,parent,false); ViewHolder viewHolder = new ViewHolder(itemView); return viewHolder; &#125; //主要作用是将viewHolder和position绑定,并给ViewHolder里面的元素/属性赋值 public void onBindViewHolder(ViewHolder viewHolder,int position)&#123; //通过position的位置实例化crime类 Crime crime = crimes.get(position); //向ViewHolder中的textView赋值 viewHolder.textView.setText(crime.getTitle()); &#125; //首先调用的就是这个方法,返回数值/列表中有多少个对象 public int getItemCount()&#123; return crimes.size(); &#125; &#125; 下面写一下如何在其他地方调用/使用MyAdapter 如果是继承的FragmentActivity,一般就在public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState)方法里面 如果是继承的AppCompatActivity,一般就在protected void onCreate(Bundle savedInstanceState)方法里面12345678910public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState)&#123; //声明一个RecyclerView的组件 private RecyclerView recyclerView; //实例化RecyclerView recyclerView = (RecyclerView) findViewById(R.id.); //实例化MyAdapter MyAdapter myAdapter = new MyAdapter(context,crimes); //给RecyclerView设置adapter recyclerView.setAdapter();&#125;]]></content>
    </entry>

    
  
  
</search>
